(()=>{var ur=Object.create;var mt=Object.defineProperty;var lr=Object.getOwnPropertyDescriptor;var hr=Object.getOwnPropertyNames;var cr=Object.getPrototypeOf,pr=Object.prototype.hasOwnProperty;var dr=(u,t,e)=>t in u?mt(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var Ge=(u=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(u,{get:(t,e)=>(typeof require!="undefined"?require:t)[e]}):u)(function(u){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+u+'" is not supported')});var yt=(u,t)=>()=>(u&&(t=u(u=0)),t);var Bt=(u,t)=>()=>(t||u((t={exports:{}}).exports,t),t.exports),fr=(u,t)=>{for(var e in t)mt(u,e,{get:t[e],enumerable:!0})},gr=(u,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of hr(t))!pr.call(u,s)&&s!==e&&mt(u,s,{get:()=>t[s],enumerable:!(n=lr(t,s))||n.enumerable});return u};var zt=(u,t,e)=>(e=u!=null?ur(cr(u)):{},gr(t||!u||!u.__esModule?mt(e,"default",{value:u,enumerable:!0}):e,u));var Ee=(u,t,e)=>(dr(u,typeof t!="symbol"?t+"":t,e),e);var mr,yr,An,ii,si,Ye,nt,xr,br,vr,Ke,wn,ai,xt,bt=yt(()=>{mr=u=>{let t=new Map;t.set("web",{name:"web"});let e=u.CapacitorPlatforms||{currentPlatform:{name:"web"},platforms:t},n=(i,c)=>{e.platforms.set(i,c)},s=i=>{e.platforms.has(i)&&(e.currentPlatform=e.platforms.get(i))};return e.addPlatform=n,e.setPlatform=s,e},yr=u=>u.CapacitorPlatforms=mr(u),An=yr(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),ii=An.addPlatform,si=An.setPlatform;(function(u){u.Unimplemented="UNIMPLEMENTED",u.Unavailable="UNAVAILABLE"})(Ye||(Ye={}));nt=class extends Error{constructor(t,e){super(t),this.message=t,this.code=e}},xr=u=>{var t,e;return u?.androidBridge?"android":!((e=(t=u?.webkit)===null||t===void 0?void 0:t.messageHandlers)===null||e===void 0)&&e.bridge?"ios":"web"},br=u=>{var t,e,n,s,i;let c=u.CapacitorCustomPlatform||null,d=u.Capacitor||{},p=d.Plugins=d.Plugins||{},y=u.CapacitorPlatforms,v=()=>c!==null?c.name:xr(u),m=((t=y?.currentPlatform)===null||t===void 0?void 0:t.getPlatform)||v,l=()=>m()!=="web",h=((e=y?.currentPlatform)===null||e===void 0?void 0:e.isNativePlatform)||l,a=_=>{let k=D.get(_);return!!(k?.platforms.has(m())||w(_))},o=((n=y?.currentPlatform)===null||n===void 0?void 0:n.isPluginAvailable)||a,b=_=>{var k;return(k=d.PluginHeaders)===null||k===void 0?void 0:k.find(M=>M.name===_)},w=((s=y?.currentPlatform)===null||s===void 0?void 0:s.getPluginHeader)||b,I=_=>u.console.error(_),S=(_,k,M)=>Promise.reject(`${M} does not have an implementation of "${k}".`),D=new Map,C=(_,k={})=>{let M=D.get(_);if(M)return console.warn(`Capacitor plugin "${_}" already registered. Cannot register plugins twice.`),M.proxy;let P=m(),A=w(_),f,R=async()=>(!f&&P in k?f=typeof k[P]=="function"?f=await k[P]():f=k[P]:c!==null&&!f&&"web"in k&&(f=typeof k.web=="function"?f=await k.web():f=k.web),f),N=(q,H)=>{var U,J;if(A){let ee=A?.methods.find(Z=>H===Z.name);if(ee)return ee.rtype==="promise"?Z=>d.nativePromise(_,H.toString(),Z):(Z,Y)=>d.nativeCallback(_,H.toString(),Z,Y);if(q)return(U=q[H])===null||U===void 0?void 0:U.bind(q)}else{if(q)return(J=q[H])===null||J===void 0?void 0:J.bind(q);throw new nt(`"${_}" plugin is not implemented on ${P}`,Ye.Unimplemented)}},K=q=>{let H,U=(...J)=>{let ee=R().then(Z=>{let Y=N(Z,q);if(Y){let X=Y(...J);return H=X?.remove,X}else throw new nt(`"${_}.${q}()" is not implemented on ${P}`,Ye.Unimplemented)});return q==="addListener"&&(ee.remove=async()=>H()),ee};return U.toString=()=>`${q.toString()}() { [capacitor code] }`,Object.defineProperty(U,"name",{value:q,writable:!1,configurable:!1}),U},O=K("addListener"),V=K("removeListener"),j=(q,H)=>{let U=O({eventName:q},H),J=async()=>{let Z=await U;V({eventName:q,callbackId:Z},H)},ee=new Promise(Z=>U.then(()=>Z({remove:J})));return ee.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await J()},ee},z=new Proxy({},{get(q,H){switch(H){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return A?j:O;case"removeListener":return V;default:return K(H)}}});return p[_]=z,D.set(_,{name:_,proxy:z,platforms:new Set([...Object.keys(k),...A?[P]:[]])}),z},T=((i=y?.currentPlatform)===null||i===void 0?void 0:i.registerPlugin)||C;return d.convertFileSrc||(d.convertFileSrc=_=>_),d.getPlatform=m,d.handleError=I,d.isNativePlatform=h,d.isPluginAvailable=o,d.pluginMethodNoop=S,d.registerPlugin=T,d.Exception=nt,d.DEBUG=!!d.DEBUG,d.isLoggingEnabled=!!d.isLoggingEnabled,d.platform=d.getPlatform(),d.isNative=d.isNativePlatform(),d},vr=u=>u.Capacitor=br(u),Ke=vr(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),wn=Ke.registerPlugin,ai=Ke.Plugins,xt=class{constructor(t){this.listeners={},this.windowListeners={},t&&(console.warn(`Capacitor WebPlugin "${t.name}" config object was deprecated in v3 and will be removed in v4.`),this.config=t)}addListener(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e);let s=this.windowListeners[t];s&&!s.registered&&this.addWindowListener(s);let i=async()=>this.removeListener(t,e),c=Promise.resolve({remove:i});return Object.defineProperty(c,"remove",{value:async()=>{console.warn("Using addListener() without 'await' is deprecated."),await i()}}),c}async removeAllListeners(){this.listeners={};for(let t in this.windowListeners)this.removeWindowListener(this.windowListeners[t]);this.windowListeners={}}notifyListeners(t,e){let n=this.listeners[t];n&&n.forEach(s=>s(e))}hasListeners(t){return!!this.listeners[t].length}registerWindowListener(t,e){this.windowListeners[e]={registered:!1,windowEventName:t,pluginEventName:e,handler:n=>{this.notifyListeners(e,n)}}}unimplemented(t="not implemented"){return new Ke.Exception(t,Ye.Unimplemented)}unavailable(t="not available"){return new Ke.Exception(t,Ye.Unavailable)}async removeListener(t,e){let n=this.listeners[t];if(!n)return;let s=n.indexOf(e);this.listeners[t].splice(s,1),this.listeners[t].length||this.removeWindowListener(this.windowListeners[t])}addWindowListener(t){window.addEventListener(t.windowEventName,t.handler),t.registered=!0}removeWindowListener(t){!t||(window.removeEventListener(t.windowEventName,t.handler),t.registered=!1)}}});function Tr(u){return new DataView(Uint8Array.from(u).buffer)}function Ar(u){return Array.from(new Uint8Array(u.buffer))}function wr(u){return`0000${u.toString(16).padStart(4,"0")}-0000-1000-8000-00805f9b34fb`}function Je(u){let t=u.trim().split(" ").filter(e=>e!=="").map(e=>parseInt(e,16));return Tr(t)}function vt(u){return Ar(u).map(t=>{let e=t.toString(16);return e.length==1&&(e="0"+e),e}).join(" ")}function Sn(u){if(typeof u=="string")return u;if(typeof u=="number")return wr(u);throw new Error("Invalid UUID")}function Gt(u){let t={};if(!!u)return u.forEach((e,n)=>{t[n.toString()]=e}),t}var Tt=yt(()=>{});async function En(u,t,e){let n;return Promise.race([u,new Promise((s,i)=>{n=setTimeout(()=>i(e),t)})]).finally(()=>clearTimeout(n))}var _n=yt(()=>{});var kn={};fr(kn,{BluetoothLeWeb:()=>Kt});var Kt,Dn=yt(()=>{bt();Tt();_n();Kt=class extends xt{constructor(){super(...arguments),this.deviceMap=new Map,this.discoveredDevices=new Map,this.scan=null,this.DEFAULT_CONNECTION_TIMEOUT=1e4,this.onAdvertisementReceivedCallback=this.onAdvertisementReceived.bind(this),this.onDisconnectedCallback=this.onDisconnected.bind(this),this.onCharacteristicValueChangedCallback=this.onCharacteristicValueChanged.bind(this)}async initialize(){if(typeof navigator>"u"||!navigator.bluetooth)throw this.unavailable("Web Bluetooth API not available in this browser.");if(!await navigator.bluetooth.getAvailability())throw this.unavailable("No Bluetooth radio available.")}async isEnabled(){return{value:!0}}async enable(){throw this.unavailable("enable is not available on web.")}async disable(){throw this.unavailable("disable is not available on web.")}async startEnabledNotifications(){}async stopEnabledNotifications(){}async isLocationEnabled(){throw this.unavailable("isLocationEnabled is not available on web.")}async openLocationSettings(){throw this.unavailable("openLocationSettings is not available on web.")}async openBluetoothSettings(){throw this.unavailable("openBluetoothSettings is not available on web.")}async openAppSettings(){throw this.unavailable("openAppSettings is not available on web.")}async setDisplayStrings(){}async requestDevice(t){let e=this.getFilters(t),n=await navigator.bluetooth.requestDevice({filters:e.length?e:void 0,optionalServices:t?.optionalServices,acceptAllDevices:e.length===0});return this.deviceMap.set(n.id,n),this.getBleDevice(n)}async requestLEScan(t){this.requestBleDeviceOptions=t;let e=this.getFilters(t);await this.stopLEScan(),this.discoveredDevices=new Map,navigator.bluetooth.removeEventListener("advertisementreceived",this.onAdvertisementReceivedCallback),navigator.bluetooth.addEventListener("advertisementreceived",this.onAdvertisementReceivedCallback),this.scan=await navigator.bluetooth.requestLEScan({filters:e.length?e:void 0,acceptAllAdvertisements:e.length===0,keepRepeatedDevices:t?.allowDuplicates})}onAdvertisementReceived(t){var e,n;let s=t.device.id;if(this.deviceMap.set(s,t.device),!this.discoveredDevices.has(s)||((e=this.requestBleDeviceOptions)===null||e===void 0?void 0:e.allowDuplicates)){this.discoveredDevices.set(s,!0);let c=this.getBleDevice(t.device),d={device:c,localName:c.name,rssi:t.rssi,txPower:t.txPower,manufacturerData:Gt(t.manufacturerData),serviceData:Gt(t.serviceData),uuids:(n=t.uuids)===null||n===void 0?void 0:n.map(Sn)};this.notifyListeners("onScanResult",d)}}async stopLEScan(){var t;!((t=this.scan)===null||t===void 0)&&t.active&&this.scan.stop(),this.scan=null}async getDevices(t){return{devices:(await navigator.bluetooth.getDevices()).map(s=>(this.deviceMap.set(s.id,s),this.getBleDevice(s)))}}async getConnectedDevices(t){return{devices:(await navigator.bluetooth.getDevices()).filter(s=>{var i;return(i=s.gatt)===null||i===void 0?void 0:i.connected}).map(s=>(this.deviceMap.set(s.id,s),this.getBleDevice(s)))}}async connect(t){var e,n;let s=this.getDeviceFromMap(t.deviceId);s.removeEventListener("gattserverdisconnected",this.onDisconnectedCallback),s.addEventListener("gattserverdisconnected",this.onDisconnectedCallback);let i=Symbol();if(s.gatt===void 0)throw new Error("No gatt server available.");try{let c=(e=t.timeout)!==null&&e!==void 0?e:this.DEFAULT_CONNECTION_TIMEOUT;await En(s.gatt.connect(),c,i)}catch(c){throw await((n=s.gatt)===null||n===void 0?void 0:n.disconnect()),c===i?new Error("Connection timeout"):c}}onDisconnected(t){let n=`disconnected|${t.target.id}`;this.notifyListeners(n,null)}async createBond(t){throw this.unavailable("createBond is not available on web.")}async isBonded(t){throw this.unavailable("isBonded is not available on web.")}async disconnect(t){var e;(e=this.getDeviceFromMap(t.deviceId).gatt)===null||e===void 0||e.disconnect()}async getServices(t){var e,n;let s=(n=await((e=this.getDeviceFromMap(t.deviceId).gatt)===null||e===void 0?void 0:e.getPrimaryServices()))!==null&&n!==void 0?n:[],i=[];for(let c of s){let d=await c.getCharacteristics(),p=[];for(let y of d)p.push({uuid:y.uuid,properties:this.getProperties(y),descriptors:await this.getDescriptors(y)});i.push({uuid:c.uuid,characteristics:p})}return{services:i}}async getDescriptors(t){try{return(await t.getDescriptors()).map(n=>({uuid:n.uuid}))}catch{return[]}}getProperties(t){return{broadcast:t.properties.broadcast,read:t.properties.read,writeWithoutResponse:t.properties.writeWithoutResponse,write:t.properties.write,notify:t.properties.notify,indicate:t.properties.indicate,authenticatedSignedWrites:t.properties.authenticatedSignedWrites,reliableWrite:t.properties.reliableWrite,writableAuxiliaries:t.properties.writableAuxiliaries}}async getCharacteristic(t){var e;let n=await((e=this.getDeviceFromMap(t.deviceId).gatt)===null||e===void 0?void 0:e.getPrimaryService(t?.service));return n?.getCharacteristic(t?.characteristic)}async getDescriptor(t){let e=await this.getCharacteristic(t);return e?.getDescriptor(t?.descriptor)}async readRssi(t){throw this.unavailable("readRssi is not available on web.")}async read(t){let e=await this.getCharacteristic(t);return{value:await e?.readValue()}}async write(t){let e=await this.getCharacteristic(t),n;typeof t.value=="string"?n=Je(t.value):n=t.value,await e?.writeValueWithResponse(n)}async writeWithoutResponse(t){let e=await this.getCharacteristic(t),n;typeof t.value=="string"?n=Je(t.value):n=t.value,await e?.writeValueWithoutResponse(n)}async readDescriptor(t){let e=await this.getDescriptor(t);return{value:await e?.readValue()}}async writeDescriptor(t){let e=await this.getDescriptor(t),n;typeof t.value=="string"?n=Je(t.value):n=t.value,await e?.writeValue(n)}async startNotifications(t){let e=await this.getCharacteristic(t);e?.removeEventListener("characteristicvaluechanged",this.onCharacteristicValueChangedCallback),e?.addEventListener("characteristicvaluechanged",this.onCharacteristicValueChangedCallback),await e?.startNotifications()}onCharacteristicValueChanged(t){var e,n;let s=t.target,i=`notification|${(e=s.service)===null||e===void 0?void 0:e.device.id}|${(n=s.service)===null||n===void 0?void 0:n.uuid}|${s.uuid}`;this.notifyListeners(i,{value:s.value})}async stopNotifications(t){let e=await this.getCharacteristic(t);await e?.stopNotifications()}getFilters(t){var e;let n=[];for(let s of(e=t?.services)!==null&&e!==void 0?e:[])n.push({services:[s],name:t?.name,namePrefix:t?.namePrefix});return(t?.name||t?.namePrefix)&&n.length===0&&n.push({name:t.name,namePrefix:t.namePrefix}),n}getDeviceFromMap(t){let e=this.deviceMap.get(t);if(e===void 0)throw new Error('Device not found. Call "requestDevice", "requestLEScan" or "getDevices" first.');return e}getBleDevice(t){var e;return{deviceId:t.id,name:(e=t.name)!==null&&e!==void 0?e:void 0,uuids:t.uuids}}}});var Fn=Bt((gi,wt)=>{"use strict";function Cn(u){var t=new Ut,e=u|0;function n(p,y,v){return(e|0)!==0?(e=(e|0)-1,new Promise(function(m){m(p.apply(y,v))}).then(i,c)):new Promise(function(m){t.push(new _r(m,p,y,v))}).then(s)}function s(p){try{return Promise.resolve(p.fn.apply(p.self,p.args)).then(i,c)}catch(y){c(y)}}function i(p){return d(),p}function c(p){throw d(),p}function d(){var p=t.shift();p?p.resolve(p):e=(e|0)+1}return n}function Sr(u,t){let e=Cn(u|0);return function(){for(var n=new Array(arguments.length),s=0;s<arguments.length;s++)n[s]=arguments[s];return e(t,this,n)}}function Er(u){let t=Cn(u|0);return function(e){if(typeof e!="function")throw new TypeError("Expected throat fn to be a function but got "+typeof e);for(var n=new Array(arguments.length-1),s=1;s<arguments.length;s++)n[s-1]=arguments[s];return t(e,this,n)}}wt.exports=function(t,e){if(typeof t=="function"){var n=e;e=t,t=n}if(typeof t!="number")throw new TypeError("Expected throat size to be a number but got "+typeof t);if(e!==void 0&&typeof e!="function")throw new TypeError("Expected throat fn to be a function but got "+typeof e);return typeof e=="function"?Sr(t|0,e):Er(t|0)};wt.exports.default=wt.exports;function _r(u,t,e,n){this.resolve=u,this.fn=t,this.self=e||null,this.args=n}var At=64;function Ut(){this._s1=[],this._s2=[],this._shiftBlock=this._pushBlock=new Array(At),this._pushIndex=0,this._shiftIndex=0}Ut.prototype.push=function(u){this._pushIndex===At&&(this._pushIndex=0,this._s1[this._s1.length]=this._pushBlock=new Array(At)),this._pushBlock[this._pushIndex++]=u};Ut.prototype.shift=function(){if(this._shiftIndex===At){this._shiftIndex=0;var u=this._s2;if(u.length===0){var t=this._s1;if(t.length===0)return;this._s1=u,u=this._s2=t.reverse()}this._shiftBlock=u.pop()}if(!(this._pushBlock===this._shiftBlock&&this._pushIndex===this._shiftIndex)){var e=this._shiftBlock[this._shiftIndex];return this._shiftBlock[this._shiftIndex++]=null,e}}});var On=Bt((ns,Qe)=>{"use strict";var $={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(u){this.toString=function(){return"CORRUPT: "+this.message},this.message=u},invalid:function(u){this.toString=function(){return"INVALID: "+this.message},this.message=u},bug:function(u){this.toString=function(){return"BUG: "+this.message},this.message=u},notReady:function(u){this.toString=function(){return"NOT READY: "+this.message},this.message=u}}};$.cipher.aes=function(u){this.s[0][0][0]||this.O();var t,e,n,s,i=this.s[0][4],c=this.s[1];t=u.length;var d=1;if(t!==4&&t!==6&&t!==8)throw new $.exception.invalid("invalid aes key size");for(this.b=[n=u.slice(0),s=[]],u=t;u<4*t+28;u++)e=n[u-1],(u%t===0||t===8&&u%t===4)&&(e=i[e>>>24]<<24^i[e>>16&255]<<16^i[e>>8&255]<<8^i[e&255],u%t===0&&(e=e<<8^e>>>24^d<<24,d=d<<1^283*(d>>7))),n[u]=n[u-t]^e;for(t=0;u;t++,u--)e=n[t&3?u:u-4],s[t]=4>=u||4>t?e:c[0][i[e>>>24]]^c[1][i[e>>16&255]]^c[2][i[e>>8&255]]^c[3][i[e&255]]};$.cipher.aes.prototype={encrypt:function(u){return Ln(this,u,0)},decrypt:function(u){return Ln(this,u,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],O:function(){var u=this.s[0],t=this.s[1],e=u[4],n=t[4],s,i,c,d=[],p=[],y,v,m,l;for(s=0;256>s;s++)p[(d[s]=s<<1^283*(s>>7))^s]=s;for(i=c=0;!e[i];i^=y||1,c=p[c]||1)for(m=c^c<<1^c<<2^c<<3^c<<4,m=m>>8^m&255^99,e[i]=m,n[m]=i,v=d[s=d[y=d[i]]],l=16843009*v^65537*s^257*y^16843008*i,v=257*d[m]^16843008*m,s=0;4>s;s++)u[s][i]=v=v<<24^v>>>8,t[s][m]=l=l<<24^l>>>8;for(s=0;5>s;s++)u[s]=u[s].slice(0),t[s]=t[s].slice(0)}};function Ln(u,t,e){if(t.length!==4)throw new $.exception.invalid("invalid aes block size");var n=u.b[e],s=t[0]^n[0],i=t[e?3:1]^n[1],c=t[2]^n[2];t=t[e?1:3]^n[3];var d,p,y,v=n.length/4-2,m,l=4,h=[0,0,0,0];d=u.s[e],u=d[0];var a=d[1],o=d[2],b=d[3],w=d[4];for(m=0;m<v;m++)d=u[s>>>24]^a[i>>16&255]^o[c>>8&255]^b[t&255]^n[l],p=u[i>>>24]^a[c>>16&255]^o[t>>8&255]^b[s&255]^n[l+1],y=u[c>>>24]^a[t>>16&255]^o[s>>8&255]^b[i&255]^n[l+2],t=u[t>>>24]^a[s>>16&255]^o[i>>8&255]^b[c&255]^n[l+3],l+=4,s=d,i=p,c=y;for(m=0;4>m;m++)h[e?3&-m:m]=w[s>>>24]<<24^w[i>>16&255]<<16^w[c>>8&255]<<8^w[t&255]^n[l++],d=s,s=i,i=c,c=t,t=d;return h}$.bitArray={bitSlice:function(u,t,e){return u=$.bitArray.$(u.slice(t/32),32-(t&31)).slice(1),e===void 0?u:$.bitArray.clamp(u,e-t)},extract:function(u,t,e){var n=Math.floor(-t-e&31);return((t+e-1^t)&-32?u[t/32|0]<<32-n^u[t/32+1|0]>>>n:u[t/32|0]>>>n)&(1<<e)-1},concat:function(u,t){if(u.length===0||t.length===0)return u.concat(t);var e=u[u.length-1],n=$.bitArray.getPartial(e);return n===32?u.concat(t):$.bitArray.$(t,n,e|0,u.slice(0,u.length-1))},bitLength:function(u){var t=u.length;return t===0?0:32*(t-1)+$.bitArray.getPartial(u[t-1])},clamp:function(u,t){if(32*u.length<t)return u;u=u.slice(0,Math.ceil(t/32));var e=u.length;return t=t&31,0<e&&t&&(u[e-1]=$.bitArray.partial(t,u[e-1]&2147483648>>t-1,1)),u},partial:function(u,t,e){return u===32?t:(e?t|0:t<<32-u)+1099511627776*u},getPartial:function(u){return Math.round(u/1099511627776)||32},equal:function(u,t){if($.bitArray.bitLength(u)!==$.bitArray.bitLength(t))return!1;var e=0,n;for(n=0;n<u.length;n++)e|=u[n]^t[n];return e===0},$:function(u,t,e,n){var s;for(s=0,n===void 0&&(n=[]);32<=t;t-=32)n.push(e),e=0;if(t===0)return n.concat(u);for(s=0;s<u.length;s++)n.push(e|u[s]>>>t),e=u[s]<<32-t;return s=u.length?u[u.length-1]:0,u=$.bitArray.getPartial(s),n.push($.bitArray.partial(t+u&31,32<t+u?e:n.pop(),1)),n},i:function(u,t){return[u[0]^t[0],u[1]^t[1],u[2]^t[2],u[3]^t[3]]},byteswapM:function(u){var t,e;for(t=0;t<u.length;++t)e=u[t],u[t]=e>>>24|e>>>8&65280|(e&65280)<<8|e<<24;return u}};$.codec.utf8String={fromBits:function(u){var t="",e=$.bitArray.bitLength(u),n,s;for(n=0;n<e/8;n++)(n&3)===0&&(s=u[n/4]),t+=String.fromCharCode(s>>>8>>>8>>>8),s<<=8;return decodeURIComponent(escape(t))},toBits:function(u){u=unescape(encodeURIComponent(u));var t=[],e,n=0;for(e=0;e<u.length;e++)n=n<<8|u.charCodeAt(e),(e&3)===3&&(t.push(n),n=0);return e&3&&t.push($.bitArray.partial(8*(e&3),n)),t}};$.codec.hex={fromBits:function(u){var t="",e;for(e=0;e<u.length;e++)t+=((u[e]|0)+0xf00000000000).toString(16).substr(4);return t.substr(0,$.bitArray.bitLength(u)/4)},toBits:function(u){var t,e=[],n;for(u=u.replace(/\s|0x/g,""),n=u.length,u=u+"00000000",t=0;t<u.length;t+=8)e.push(parseInt(u.substr(t,8),16)^0);return $.bitArray.clamp(e,4*n)}};$.codec.base32={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",X:"0123456789ABCDEFGHIJKLMNOPQRSTUV",BITS:32,BASE:5,REMAINING:27,fromBits:function(u,t,e){var n=$.codec.base32.BASE,s=$.codec.base32.REMAINING,i="",c=0,d=$.codec.base32.B,p=0,y=$.bitArray.bitLength(u);for(e&&(d=$.codec.base32.X),e=0;i.length*n<y;)i+=d.charAt((p^u[e]>>>c)>>>s),c<n?(p=u[e]<<n-c,c+=s,e++):(p<<=n,c-=n);for(;i.length&7&&!t;)i+="=";return i},toBits:function(u,t){u=u.replace(/\s|=/g,"").toUpperCase();var e=$.codec.base32.BITS,n=$.codec.base32.BASE,s=$.codec.base32.REMAINING,i=[],c,d=0,p=$.codec.base32.B,y=0,v,m="base32";for(t&&(p=$.codec.base32.X,m="base32hex"),c=0;c<u.length;c++){if(v=p.indexOf(u.charAt(c)),0>v){if(!t)try{return $.codec.base32hex.toBits(u)}catch{}throw new $.exception.invalid("this isn't "+m+"!")}d>s?(d-=s,i.push(y^v>>>d),y=v<<e-d):(d+=n,y^=v<<e-d)}return d&56&&i.push($.bitArray.partial(d&56,y,1)),i}};$.codec.base32hex={fromBits:function(u,t){return $.codec.base32.fromBits(u,t,1)},toBits:function(u){return $.codec.base32.toBits(u,1)}};$.codec.base64={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(u,t,e){var n="",s=0,i=$.codec.base64.B,c=0,d=$.bitArray.bitLength(u);for(e&&(i=i.substr(0,62)+"-_"),e=0;6*n.length<d;)n+=i.charAt((c^u[e]>>>s)>>>26),6>s?(c=u[e]<<6-s,s+=26,e++):(c<<=6,s-=6);for(;n.length&3&&!t;)n+="=";return n},toBits:function(u,t){u=u.replace(/\s|=/g,"");var e=[],n,s=0,i=$.codec.base64.B,c=0,d;for(t&&(i=i.substr(0,62)+"-_"),n=0;n<u.length;n++){if(d=i.indexOf(u.charAt(n)),0>d)throw new $.exception.invalid("this isn't base64!");26<s?(s-=26,e.push(c^d>>>s),c=d<<32-s):(s+=6,c^=d<<32-s)}return s&56&&e.push($.bitArray.partial(s&56,c,1)),e}};$.codec.base64url={fromBits:function(u){return $.codec.base64.fromBits(u,1,1)},toBits:function(u){return $.codec.base64.toBits(u,1)}};$.hash.sha256=function(u){this.b[0]||this.O(),u?(this.F=u.F.slice(0),this.A=u.A.slice(0),this.l=u.l):this.reset()};$.hash.sha256.hash=function(u){return new $.hash.sha256().update(u).finalize()};$.hash.sha256.prototype={blockSize:512,reset:function(){return this.F=this.Y.slice(0),this.A=[],this.l=0,this},update:function(u){typeof u=="string"&&(u=$.codec.utf8String.toBits(u));var t,e=this.A=$.bitArray.concat(this.A,u);if(t=this.l,u=this.l=t+$.bitArray.bitLength(u),9007199254740991<u)throw new $.exception.invalid("Cannot hash more than 2^53 - 1 bits");if(typeof Uint32Array<"u"){var n=new Uint32Array(e),s=0;for(t=512+t-(512+t&511);t<=u;t+=512)Wt(this,n.subarray(16*s,16*(s+1))),s+=1;e.splice(0,16*s)}else for(t=512+t-(512+t&511);t<=u;t+=512)Wt(this,e.splice(0,16));return this},finalize:function(){var u,e=this.A,t=this.F,e=$.bitArray.concat(e,[$.bitArray.partial(1,1)]);for(u=e.length+2;u&15;u++)e.push(0);for(e.push(Math.floor(this.l/4294967296)),e.push(this.l|0);e.length;)Wt(this,e.splice(0,16));return this.reset(),t},Y:[],b:[],O:function(){function u(i){return 4294967296*(i-Math.floor(i))|0}for(var t=0,e=2,n,s;64>t;e++){for(s=!0,n=2;n*n<=e;n++)if(e%n===0){s=!1;break}s&&(8>t&&(this.Y[t]=u(Math.pow(e,.5))),this.b[t]=u(Math.pow(e,1/3)),t++)}}};function Wt(u,t){var e,n,s,i=u.F,c=u.b,d=i[0],p=i[1],y=i[2],v=i[3],m=i[4],l=i[5],h=i[6],a=i[7];for(e=0;64>e;e++)16>e?n=t[e]:(n=t[e+1&15],s=t[e+14&15],n=t[e&15]=(n>>>7^n>>>18^n>>>3^n<<25^n<<14)+(s>>>17^s>>>19^s>>>10^s<<15^s<<13)+t[e&15]+t[e+9&15]|0),n=n+a+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(h^m&(l^h))+c[e],a=h,h=l,l=m,m=v+n|0,v=y,y=p,p=d,d=n+(p&y^v&(p^y))+(p>>>2^p>>>13^p>>>22^p<<30^p<<19^p<<10)|0;i[0]=i[0]+d|0,i[1]=i[1]+p|0,i[2]=i[2]+y|0,i[3]=i[3]+v|0,i[4]=i[4]+m|0,i[5]=i[5]+l|0,i[6]=i[6]+h|0,i[7]=i[7]+a|0}$.mode.ccm={name:"ccm",G:[],listenProgress:function(u){$.mode.ccm.G.push(u)},unListenProgress:function(u){u=$.mode.ccm.G.indexOf(u),-1<u&&$.mode.ccm.G.splice(u,1)},fa:function(u){var t=$.mode.ccm.G.slice(),e;for(e=0;e<t.length;e+=1)t[e](u)},encrypt:function(u,t,e,n,s){var i,c=t.slice(0),d=$.bitArray,p=d.bitLength(e)/8,y=d.bitLength(c)/8;if(s=s||64,n=n||[],7>p)throw new $.exception.invalid("ccm: iv must be at least 7 bytes");for(i=2;4>i&&y>>>8*i;i++);return i<15-p&&(i=15-p),e=d.clamp(e,8*(15-i)),t=$.mode.ccm.V(u,t,e,n,s,i),c=$.mode.ccm.C(u,c,e,t,s,i),d.concat(c.data,c.tag)},decrypt:function(u,t,e,n,s){s=s||64,n=n||[];var i=$.bitArray,c=i.bitLength(e)/8,y=i.bitLength(t),d=i.clamp(t,y-s),p=i.bitSlice(t,y-s),y=(y-s)/8;if(7>c)throw new $.exception.invalid("ccm: iv must be at least 7 bytes");for(t=2;4>t&&y>>>8*t;t++);if(t<15-c&&(t=15-c),e=i.clamp(e,8*(15-t)),d=$.mode.ccm.C(u,d,e,p,s,t),u=$.mode.ccm.V(u,d.data,e,n,s,t),!i.equal(d.tag,u))throw new $.exception.corrupt("ccm: tag doesn't match");return d.data},na:function(u,t,e,n,s,i){var c=[],d=$.bitArray,p=d.i;if(n=[d.partial(8,(t.length?64:0)|n-2<<2|i-1)],n=d.concat(n,e),n[3]|=s,n=u.encrypt(n),t.length)for(e=d.bitLength(t)/8,65279>=e?c=[d.partial(16,e)]:4294967295>=e&&(c=d.concat([d.partial(16,65534)],[e])),c=d.concat(c,t),t=0;t<c.length;t+=4)n=u.encrypt(p(n,c.slice(t,t+4).concat([0,0,0])));return n},V:function(u,t,e,n,s,i){var c=$.bitArray,d=c.i;if(s/=8,s%2||4>s||16<s)throw new $.exception.invalid("ccm: invalid tag length");if(4294967295<n.length||4294967295<t.length)throw new $.exception.bug("ccm: can't deal with 4GiB or more data");for(e=$.mode.ccm.na(u,n,e,s,c.bitLength(t)/8,i),n=0;n<t.length;n+=4)e=u.encrypt(d(e,t.slice(n,n+4).concat([0,0,0])));return c.clamp(e,8*s)},C:function(u,t,e,n,s,i){var c,d=$.bitArray;c=d.i;var p=t.length,y=d.bitLength(t),v=p/50,m=v;if(e=d.concat([d.partial(8,i-1)],e).concat([0,0,0]).slice(0,4),n=d.bitSlice(c(n,u.encrypt(e)),0,s),!p)return{tag:n,data:[]};for(c=0;c<p;c+=4)c>v&&($.mode.ccm.fa(c/p),v+=m),e[3]++,s=u.encrypt(e),t[c]^=s[0],t[c+1]^=s[1],t[c+2]^=s[2],t[c+3]^=s[3];return{tag:n,data:d.clamp(t,y)}}};$.mode.ocb2={name:"ocb2",encrypt:function(u,t,e,n,s,i){if($.bitArray.bitLength(e)!==128)throw new $.exception.invalid("ocb iv must be 128 bits");var c,d=$.mode.ocb2.S,p=$.bitArray,y=p.i,v=[0,0,0,0];e=d(u.encrypt(e));var m,l=[];for(n=n||[],s=s||64,c=0;c+4<t.length;c+=4)m=t.slice(c,c+4),v=y(v,m),l=l.concat(y(e,u.encrypt(y(e,m)))),e=d(e);return m=t.slice(c),t=p.bitLength(m),c=u.encrypt(y(e,[0,0,0,t])),m=p.clamp(y(m.concat([0,0,0]),c),t),v=y(v,y(m.concat([0,0,0]),c)),v=u.encrypt(y(v,y(e,d(e)))),n.length&&(v=y(v,i?n:$.mode.ocb2.pmac(u,n))),l.concat(p.concat(m,p.clamp(v,s)))},decrypt:function(u,t,e,n,s,i){if($.bitArray.bitLength(e)!==128)throw new $.exception.invalid("ocb iv must be 128 bits");s=s||64;var c=$.mode.ocb2.S,d=$.bitArray,p=d.i,y=[0,0,0,0],v=c(u.encrypt(e)),m,l,h=$.bitArray.bitLength(t)-s,a=[];for(n=n||[],e=0;e+4<h/32;e+=4)m=p(v,u.decrypt(p(v,t.slice(e,e+4)))),y=p(y,m),a=a.concat(m),v=c(v);if(l=h-32*e,m=u.encrypt(p(v,[0,0,0,l])),m=p(m,d.clamp(t.slice(e),l).concat([0,0,0])),y=p(y,m),y=u.encrypt(p(y,p(v,c(v)))),n.length&&(y=p(y,i?n:$.mode.ocb2.pmac(u,n))),!d.equal(d.clamp(y,s),d.bitSlice(t,h)))throw new $.exception.corrupt("ocb: tag doesn't match");return a.concat(d.clamp(m,l))},pmac:function(u,t){var e,n=$.mode.ocb2.S,s=$.bitArray,i=s.i,c=[0,0,0,0],d=u.encrypt([0,0,0,0]),d=i(d,n(n(d)));for(e=0;e+4<t.length;e+=4)d=n(d),c=i(c,u.encrypt(i(d,t.slice(e,e+4))));return e=t.slice(e),128>s.bitLength(e)&&(d=i(d,n(d)),e=s.concat(e,[-2147483648,0,0,0])),c=i(c,e),u.encrypt(i(n(i(d,n(d))),c))},S:function(u){return[u[0]<<1^u[1]>>>31,u[1]<<1^u[2]>>>31,u[2]<<1^u[3]>>>31,u[3]<<1^135*(u[0]>>>31)]}};$.mode.gcm={name:"gcm",encrypt:function(u,t,e,n,s){var i=t.slice(0);return t=$.bitArray,n=n||[],u=$.mode.gcm.C(!0,u,i,n,e,s||128),t.concat(u.data,u.tag)},decrypt:function(u,t,e,n,s){var i=t.slice(0),c=$.bitArray,d=c.bitLength(i);if(s=s||128,n=n||[],s<=d?(t=c.bitSlice(i,d-s),i=c.bitSlice(i,0,d-s)):(t=i,i=[]),u=$.mode.gcm.C(!1,u,i,n,e,s),!c.equal(u.tag,t))throw new $.exception.corrupt("gcm: tag doesn't match");return u.data},ka:function(u,t){var e,n,s,i,c,d=$.bitArray.i;for(s=[0,0,0,0],i=t.slice(0),e=0;128>e;e++){for((n=(u[Math.floor(e/32)]&1<<31-e%32)!==0)&&(s=d(s,i)),c=(i[3]&1)!==0,n=3;0<n;n--)i[n]=i[n]>>>1|(i[n-1]&1)<<31;i[0]>>>=1,c&&(i[0]^=-520093696)}return s},j:function(u,t,e){var n,s=e.length;for(t=t.slice(0),n=0;n<s;n+=4)t[0]^=4294967295&e[n],t[1]^=4294967295&e[n+1],t[2]^=4294967295&e[n+2],t[3]^=4294967295&e[n+3],t=$.mode.gcm.ka(t,u);return t},C:function(u,t,e,n,s,i){var c,d,p,y,v,m,l,h,a=$.bitArray;for(m=e.length,l=a.bitLength(e),h=a.bitLength(n),d=a.bitLength(s),c=t.encrypt([0,0,0,0]),d===96?(s=s.slice(0),s=a.concat(s,[1])):(s=$.mode.gcm.j(c,[0,0,0,0],s),s=$.mode.gcm.j(c,s,[0,0,Math.floor(d/4294967296),d&4294967295])),d=$.mode.gcm.j(c,[0,0,0,0],n),v=s.slice(0),n=d.slice(0),u||(n=$.mode.gcm.j(c,d,e)),y=0;y<m;y+=4)v[3]++,p=t.encrypt(v),e[y]^=p[0],e[y+1]^=p[1],e[y+2]^=p[2],e[y+3]^=p[3];return e=a.clamp(e,l),u&&(n=$.mode.gcm.j(c,d,e)),u=[Math.floor(h/4294967296),h&4294967295,Math.floor(l/4294967296),l&4294967295],n=$.mode.gcm.j(c,n,u),p=t.encrypt(s),n[0]^=p[0],n[1]^=p[1],n[2]^=p[2],n[3]^=p[3],{tag:a.bitSlice(n,0,i),data:e}}};$.misc.hmac=function(u,t){this.W=t=t||$.hash.sha256;var e=[[],[]],n,s=t.prototype.blockSize/32;for(this.w=[new t,new t],u.length>s&&(u=t.hash(u)),n=0;n<s;n++)e[0][n]=u[n]^909522486,e[1][n]=u[n]^1549556828;this.w[0].update(e[0]),this.w[1].update(e[1]),this.R=new t(this.w[0])};$.misc.hmac.prototype.encrypt=$.misc.hmac.prototype.mac=function(u){if(this.aa)throw new $.exception.invalid("encrypt on already updated hmac called!");return this.update(u),this.digest(u)};$.misc.hmac.prototype.reset=function(){this.R=new this.W(this.w[0]),this.aa=!1};$.misc.hmac.prototype.update=function(u){this.aa=!0,this.R.update(u)};$.misc.hmac.prototype.digest=function(){var u=this.R.finalize(),u=new this.W(this.w[1]).update(u).finalize();return this.reset(),u};$.misc.pbkdf2=function(u,t,e,n,s){if(e=e||1e4,0>n||0>e)throw new $.exception.invalid("invalid params to pbkdf2");typeof u=="string"&&(u=$.codec.utf8String.toBits(u)),typeof t=="string"&&(t=$.codec.utf8String.toBits(t)),s=s||$.misc.hmac,u=new s(u);var i,c,d,p,y=[],v=$.bitArray;for(p=1;32*y.length<(n||1);p++){for(s=i=u.encrypt(v.concat(t,[p])),c=1;c<e;c++)for(i=u.encrypt(i),d=0;d<i.length;d++)s[d]^=i[d];y=y.concat(s)}return n&&(y=v.clamp(y,n)),y};$.prng=function(u){this.c=[new $.hash.sha256],this.m=[0],this.P=0,this.H={},this.N=0,this.U={},this.Z=this.f=this.o=this.ha=0,this.b=[0,0,0,0,0,0,0,0],this.h=[0,0,0,0],this.L=void 0,this.M=u,this.D=!1,this.K={progress:{},seeded:{}},this.u=this.ga=0,this.I=1,this.J=2,this.ca=65536,this.T=[0,48,64,96,128,192,256,384,512,768,1024],this.da=3e4,this.ba=80};$.prng.prototype={randomWords:function(u,t){var e=[],n;n=this.isReady(t);var s;if(n===this.u)throw new $.exception.notReady("generator isn't seeded");if(n&this.J){n=!(n&this.I),s=[];var i=0,c;for(this.Z=s[0]=new Date().valueOf()+this.da,c=0;16>c;c++)s.push(4294967296*Math.random()|0);for(c=0;c<this.c.length&&(s=s.concat(this.c[c].finalize()),i+=this.m[c],this.m[c]=0,n||!(this.P&1<<c));c++);for(this.P>=1<<this.c.length&&(this.c.push(new $.hash.sha256),this.m.push(0)),this.f-=i,i>this.o&&(this.o=i),this.P++,this.b=$.hash.sha256.hash(this.b.concat(s)),this.L=new $.cipher.aes(this.b),n=0;4>n&&(this.h[n]=this.h[n]+1|0,!this.h[n]);n++);}for(n=0;n<u;n+=4)(n+1)%this.ca===0&&$n(this),s=Ht(this),e.push(s[0],s[1],s[2],s[3]);return $n(this),e.slice(0,u)},setDefaultParanoia:function(u,t){if(u===0&&t!=="Setting paranoia=0 will ruin your security; use it only for testing")throw new $.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");this.M=u},addEntropy:function(u,t,e){e=e||"user";var n,s,i=new Date().valueOf(),c=this.H[e],d=this.isReady(),p=0;switch(n=this.U[e],n===void 0&&(n=this.U[e]=this.ha++),c===void 0&&(c=this.H[e]=0),this.H[e]=(this.H[e]+1)%this.c.length,typeof u){case"number":t===void 0&&(t=1),this.c[c].update([n,this.N++,1,t,i,1,u|0]);break;case"object":if(e=Object.prototype.toString.call(u),e==="[object Uint32Array]"){for(s=[],e=0;e<u.length;e++)s.push(u[e]);u=s}else for(e!=="[object Array]"&&(p=1),e=0;e<u.length&&!p;e++)typeof u[e]!="number"&&(p=1);if(!p){if(t===void 0)for(e=t=0;e<u.length;e++)for(s=u[e];0<s;)t++,s=s>>>1;this.c[c].update([n,this.N++,2,t,i,u.length].concat(u))}break;case"string":t===void 0&&(t=u.length),this.c[c].update([n,this.N++,3,t,i,u.length]),this.c[c].update(u);break;default:p=1}if(p)throw new $.exception.bug("random: addEntropy only supports number, array of numbers or string");this.m[c]+=t,this.f+=t,d===this.u&&(this.isReady()!==this.u&&Mn("seeded",Math.max(this.o,this.f)),Mn("progress",this.getProgress()))},isReady:function(u){return u=this.T[u!==void 0?u:this.M],this.o&&this.o>=u?this.m[0]>this.ba&&new Date().valueOf()>this.Z?this.J|this.I:this.I:this.f>=u?this.J|this.u:this.u},getProgress:function(u){return u=this.T[u||this.M],this.o>=u||this.f>u?1:this.f/u},startCollectors:function(){if(!this.D){if(this.a={loadTimeCollector:it(this,this.ma),mouseCollector:it(this,this.oa),keyboardCollector:it(this,this.la),accelerometerCollector:it(this,this.ea),touchCollector:it(this,this.qa)},window.addEventListener)window.addEventListener("load",this.a.loadTimeCollector,!1),window.addEventListener("mousemove",this.a.mouseCollector,!1),window.addEventListener("keypress",this.a.keyboardCollector,!1),window.addEventListener("devicemotion",this.a.accelerometerCollector,!1),window.addEventListener("touchmove",this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector);else throw new $.exception.bug("can't attach event");this.D=!0}},stopCollectors:function(){this.D&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,!1),window.removeEventListener("mousemove",this.a.mouseCollector,!1),window.removeEventListener("keypress",this.a.keyboardCollector,!1),window.removeEventListener("devicemotion",this.a.accelerometerCollector,!1),window.removeEventListener("touchmove",this.a.touchCollector,!1)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.D=!1)},addEventListener:function(u,t){this.K[u][this.ga++]=t},removeEventListener:function(u,t){var e,n,s=this.K[u],i=[];for(n in s)s.hasOwnProperty(n)&&s[n]===t&&i.push(n);for(e=0;e<i.length;e++)n=i[e],delete s[n]},la:function(){rt(this,1)},oa:function(u){var t,e;try{t=u.x||u.clientX||u.offsetX||0,e=u.y||u.clientY||u.offsetY||0}catch{e=t=0}t!=0&&e!=0&&this.addEntropy([t,e],2,"mouse"),rt(this,0)},qa:function(u){u=u.touches[0]||u.changedTouches[0],this.addEntropy([u.pageX||u.clientX,u.pageY||u.clientY],1,"touch"),rt(this,0)},ma:function(){rt(this,2)},ea:function(u){if(u=u.accelerationIncludingGravity.x||u.accelerationIncludingGravity.y||u.accelerationIncludingGravity.z,window.orientation){var t=window.orientation;typeof t=="number"&&this.addEntropy(t,1,"accelerometer")}u&&this.addEntropy(u,2,"accelerometer"),rt(this,0)}};function Mn(u,t){var e,n=$.random.K[u],s=[];for(e in n)n.hasOwnProperty(e)&&s.push(n[e]);for(e=0;e<s.length;e++)s[e](t)}function rt(u,t){typeof window<"u"&&window.performance&&typeof window.performance.now=="function"?u.addEntropy(window.performance.now(),t,"loadtime"):u.addEntropy(new Date().valueOf(),t,"loadtime")}function $n(u){u.b=Ht(u).concat(Ht(u)),u.L=new $.cipher.aes(u.b)}function Ht(u){for(var t=0;4>t&&(u.h[t]=u.h[t]+1|0,!u.h[t]);t++);return u.L.encrypt(u.h)}function it(u,t){return function(){t.apply(u,arguments)}}$.random=new $.prng(6);e:try{if(Ct=typeof Qe<"u"&&Qe.exports){try{Ft=Ge("crypto")}catch{Ft=null}Ct=Dt=Ft}if(Ct&&Dt.randomBytes)st=Dt.randomBytes(128),st=new Uint32Array(new Uint8Array(st).buffer),$.random.addEntropy(st,1024,"crypto['randomBytes']");else if(typeof window<"u"&&typeof Uint32Array<"u"){if(at=new Uint32Array(32),window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(at);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(at);else break e;$.random.addEntropy(at,1024,"crypto['getRandomValues']")}}catch(u){typeof window<"u"&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(u))}var st,Dt,at,Ct,Ft;$.json={defaults:{v:1,iter:1e4,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},ja:function(u,t,e,n){e=e||{},n=n||{};var s=$.json,i=s.g({iv:$.random.randomWords(4,0)},s.defaults),c;if(s.g(i,e),e=i.adata,typeof i.salt=="string"&&(i.salt=$.codec.base64.toBits(i.salt)),typeof i.iv=="string"&&(i.iv=$.codec.base64.toBits(i.iv)),!$.mode[i.mode]||!$.cipher[i.cipher]||typeof u=="string"&&100>=i.iter||i.ts!==64&&i.ts!==96&&i.ts!==128||i.ks!==128&&i.ks!==192&&i.ks!==256||2>i.iv.length||4<i.iv.length)throw new $.exception.invalid("json encrypt: invalid parameters");return typeof u=="string"?(c=$.misc.cachedPbkdf2(u,i),u=c.key.slice(0,i.ks/32),i.salt=c.salt):$.ecc&&u instanceof $.ecc.elGamal.publicKey&&(c=u.kem(),i.kemtag=c.tag,u=c.key.slice(0,i.ks/32)),typeof t=="string"&&(t=$.codec.utf8String.toBits(t)),typeof e=="string"&&(i.adata=e=$.codec.utf8String.toBits(e)),c=new $.cipher[i.cipher](u),s.g(n,i),n.key=u,i.ct=i.mode==="ccm"&&$.arrayBuffer&&$.arrayBuffer.ccm&&t instanceof ArrayBuffer?$.arrayBuffer.ccm.encrypt(c,t,i.iv,e,i.ts):$.mode[i.mode].encrypt(c,t,i.iv,e,i.ts),i},encrypt:function(u,t,e,n){var s=$.json,i=s.ja.apply(s,arguments);return s.encode(i)},ia:function(u,t,e,n){e=e||{},n=n||{};var s=$.json;t=s.g(s.g(s.g({},s.defaults),t),e,!0);var i,c;if(i=t.adata,typeof t.salt=="string"&&(t.salt=$.codec.base64.toBits(t.salt)),typeof t.iv=="string"&&(t.iv=$.codec.base64.toBits(t.iv)),!$.mode[t.mode]||!$.cipher[t.cipher]||typeof u=="string"&&100>=t.iter||t.ts!==64&&t.ts!==96&&t.ts!==128||t.ks!==128&&t.ks!==192&&t.ks!==256||!t.iv||2>t.iv.length||4<t.iv.length)throw new $.exception.invalid("json decrypt: invalid parameters");return typeof u=="string"?(c=$.misc.cachedPbkdf2(u,t),u=c.key.slice(0,t.ks/32),t.salt=c.salt):$.ecc&&u instanceof $.ecc.elGamal.secretKey&&(u=u.unkem($.codec.base64.toBits(t.kemtag)).slice(0,t.ks/32)),typeof i=="string"&&(i=$.codec.utf8String.toBits(i)),c=new $.cipher[t.cipher](u),i=t.mode==="ccm"&&$.arrayBuffer&&$.arrayBuffer.ccm&&t.ct instanceof ArrayBuffer?$.arrayBuffer.ccm.decrypt(c,t.ct,t.iv,t.tag,i,t.ts):$.mode[t.mode].decrypt(c,t.ct,t.iv,i,t.ts),s.g(n,t),n.key=u,e.raw===1?i:$.codec.utf8String.fromBits(i)},decrypt:function(u,t,e,n){var s=$.json;return s.ia(u,s.decode(t),e,n)},encode:function(u){var t,e="{",n="";for(t in u)if(u.hasOwnProperty(t)){if(!t.match(/^[a-z0-9]+$/i))throw new $.exception.invalid("json encode: invalid property name");switch(e+=n+'"'+t+'":',n=",",typeof u[t]){case"number":case"boolean":e+=u[t];break;case"string":e+='"'+escape(u[t])+'"';break;case"object":e+='"'+$.codec.base64.fromBits(u[t],0)+'"';break;default:throw new $.exception.bug("json encode: unsupported type")}}return e+"}"},decode:function(u){if(u=u.replace(/\s/g,""),!u.match(/^\{.*\}$/))throw new $.exception.invalid("json decode: this isn't json!");u=u.replace(/^\{|\}$/g,"").split(/,/);var t={},e,n;for(e=0;e<u.length;e++){if(!(n=u[e].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))throw new $.exception.invalid("json decode: this isn't json!");n[3]!=null?t[n[2]]=parseInt(n[3],10):n[4]!=null?t[n[2]]=n[2].match(/^(ct|adata|salt|iv)$/)?$.codec.base64.toBits(n[4]):unescape(n[4]):n[5]!=null&&(t[n[2]]=n[5]==="true")}return t},g:function(u,t,e){if(u===void 0&&(u={}),t===void 0)return u;for(var n in t)if(t.hasOwnProperty(n)){if(e&&u[n]!==void 0&&u[n]!==t[n])throw new $.exception.invalid("required parameter overridden");u[n]=t[n]}return u},sa:function(u,t){var e={},n;for(n in u)u.hasOwnProperty(n)&&u[n]!==t[n]&&(e[n]=u[n]);return e},ra:function(u,t){var e={},n;for(n=0;n<t.length;n++)u[t[n]]!==void 0&&(e[t[n]]=u[t[n]]);return e}};$.encrypt=$.json.encrypt;$.decrypt=$.json.decrypt;$.misc.pa={};$.misc.cachedPbkdf2=function(u,t){var e=$.misc.pa,n;return t=t||{},n=t.iter||1e3,e=e[u]=e[u]||{},n=e[n]=e[n]||{firstSalt:t.salt&&t.salt.length?t.salt.slice(0):$.random.randomWords(2,0)},e=t.salt===void 0?n.firstSalt:t.salt,n[e]=n[e]||$.misc.pbkdf2(u,e,t.iter),{key:n[e].slice(0),salt:e.slice(0)}};typeof Qe<"u"&&Qe.exports&&(Qe.exports=$);typeof define=="function"&&define([],function(){return $})});var Bn=Bt((Os,Pn)=>{Pn.exports=Worker});var Re=class{constructor(){this.streams={};this.createStream=t=>{let e={_id:`stream${Math.floor(Math.random()*1e15)}`,info:t.port.getInfo(),running:!1,...t};return t.port?.readable&&(t.transforms?e.reader=Re.setStreamTransforms(t.port.readable,t.transforms).getReader():e.reader=t.port.readable.getReader()),t.port?.writable&&(e.writer=t.port.writable.getWriter()),this.streams[e._id]=e,e}}getPorts(){return navigator.serial.getPorts()}requestPort(t,e){let n={};return t&&(n.usbVendorId=t),e&&(n.usbProductId=e),n.usbVendorId?navigator.serial.requestPort({filters:[n]}):navigator.serial.requestPort()}openPort(t,e){return e&&(e=Object.assign({},e)),e?.ondisconnect&&(t.ondisconnect=e.ondisconnect,delete e.ondisconnect),t.open(e).then(()=>{e?.onconnect&&e.onconnect(t)})}async readWithTimeout(t,e){let n=t.readable.getReader(),s=setTimeout(()=>{n.releaseLock()},e),i=await n.read();return clearTimeout(s),n.releaseLock(),i}async writePort(t,e){let n=t.writable.getWriter();return await n.write(Re.toDataView(e)),n.releaseLock(),!0}getSignals(t){return t.getSignals()}setSignals(t,e){return t.setSignals(e)}readStream(t){if(t.reader&&!t.running){let e=t.reader,n=()=>{if(t.port.readable&&t.running)e.read().then(s=>{s.done?e.releaseLock():(t.ondata(s.value),setTimeout(()=>{n()},t.frequency))});else if(!t.running&&t.port.readable)try{e.releaseLock()}catch(s){console.error(s)}};return t.running=!0,n(),t}}writeStream(t,e){if(t.writer)return t.writer.write(Re.toDataView(e))}endStream(t,e){t.running=!1,setTimeout(async()=>{if(t.port.readable)try{t.reader.releaseLock(),await t.reader.cancel()}catch{}if(t.port.writable)try{t.writer.releaseLock(),await t.writer.close()}catch{}try{await t.port.close().then(()=>{e(this.streams[t._id])})}catch{}},t.frequency),delete this.streams[t._id]}static setStreamTransforms(t,e){let n=[];Object.keys(e).forEach(i=>{let c=e[i];if(c instanceof TransformStream)n.push(c);else{c.start||(c.start=function(){}),c.flush||(c.flush=function(){});let d=new TransformStream({start:c.start,transform:c.transform,flush:c.flush},c.writableStrategy,c.readableStrategy);n.push(d)}});let s=t;return n.forEach(i=>{s=s.pipeThrough(i)}),s}static toDataView(t){if(!(t instanceof DataView))if(typeof t=="string"){let e=new TextEncoder;t=new DataView(e.encode(t))}else if(typeof t=="number"){let e=t;t<256?(t=new DataView(new ArrayBuffer(1)),t.setUint8(0,e)):t<65536?(t=new DataView(new ArrayBuffer(2)),t.setInt16(0,e)):(t=new DataView(new ArrayBuffer(4)),t.setUint32(0,e))}else t instanceof ArrayBuffer||t instanceof SharedArrayBuffer?t=new DataView(t):Array.isArray(t)&&(t=new DataView(Uint8Array.from(t)));return t}static searchBuffer(t,e,n){for(var s=e,i=t,c=Re.boyerMoore(s),d=c.byteLength,p=[],y=c(i);y!==-1&&(p.push(y),!(n&&p.length>=n));y=c(i,y+d));return p}static bytesToInt16(t,e){let n=(255&t)<<8|255&e;return(n&32768)>0?n|=4294901760:n&=65535,n}static bytesToUInt16(t,e){return t*256+e}static Uint16ToBytes(t){return[t&255,t>>8&255]}static bytesToInt24(t,e,n){let s=(255&t)<<16|(255&e)<<8|255&n;return(s&8388608)>0?s|=4278190080:s&=16777215,s}static bytesToUInt24(t,e,n){return t*65536+e*256+n}static Uint24ToBytes(t){return[t&255,t>>8&255,t>>16&255]}static bytesToInt32(t,e,n,s){let i=(255&t)<<24|(255&e)<<16|(255&n)<<8|255&s;return(i&2147483648)>0?i|=0:i&=4294967295,i}static bytesToUInt32(t,e,n,s){return t*16777216+e*65536+n*256+s}static Uint32ToBytes(t){return[t&255,t>>8&255,t>>16&255,t>>24&255]}static get2sCompliment(t,e){return t>4294967296?null:t<<32-e>>32-e}static getSignedInt(...t){let e=0;function n(s){for(var i=0,c=!0;s--;)if(c){let d=t[e++];i+=d&127,d&128&&(i-=128),c=!1}else i*=256,i+=t[e++];return i}return n(t.length)}static asUint8Array(t){if(t instanceof Uint8Array)return t;if(typeof t=="string"){for(var e=new Uint8Array(t.length),n=0;n<t.length;n++){var s=t.charCodeAt(n);if(s>127)throw new TypeError("Only ASCII patterns are supported");e[n]=s}return e}else return new Uint8Array(t)}static boyerMoore(t){var e=Re.asUint8Array(t),n=e.length;if(n===0)throw new TypeError("patternBuffer must be at least 1 byte long");for(var s=256,i=new Int32Array(s),c=0;c<s;c++)i[c]=-1;for(var d=0;d<n;d++)i[e[d]]=d;var p=(y,v,m)=>{var l=Re.asUint8Array(y);v===void 0&&(v=0),m===void 0&&(m=l.length);for(var h=e,a=i,o=m-h.length,b=h.length-1,w,I=v;I<=o;I+=w){w=0;for(var S=b;S>=0;S--){var D=l[I+S];if(h[S]!==D){w=Math.max(1,S-a[D]);break}}if(w===0)return I}return-1};return p.byteLength=e.byteLength,p}};var Tn;(function(u){u[u.SCAN_MODE_LOW_POWER=0]="SCAN_MODE_LOW_POWER",u[u.SCAN_MODE_BALANCED=1]="SCAN_MODE_BALANCED",u[u.SCAN_MODE_LOW_LATENCY=2]="SCAN_MODE_LOW_LATENCY"})(Tn||(Tn={}));bt();Tt();bt();var ce=wn("BluetoothLe",{web:()=>Promise.resolve().then(()=>(Dn(),kn)).then(u=>new u.BluetoothLeWeb)});var In=zt(Fn());function St(u){return u?(0,In.default)(1):t=>t()}function Se(u){if(typeof u!="string")throw new Error(`Invalid UUID type ${typeof u}. Expected string.`);if(u=u.toLowerCase(),!(u.search(/^[0-9a-f]{8}\b-[0-9a-f]{4}\b-[0-9a-f]{4}\b-[0-9a-f]{4}\b-[0-9a-f]{12}$/)>=0))throw new Error(`Invalid UUID format ${u}. Expected 128 bit string (e.g. "0000180d-0000-1000-8000-00805f9b34fb").`);return u}var jt=class{constructor(){this.scanListener=null,this.eventListeners=new Map,this.queue=St(!0)}enableQueue(){this.queue=St(!0)}disableQueue(){this.queue=St(!1)}async initialize(t){await this.queue(async()=>{await ce.initialize(t)})}async getEnabled(){return this.isEnabled()}async isEnabled(){return await this.queue(async()=>(await ce.isEnabled()).value)}async enable(){await this.queue(async()=>{await ce.enable()})}async disable(){await this.queue(async()=>{await ce.disable()})}async startEnabledNotifications(t){await this.queue(async()=>{var e;let n="onEnabledChanged";await((e=this.eventListeners.get(n))===null||e===void 0?void 0:e.remove());let s=await ce.addListener(n,i=>{t(i.value)});this.eventListeners.set(n,s),await ce.startEnabledNotifications()})}async stopEnabledNotifications(){await this.queue(async()=>{var t;let e="onEnabledChanged";await((t=this.eventListeners.get(e))===null||t===void 0?void 0:t.remove()),this.eventListeners.delete(e),await ce.stopEnabledNotifications()})}async isLocationEnabled(){return await this.queue(async()=>(await ce.isLocationEnabled()).value)}async openLocationSettings(){await this.queue(async()=>{await ce.openLocationSettings()})}async openBluetoothSettings(){await this.queue(async()=>{await ce.openBluetoothSettings()})}async openAppSettings(){await this.queue(async()=>{await ce.openAppSettings()})}async setDisplayStrings(t){await this.queue(async()=>{await ce.setDisplayStrings(t)})}async requestDevice(t){return await this.queue(async()=>await ce.requestDevice(t))}async requestLEScan(t,e){await this.queue(async()=>{var n;await((n=this.scanListener)===null||n===void 0?void 0:n.remove()),this.scanListener=await ce.addListener("onScanResult",s=>{let i=Object.assign(Object.assign({},s),{manufacturerData:this.convertObject(s.manufacturerData),serviceData:this.convertObject(s.serviceData),rawAdvertisement:s.rawAdvertisement?this.convertValue(s.rawAdvertisement):void 0});e(i)}),await ce.requestLEScan(t)})}async stopLEScan(){await this.queue(async()=>{var t;await((t=this.scanListener)===null||t===void 0?void 0:t.remove()),this.scanListener=null,await ce.stopLEScan()})}async getDevices(t){return this.queue(async()=>(await ce.getDevices({deviceIds:t})).devices)}async getConnectedDevices(t){return this.queue(async()=>(await ce.getConnectedDevices({services:t})).devices)}async connect(t,e,n){await this.queue(async()=>{var s;if(e){let i=`disconnected|${t}`;await((s=this.eventListeners.get(i))===null||s===void 0?void 0:s.remove());let c=await ce.addListener(i,()=>{e(t)});this.eventListeners.set(i,c)}await ce.connect(Object.assign({deviceId:t},n))})}async createBond(t){await this.queue(async()=>{await ce.createBond({deviceId:t})})}async isBonded(t){return await this.queue(async()=>(await ce.isBonded({deviceId:t})).value)}async disconnect(t){await this.queue(async()=>{await ce.disconnect({deviceId:t})})}async getServices(t){return await this.queue(async()=>(await ce.getServices({deviceId:t})).services)}async readRssi(t){return await this.queue(async()=>{let n=await ce.readRssi({deviceId:t});return parseFloat(n.value)})}async read(t,e,n,s){return e=Se(e),n=Se(n),await this.queue(async()=>{let c=await ce.read(Object.assign({deviceId:t,service:e,characteristic:n},s));return this.convertValue(c.value)})}async write(t,e,n,s,i){return e=Se(e),n=Se(n),this.queue(async()=>{if(!s?.buffer)throw new Error("Invalid data.");let c=s;Ke.getPlatform()!=="web"&&(c=vt(s)),await ce.write(Object.assign({deviceId:t,service:e,characteristic:n,value:c},i))})}async writeWithoutResponse(t,e,n,s,i){e=Se(e),n=Se(n),await this.queue(async()=>{if(!s?.buffer)throw new Error("Invalid data.");let c=s;Ke.getPlatform()!=="web"&&(c=vt(s)),await ce.writeWithoutResponse(Object.assign({deviceId:t,service:e,characteristic:n,value:c},i))})}async readDescriptor(t,e,n,s,i){return e=Se(e),n=Se(n),s=Se(s),await this.queue(async()=>{let d=await ce.readDescriptor(Object.assign({deviceId:t,service:e,characteristic:n,descriptor:s},i));return this.convertValue(d.value)})}async writeDescriptor(t,e,n,s,i,c){return e=Se(e),n=Se(n),s=Se(s),this.queue(async()=>{if(!i?.buffer)throw new Error("Invalid data.");let d=i;Ke.getPlatform()!=="web"&&(d=vt(i)),await ce.writeDescriptor(Object.assign({deviceId:t,service:e,characteristic:n,descriptor:s,value:d},c))})}async startNotifications(t,e,n,s){e=Se(e),n=Se(n),await this.queue(async()=>{var i;let c=`notification|${t}|${e}|${n}`;await((i=this.eventListeners.get(c))===null||i===void 0?void 0:i.remove());let d=await ce.addListener(c,p=>{s(this.convertValue(p?.value))});this.eventListeners.set(c,d),await ce.startNotifications({deviceId:t,service:e,characteristic:n})})}async stopNotifications(t,e,n){e=Se(e),n=Se(n),await this.queue(async()=>{var s;let i=`notification|${t}|${e}|${n}`;await((s=this.eventListeners.get(i))===null||s===void 0?void 0:s.remove()),this.eventListeners.delete(i),await ce.stopNotifications({deviceId:t,service:e,characteristic:n})})}convertValue(t){return typeof t=="string"?Je(t):t===void 0?new DataView(new ArrayBuffer(0)):t}convertObject(t){if(t===void 0)return;let e={};for(let n of Object.keys(t))e[n]=this.convertValue(t[n]);return e}},Rn=new jt;Tt();var Ne=class{constructor(t,e){this.client=Rn;this.devices={};this.location=!1;this.initialized=!1;this.setupDevice=(t,e)=>new Promise(async(n,s)=>{this.devices[t.deviceId]={device:t,options:e},this.client.connect(t.deviceId,e?.onDisconnect,e?.connectOptions).then(async()=>{for(let i in e?.services)for(let c in e.services[i]){let d=e.services[i][c];d.write&&await this.write(t,i,c,d.write,d.writeCallback,d.writeOptions),d.read&&await this.read(t,i,c,d.readCallback,d.readOptions),d.notify&&d.notifyCallback&&(await this.subscribe(t,i,c,d.notifyCallback),d.notifying=!0)}}).catch(s),n(this.devices[t.deviceId])});this.triangulate=(t,e=1500,n=60)=>new Promise((s,i)=>{if("Accelerometer"in globalThis){if(typeof globalThis.Accelerometer=="function"){let c=new globalThis.Accelerometer({frequency:n}),d=performance.now(),p=d,y={samples:[],vector:{}},v=()=>{if(p-d<e)this.readRssi(t).then(m=>{let l=c.x,h=c.y,a=c.z;p=performance.now(),y.samples.push({x:l,y:h,z:a,rssi:m,timestamp:p})});else{let m={x:0,y:0,z:0,rssiAvg:0};y.samples.forEach(l=>{}),c.removeEventListener("reading",v)}};c.addEventListener("reading",v)}}else i(new Error("No Accelerometer API detected"))});e&&(this.location=e),t&&this.setup(t)}setup(t,e=this.location){let n=[];if(t)for(let i in t.services)n.push(i);let s={};return e||(s.androidNeverForLocation=!1),new Promise(async(i,c)=>{if(this.initialized||(await this.client.initialize(s),this.initialized=!0),t?.deviceId)this.reconnect(t.deviceId).then(d=>{i(this.setupDevice(d,t))});else{if(t){let d={services:n,optionalServices:n};t?.namePrefix&&(d.namePrefix=t.namePrefix),this.client.requestDevice(d).then(p=>{i(this.setupDevice(p,t))})}this.client.requestDevice().then(d=>{i(this.setupDevice(d,t))})}})}initialize(t){return new Promise((e,n)=>{this.client.initialize(t).then(()=>{e(!0)}).catch(n)})}requestDevice(t,e){return new Promise((n,s)=>{this.client.requestDevice(t).then(i=>{this.devices[i.deviceId]={device:i,options:e},n(i)}).catch(s)})}connect(t,e){return new Promise((n,s)=>{this.client.connect(t.deviceId,e?.onDisconnect,e?.connectOptions).then(i=>{n(t)}).catch(s)})}reconnect(t){return new Promise((e,n)=>{this.client.getDevices([t]).then(s=>{e(s[0])}).catch(n)})}disconnect(t){return this.client.disconnect(t.deviceId)}write(t,e,n,s,i,c){return i?this.client.write(t.deviceId,e,n,Ne.toDataView(s)).then(i):this.client.writeWithoutResponse(t.deviceId,e,n,Ne.toDataView(s),c)}read(t,e,n,s,i){return s?this.client.read(t.deviceId,e,n,i).then(s):this.client.read(t.deviceId,e,n,i)}subscribe(t,e,n,s){return this.client.startNotifications(t.deviceId,e,n,s)}unsubscribe(t,e,n){return this.client.stopNotifications(t.deviceId,e,n)}scan(t,e){return this.client.requestLEScan(t,e)}stopScanning(){return this.client.stopLEScan()}readDescriptor(t,e,n,s,i){return this.client.readDescriptor(t.deviceId,e,n,s,i)}writeDescriptor(t,e,n,s,i,c){return this.client.writeDescriptor(t.deviceId,e,n,s,Ne.toDataView(i),c)}readRssi(t){return this.client.readRssi(t.deviceId)}async distance(t,e,n,s,i){let c=await this.readRssi(t);if(c==0)return;let d=c/e;return d<1?Math.pow(d,10):n*Math.pow(d,s)+i}async distanceFromPhone(t,e,n){let s,i,c;return n&&(n==="nexus5"?(s=.42093,i=6.9476,c=.54992):n==="motoX"?(s=.9401940951,i=6.170094565,c=0):n==="iphone5"&&(s=.89976,i=7.7095,c=.111)),await this.distance(t,e,s,i,c)}static toDataView(t){if(!(t instanceof DataView))if(typeof t=="string"){let e=new TextEncoder;t=new DataView(e.encode(t))}else if(typeof t=="number"){let e=t;t<256?(t=new DataView(new ArrayBuffer(1)),t.setUint8(0,e)):t<65536?(t=new DataView(new ArrayBuffer(2)),t.setInt16(0,e)):(t=new DataView(new ArrayBuffer(4)),t.setUint32(0,e))}else t instanceof ArrayBuffer||t instanceof SharedArrayBuffer?t=new DataView(t):Array.isArray(t)&&(t=new DataView(Uint8Array.from(t)));return t}static searchBuffer(t,e,n){for(var s=e,i=t,c=Ne.boyerMoore(s),d=c.byteLength,p=[],y=c(i);y!==-1&&(p.push(y),!(n&&p.length>=n));y=c(i,y+d));return p}static bytesToInt16(t,e){let n=(255&t)<<8|255&e;return(n&32768)>0?n|=4294901760:n&=65535,n}static bytesToUInt16(t,e){return t*256+e}static Uint16ToBytes(t){return[t&255,t>>8&255]}static bytesToInt24(t,e,n){let s=(255&t)<<16|(255&e)<<8|255&n;return(s&8388608)>0?s|=4278190080:s&=16777215,s}static bytesToUInt24(t,e,n){return t*65536+e*256+n}static Uint24ToBytes(t){return[t&255,t>>8&255,t>>16&255]}static bytesToInt32(t,e,n,s){let i=(255&t)<<24|(255&e)<<16|(255&n)<<8|255&s;return(i&2147483648)>0?i|=0:i&=4294967295,i}static bytesToUInt32(t,e,n,s){return t*16777216+e*65536+n*256+s}static Uint32ToBytes(t){return[t&255,t>>8&255,t>>16&255,t>>24&255]}static get2sCompliment(t,e){return t>4294967296?null:t<<32-e>>32-e}static getSignedInt(...t){let e=0;function n(s){for(var i=0,c=!0;s--;)if(c){let d=t[e++];i+=d&127,d&128&&(i-=128),c=!1}else i*=256,i+=t[e++];return i}return n(t.length)}static asUint8Array(t){if(t instanceof Uint8Array)return t;if(typeof t=="string"){for(var e=new Uint8Array(t.length),n=0;n<t.length;n++){var s=t.charCodeAt(n);if(s>127)throw new TypeError("Only ASCII patterns are supported");e[n]=s}return e}else return new Uint8Array(t)}static boyerMoore(t){var e=Ne.asUint8Array(t),n=e.length;if(n===0)throw new TypeError("patternBuffer must be at least 1 byte long");for(var s=256,i=new Int32Array(s),c=0;c<s;c++)i[c]=-1;for(var d=0;d<n;d++)i[e[d]]=d;var p=(y,v,m)=>{var l=Ne.asUint8Array(y);v===void 0&&(v=0),m===void 0&&(m=l.length);for(var h=e,a=i,o=m-h.length,b=h.length-1,w,I=v;I<=o;I+=w){w=0;for(var S=b;S>=0;S--){var D=l[I+S];if(h[S]!==D){w=Math.max(1,S-a[D]);break}}if(w===0)return I}return-1};return p.byteLength=e.byteLength,p}};var kr=/([^,]*)/g;function Dr(u){var t=u.toString();let e=t.indexOf("("),n=t.indexOf(")"),s=(y,v=0)=>{let m=v+y.indexOf("{");return m<n&&m>e?s(y.slice(m),v+m):m},i=s(t),c;i===-1||n<i?c=t.slice(t.indexOf("(")+1,t.indexOf(")")):c=t.match(/([a-zA-Z]\w*|\([a-zA-Z]\w*(,\s*[a-zA-Z]\w*)*\)) =>/)?.[1];let d=c.match(kr).filter(y=>!!y),p=new Map;return d.forEach(y=>{let[v,m]=y.split("=");v=v.trim(),v=v.replace(/\d+$/,"");try{v&&p.set(v,(0,eval)(`(${m})`))}catch{p.set(v,void 0),console.warn(`Argument ${v} could be parsed for`,u.toString())}}),p}function He(u=""){let t=c=>c.replace(/^\W*(function[^{]+\{([\s\S]*)\}|[^=]+=>[^{]*\{([\s\S]*)\}|[^=]+=>(.+))/i,"$2$3$4"),n=(c=>{let d=c.indexOf(")");return c.slice(0,c.indexOf("{",d)+1)})(u),s=t(u),i;if(n.includes("function ")){let c=n.split("(")[1].split(")")[0];i=new Function(c,s)}else if(n.substring(0,6)===s.substring(0,6)){let c=n.split("(")[1].split(")")[0];i=new Function(c,s.substring(s.indexOf("{")+1,s.length-1))}else try{i=(0,eval)(n+s+"}")}catch{}return i}var _e={pushToState:{},data:{},triggers:{},setState(u){Object.assign(_e.data,u);for(let t of Object.getOwnPropertyNames(u))_e.triggers[t]&&_e.triggers[t].forEach(e=>e.onchange(_e.data[t]));return _e.data},subscribeTrigger(u,t){if(u){_e.triggers[u]||(_e.triggers[u]=[]);let e=_e.triggers[u].length;return _e.triggers[u].push({idx:e,onchange:t}),_e.triggers[u].length-1}else return},unsubscribeTrigger(u,t){let e,n=_e.triggers[u];if(n)if(!t)delete _e.triggers[u];else return n.find(i=>{if(i.idx===t)return!0})&&n.splice(e,1),!0},subscribeTriggerOnce(u,t){let e,n=s=>{t(s),_e.unsubscribeTrigger(u,e)};e=_e.subscribeTrigger(u,n)}},Q=class{constructor(t={},e,n){this.nodes=new Map;this.arguments=new Map;this._initial={};this.state=_e;this.isLooping=!1;this.isAnimating=!1;this.looper=void 0;this.animation=void 0;this.forward=!0;this.backward=!1;this.runSync=!1;this.firstRun=!0;this.DEBUGNODE=!1;this.operator=(t=this,e,...n)=>n;this.runOp=(t=this,e=this,...n)=>{t.DEBUGNODE&&console.time(t.tag);let s=t.operator(t,e,...n);return s instanceof Promise?s.then(i=>(i!==void 0&&this.setState({[t.tag]:i}),t.DEBUGNODE&&(console.timeEnd(t.tag),s!==void 0&&console.log(`${t.tag} result:`,s)),i)):(s!==void 0&&this.setState({[t.tag]:s}),t.DEBUGNODE&&(console.timeEnd(t.tag),s!==void 0&&console.log(`${t.tag} result:`,s))),s};this.setOperator=t=>{if(typeof t!="function")return t;let e=Dr(t),n=e.keys(),s=n.next().value,i=n.next().value,c=["self","node"],d=["origin","parent","graph","router"],p=!1;if(s&&c.forEach(y=>{s.includes(y)&&(p=!0)}),i&&d.forEach(y=>{i.includes(y)&&(p=!0)}),!p){let y=t;t=(v,m,...l)=>y(...l),this.arguments&&e.forEach((v,m)=>{this.arguments.has(m)||this.arguments.set(m,v)})}return this.operator=t,t};this.run=(...t)=>this._run(this,void 0,...t);this.runAsync=(...t)=>new Promise((e,n)=>{e(this._run(this,void 0,...t))});this.transformArgs=(t=[])=>t;this._run=(t=this,e,...n)=>{if(typeof this.transformArgs=="function"&&(n=this.transformArgs(n,t)),typeof t!="object"){if(typeof t=="string"){let s;this.graph&&(s=this.graph.nodes.get(t)),s||(s=this.nodes.get(t)),t=s}if(!t)return}if(!(t.firstRun&&(t.firstRun=!1,t.children&&t.forward||t.parent&&t.backward||t.repeat||t.delay||t.frame||t.recursive||t.branch||(t.runSync=!0),t.animate&&!t.isAnimating&&t.runAnimation(t.animation,n,t,e),t.loop&&typeof t.loop=="number"&&!t.isLooping&&t.runLoop(t.looper,n,t,e),t.loop||t.animate)))return t.runSync?t.runOp(t,e,...n):new Promise(async s=>{if(t){let i=(d,p=0,...y)=>new Promise(async v=>{p++;let m=await d.runOp(d,e,...y);if(d.repeat){for(;p<d.repeat;){if(d.delay){setTimeout(async()=>{v(await i(d,p,...y))},d.delay);break}else if(d.frame&&window?.requestAnimationFrame){requestAnimationFrame(async()=>{v(await i(d,p,...y))});break}else m=await d.runOp(d,e,...y);p++}if(p===d.repeat){v(m);return}}else if(d.recursive){for(;p<d.recursive;){if(d.delay){setTimeout(async()=>{v(await i(d,p,...m))},d.delay);break}else if(d.frame&&window?.requestAnimationFrame){requestAnimationFrame(async()=>{v(await i(d,p,...m))});break}else m=await d.runOp(d,e,...m);p++}if(p===d.recursive){v(m);return}}else{v(m);return}}),c=async()=>{let d=await i(t,void 0,...n);return d!==void 0&&(t.backward&&t.parent instanceof Q&&(Array.isArray(d)?await this.runParent(t,...d):await this.runParent(t,d)),t.children&&t.forward&&(Array.isArray(d)?await this.runChildren(t,...d):await this.runChildren(t,d)),t.branch&&this.runBranch(t,d)),d};t.delay?setTimeout(async()=>{s(await c())},t.delay):t.frame&&window?.requestAnimationFrame?requestAnimationFrame(async()=>{s(await c())}):s(await c())}else s(void 0)})};this.runParent=async(t,...e)=>{t.backward&&t.parent&&(typeof t.parent=="string"&&(t.graph&&t.graph?.get(t.parent)?(t.parent=t.graph,t.parent&&this.nodes.set(t.parent.tag,t.parent)):t.parent=this.nodes.get(t.parent)),t.parent instanceof Q&&await t.parent._run(t.parent,this,...e))};this.runChildren=async(t,...e)=>{if(typeof t.children=="object")for(let n in t.children)typeof t.children[n]=="string"?(t.graph&&t.graph?.get(t.children[n])&&(t.children[n]=t.graph.get(t.children[n]),t.nodes.get(t.children[n].tag)||t.nodes.set(t.children[n].tag,t.children[n])),!t.children[n]&&t.nodes.get(t.children[n])&&(t.children[n]=t.nodes.get(t.children[n]))):(typeof t.children[n]>"u"||t.children[n]===!0)&&(t.graph&&t.graph?.get(n)&&(t.children[n]=t.graph.get(n),t.nodes.get(t.children[n].tag)||t.nodes.set(t.children[n].tag,t.children[n])),!t.children[n]&&t.nodes.get(n)&&(t.children[n]=t.nodes.get(n))),t.children[n]?.runOp&&await t.children[n]._run(t.children[n],t,...e)};this.runBranch=async(t,e)=>{if(t.branch){let n=Object.keys(t.branch);await Promise.all(n.map(async s=>{typeof t.branch[s].if=="object"&&(t.branch[s].if=Et(t.branch[s].if));let i=!1;return typeof e=="object"&&(Et(e)===t.branch[s].if||t.branch[s].if,i=!0),i&&(t.branch[s].then instanceof Q?Array.isArray(e)?await t.branch[s].then._run(t.branch[s].then,t,...e):await t.branch[s].then._run(t.branch[s].then,t,...e):typeof t.branch[s].then=="function"?Array.isArray(e)?await t.branch[s].then(...e):await t.branch[s].then(e):typeof t.branch[s].then=="string"&&(t.graph?t.branch[s].then=t.graph.nodes.get(t.branch[s].then):t.branch[s].then=t.nodes.get(t.branch[s].then),t.branch[s].then instanceof Q&&(Array.isArray(e)?await t.branch[s].then._run(t.branch[s].then,t,...e):await t.branch[s].then._run(t.branch[s].then,t,...e)))),i}))}};this.runAnimation=(t=this.animation,e=[],n=this,s)=>{if(this.animation=t,t||(this.animation=this.operator),n.animate&&!n.isAnimating&&"requestAnimationFrame"in window){n.isAnimating=!0;let i=async()=>{if(n.isAnimating){n.DEBUGNODE&&console.time(n.tag);let c=this.animation(n,s,...e);c instanceof Promise&&(c=await c),n.DEBUGNODE&&(console.timeEnd(n.tag),c!==void 0&&console.log(`${n.tag} result:`,c)),c!==void 0&&(this.tag&&this.setState({[this.tag]:c}),n.backward&&n.parent?._run&&(Array.isArray(c)?await this.runParent(n,...c):await this.runParent(n,c)),n.children&&n.forward&&(Array.isArray(c)?await this.runChildren(n,...c):await this.runChildren(n,c)),n.branch&&this.runBranch(n,c),this.setState({[n.tag]:c})),requestAnimationFrame(i)}};requestAnimationFrame(i)}};this.runLoop=(t=this.looper,e=[],n=this,s,i=n.loop)=>{if(n.looper=t,t||(n.looper=n.operator),typeof i=="number"&&!n.isLooping){n.isLooping=!0;let c=async()=>{if(n.isLooping){n.DEBUGNODE&&console.time(n.tag);let d=n.looper(n,s,...e);d instanceof Promise&&(d=await d),n.DEBUGNODE&&(console.timeEnd(n.tag),d!==void 0&&console.log(`${n.tag} result:`,d)),d!==void 0&&(n.tag&&n.setState({[n.tag]:d}),n.backward&&n.parent?._run&&(Array.isArray(d)?await this.runParent(n,...d):await this.runParent(n,d)),n.children&&n.forward&&(Array.isArray(d)?await this.runChildren(n,...d):await this.runChildren(n,d)),n.branch&&this.runBranch(n,d),n.setState({[n.tag]:d})),setTimeout(async()=>{await c()},i)}};c()}};this.setParent=t=>{this.parent=t,this.backward&&(this.runSync=!1)};this.setChildren=t=>{this.children=t,this.forward&&(this.runSync=!1)};this.add=(t={})=>(typeof t=="function"&&(t={operator:t}),t instanceof Q||(t=new Q(t,this,this.graph)),this.nodes.set(t.tag,t),this.graph&&(this.graph.nodes.set(t.tag,t),this.graph.nNodes++),t);this.remove=t=>{typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q&&(this.nodes.delete(t.tag),this.graph&&(this.graph.nodes.delete(t.tag),this.graph.nNodes--),this.nodes.forEach(e=>{e.nodes.get(t.tag)&&e.nodes.delete(t.tag)}))};this.append=(t,e=this)=>{typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q&&(e.addChildren(t),t.forward&&(t.runSync=!1))};this.subscribe=(t,e=this.tag)=>t instanceof Q?this.subscribeNode(t):this.state.subscribeTrigger(e,t);this.unsubscribe=(t,e=this.tag)=>{this.state.unsubscribeTrigger(e,t)};this.addChildren=t=>{this.children||(this.children={}),typeof t=="object"&&Object.assign(this.children,t),this.convertChildrenToNodes(),this.forward&&(this.runSync=!1)};this.callParent=(...t)=>{let e=this;if(typeof this.parent=="string"&&(this.graph&&this.graph?.get(this.parent)?(this.parent=this.graph,this.parent&&this.nodes.set(this.parent.tag,this.parent)):this.parent=this.nodes.get(this.parent)),typeof this.parent?.operator=="function")return this.parent.runOp(this.parent,e,...t)};this.callChildren=(t,...e)=>{let n=this,s;if(typeof this.children=="object")for(let i in this.children)this.children[i]?.runOp&&this.children[i].runOp(this.children[i],n,...e);return s};this.getProps=(t=this)=>({tag:t.tag,operator:t.operator,graph:t.graph,children:t.children,parent:t.parent,forward:t.forward,backward:t.bacward,loop:t.loop,animate:t.animate,frame:t.frame,delay:t.delay,recursive:t.recursive,repeat:t.repeat,branch:t.branch,oncreate:t.oncreate,DEBUGNODE:t.DEBUGNODE,...this._initial});this.setProps=(t={})=>{let e=Object.assign({},t);e.children&&(this.addChildren(t.children),delete e.children),e.operator&&(this.setOperator(t.operator),delete e.operator),Object.assign(e,t),this.children&&this.forward||this.parent&&this.backward||this.repeat||this.delay||this.frame||this.recursive||(this.runSync=!0)};this.removeTree=t=>{if(t&&typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q){let e=n=>{if(typeof n.children=="object")for(let s in n.children)n.children[s].stopNode&&n.children[s].stopNode(),n.children[s].tag&&(this.nodes.get(n.children[s].tag)&&this.nodes.delete(n.children[s].tag),this[n.children[s].tag]instanceof Q&&delete this[n.children[s].tag]),this.nodes.forEach(i=>{i.nodes.get(n.children[s].tag)&&i.nodes.delete(n.children[s].tag),i[n.children[s].tag]instanceof Q&&delete i[n.children[s].tag]}),e(n.children[s])};t.stopNode&&t.stopNode(),t.tag&&(this.nodes.delete(t.tag),this[t.tag]instanceof Q&&delete this[t.tag],this.nodes.forEach(n=>{t?.tag&&(n.nodes.get(t.tag)&&n.nodes.delete(t.tag),n[t.tag]instanceof Q&&delete n[t.tag])}),e(t),this.graph&&this.graph.removeTree(t))}};this.checkNodesHaveChildMapped=(t,e,n={})=>{let s=t.tag;s||(s=t.name),n[s]||(n[s]=!0,t.children&&e.tag in t.children&&t.children[e.tag]instanceof Q&&(t.nodes.get(e.tag)||t.nodes.set(e.tag,e),t.children[e.tag]=e,t.firstRun||(t.firstRun=!0)),t.parent instanceof Q&&(t.nodes.get(e.tag)&&!t.parent.nodes.get(e.tag)&&t.parent.nodes.set(e.tag,e),t.parent.children?this.checkNodesHaveChildMapped(t.parent,e,n):t.nodes&&t.nodes.forEach(i=>{n[i.tag]||this.checkNodesHaveChildMapped(i,e,n)})),t.graph&&t.parent&&t.parent.name!==t.graph.name&&t.graph.nodes.forEach(i=>{n[i.tag]||this.checkNodesHaveChildMapped(i,e,n)}))};this.convertChildrenToNodes=(t=this)=>{if(t?.children){for(let e in t.children)if(!(t.children[e]instanceof Q))if(typeof t.children[e]=="object")t.children[e].tag||(t.children[e].tag=e),t.nodes.get(t.children[e].tag)||(t.children[e]=new Q(t.children[e],t,t.graph),this.checkNodesHaveChildMapped(t,t.children[e]));else{if(typeof t.children[e]>"u"||t.children[e]==!0)t.children[e]=t.graph.get(e),t.children[e]||(t.children[e]=t.nodes.get(e));else if(typeof t.children[e]=="string"){let n=t.children[e];t.children[e]=t.graph.get(n),t.children[e]||(t.children[e]=t.nodes.get(e))}if(t.children[e]instanceof Q){if(t.graph&&t.children[e].parent.tag!==this.tag){let n=t.children[e].getProps();delete n.parent,delete n.graph,t.source instanceof Ae?t.children[e]=new Q(n,t,t.source):t.children[e]=new Q(n,t,t.graph)}t.nodes.set(t.children[e].tag,t.children[e]),this.checkNodesHaveChildMapped(t,t.children[e]),t.children[e].tag in t||(t[t.children[e].tag]=t.children[e])}}}return t.children};this.stopLooping=(t=this)=>{t.isLooping=!1};this.stopAnimating=(t=this)=>{t.isAnimating=!1};this.stopNode=(t=this)=>{t.stopAnimating(t),t.stopLooping(t)};this.subscribeNode=t=>(t.tag&&this.nodes.set(t.tag,t),this.state.subscribeTrigger(this.tag,e=>{t._run(t,this,e)}));this.print=(t=this,e=!0,n=[])=>{let s=new Q;if(typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q){n.push(t.tag);let i={tag:t.tag,operator:t.operator.toString()};if(t.parent&&(i.parent=t.parent.tag),typeof t.children=="object")for(let c in t.children)return typeof t.children[c]=="string"?t.children[c]:n.includes(t.children[c].tag)?t.children[c].tag:e?t.children[c].print(t.children[c],e,n):t.children[c].tag;for(let c in t)c==="parent"||c==="children"||typeof s[c]>"u"&&(typeof t[c]=="function"?i[c]=t[c].toString():typeof t[c]=="object"?i[c]=JSON.stringifyWithCircularRefs(t[c]):i[c]=t[c]);return JSON.stringify(i)}};this.reconstruct=t=>{let e=Nn(t);if(e)return this.add(e)};this.setState=this.state.setState;this.DEBUGNODES=(t=!0)=>{this.DEBUGNODE=t,this.nodes.forEach(e=>{t?e.DEBUGNODE=!0:e.DEBUGNODE=!1})};if(typeof t=="function"&&(t={operator:t}),typeof t=="object"){if(t instanceof Q&&t._initial&&Object.assign(t,t._initial),t instanceof Ae){let i=t;t={source:i,operator:c=>{if(typeof c=="object"){let d={};for(let p in c)typeof i[p]=="function"?Array.isArray(c[p])?d[p]=i[p](...c[p]):d[p]=i[p](c[p]):(i[p]=c[p],d[p]=i[p]);return d}return i}},i.operator&&(t.operator=i.operator),i.children&&(t.children=i.children),i.forward&&(t.forward=i.forward),i.backward&&(t.backward=i.backward),i.repeat&&(t.repeat=i.repeat),i.recursive&&(t.recursive=i.recursive),i.loop&&(t.loop=i.loop),i.animate&&(t.animate=i.animate),i.looper&&(t.looper=i.looper),i.animation&&(t.animation=i.animation),i.delay&&(t.delay=i.delay),i.tag&&(t.tag=i.tag),i.oncreate&&(t.oncreate=i.oncreate),i.node&&i.node._initial&&Object.assign(t,i.node._initial),i._initial&&Object.assign(t,i._initial),this.nodes=i.nodes,i.node=this,n&&i.nodes.forEach(c=>{n.nodes.get(c.tag)||(n.nodes.set(c.tag,c),n.nNodes++)})}if(t.tag&&(n||e)){let i;if(n?.nodes&&(i=n.nodes.get(t.tag)),!i&&e?.nodes&&(i=e.nodes.get(t.tag)),i){Object.assign(this,i),this.source||(this.source=i);let c=i.getProps();delete c.graph,delete c.parent,Object.assign(t,c)}}if(t?.operator&&(t.operator=this.setOperator(t.operator)),!t.tag&&n?t.tag=`node${n.nNodes}`:t.tag||(t.tag=`node${Math.floor(Math.random()*1e10)}`),"arguments"in t){if(t.arguments)for(let i in t.arguments)this.arguments.set(i,t.arguments[i]);t.arguments=this.arguments}let s=Object.getOwnPropertyNames(this);for(let i in t)s.includes(i)||(this._initial[i]=t[i]);if(t.children&&(this._initial.children=Object.assign({},t.children)),Object.assign(this,t),this.tag||(n?this.tag=`node${n.nNodes}`:this.tag=`node${Math.floor(Math.random()*1e10)}`),e&&(this.parent=e,(e instanceof Q||e instanceof Ae)&&e.nodes.set(this.tag,this)),n&&(this.graph=n,n.nodes.get(this.tag)&&(this.tag=`${this.tag}${n.nNodes+1}`),n.nodes.set(this.tag,this),n.nNodes++),typeof t.tree=="object")for(let i in t.tree){typeof t.tree[i]=="object"&&(!t.tree[i]).tag&&(t.tree[i].tag=i);let c=new Q(t.tree[i],this,n);this.nodes.set(c.tag,c)}this.children&&this.convertChildrenToNodes(this),(this.parent instanceof Q||this.parent instanceof Ae)&&this.checkNodesHaveChildMapped(this.parent,this),typeof this.oncreate=="function"&&this.oncreate(this),this.firstRun||(this.firstRun=!0)}else return t}},Ae=class{constructor(t,e,n){this.nNodes=0;this.nodes=new Map;this.state=_e;this.tree={};this.add=(t={})=>{let e=t;return t instanceof Q?this.nNodes++:t=new Q(e,this,this),t.tag&&(this.tree[t.tag]=e),this.nodes.set(t.tag,t),t};this.setTree=(t=this.tree)=>{if(!!t){for(let e in t)if(this.nodes.get(e)){let n=this.nodes.get(e);if(typeof t[e]=="function")n.setOperator(t[e]);else if(typeof t[e]=="object")if(t[e]instanceof Q)n.tag!==t[e].tag&&this.add(t[e]);else if(t[e]instanceof Ae){let s=t[e],i={};s.operator&&(i.operator=s.operator),s.children&&(i.children=s.children),s.forward&&(i.forward=s.forward),s.backward&&(i.backward=s.backward),s.repeat&&(i.repeat=s.repeat),s.recursive&&(i.recursive=s.recursive),s.loop&&(i.loop=s.loop),s.animate&&(i.animate=s.animate),s.looper&&(i.looper=s.looper),s.animation&&(i.animation=s.animation),s.delay&&(i.delay=s.delay),s.tag&&(i.tag=s.tag),s.oncreate&&(i.oncreate=s.oncreate),s.node?._initial&&Object.assign(i,s.node._initial),i.nodes=s.nodes,i.source=s,n.setProps(i)}else n.setProps(t[e])}else if(typeof t[e]=="function")this.add({tag:e,operator:t[e]});else if(typeof t[e]=="object"&&!Array.isArray(t[e])){t[e].tag||(t[e].tag=e);let n=this.add(t[e]);t[e].aliases&&t[e].aliases.forEach(s=>{this.nodes.set(s,n)})}else this.add({tag:e,operator:(n,s,...i)=>t[e]});this.nodes.forEach(e=>{if(typeof e.children=="object")for(let n in e.children)typeof e.children[n]=="string"?this.nodes.get(e.children[n])&&(e.children[n]=this.nodes.get(e.children[n])):(e.children[n]===!0||typeof e.children[n]>"u")&&this.nodes.get(n)&&(e.children[n]=this.nodes.get(n)),e.children[n]instanceof Q&&e.checkNodesHaveChildMapped(e,e.children[n]);typeof e.parent=="string"&&this.nodes.get(e.parent)&&(e.parent=this.nodes.get(e.parent),e.nodes.set(e.parent.tag,e.parent))})}};this.get=t=>this.nodes.get(t);this.set=t=>this.nodes.set(t.tag,t);this.run=(t,...e)=>{if(typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q)return t._run(t,this,...e)};this.runAsync=(t,...e)=>(typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q?new Promise((n,s)=>{n(t._run(t,this,...e))}):new Promise((n,s)=>{n(void 0)}));this._run=(t,e=this,...n)=>{if(typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q)return t._run(t,e,...n)};this.removeTree=t=>{if(typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q){let e=n=>{n.children&&(Array.isArray(n.children)?n.children.forEach(s=>{s.stopNode&&s.stopNode(),s.tag&&this.nodes.get(s.tag)&&this.nodes.delete(s.tag),this.nodes.forEach(i=>{i.nodes.get(s.tag)&&i.nodes.delete(s.tag)}),e(s)}):typeof n.children=="object"&&(n.stopNode&&n.stopNode(),n.tag&&this.nodes.get(n.tag)&&this.nodes.delete(n.tag),this.nodes.forEach(s=>{s.nodes.get(n.tag)&&s.nodes.delete(n.tag)}),e(n)))};t.stopNode&&t.stopNode(),t.tag&&(this.nodes.delete(t.tag),this.nodes.forEach(n=>{n.nodes.get(t.tag)&&n.nodes.delete(t.tag)}),this.nNodes--,e(t))}return t};this.remove=t=>(typeof t=="string"&&(t=this.nodes.get(t)),t?.tag&&(t.stopNode(),t?.tag&&this.nodes.get(t.tag)&&(this.nodes.delete(t.tag),this.nodes.forEach(e=>{e.nodes.get(t.tag)&&e.nodes.delete(t.tag)}))),t);this.append=(t,e)=>{e.addChildren(t)};this.callParent=async(t,e=t,...n)=>{if(t?.parent)return await t.callParent(t,e,...n)};this.callChildren=async(t,e,...n)=>{if(t?.children)return await t.callChildren(e,...n)};this.subscribe=(t,e)=>{if(!!e){if(t instanceof Q)return t.subscribe(e);if(typeof t=="string")return this.state.subscribeTrigger(t,e)}};this.unsubscribe=(t,e)=>{this.state.unsubscribeTrigger(t,e)};this.subscribeNode=(t,e)=>{let n;return t?.tag?n=t.tag:typeof t=="string"&&(n=t),this.state.subscribeTrigger(n,s=>{this.run(e,t,...s)})};this.stopNode=t=>{typeof t=="string"&&(t=this.nodes.get(t)),t instanceof Q&&t.stopNode()};this.print=(t=void 0,e=!0)=>{if(t instanceof Q)return t.print(t,e);{let n="{";return this.nodes.forEach(s=>{n+=`
"${s.tag}:${s.print(s,e)}"`}),n}};this.reconstruct=t=>{let e=Nn(t);if(e)return this.add(e)};this.create=(t,e,n)=>Cr(t,e,n,this);this.setState=this.state.setState;this.DEBUGNODES=(t=!0)=>{this.nodes.forEach(e=>{t?e.DEBUGNODE=!0:e.DEBUGNODE=!1})};this.tag=e||`graph${Math.floor(Math.random()*1e11)}`,n&&(Object.assign(this,n),this._initial=n),(t||Object.keys(this.tree).length>0)&&this.setTree(t)}};function Nn(u="{}"){try{let t=typeof u=="string"?JSON.parse(u):u,e=n=>{for(let s in n)if(typeof n[s]=="string"){let i=He(n[s]);typeof i=="function"&&(n[s]=i)}else typeof n[s]=="object"&&e(n[s]);return n};return e(t)}catch(t){console.error(t);return}}var _t=function(){let u=new Map,t=[],e=["this"];function n(){u.clear(),t.length=0,e.length=1}function s(c,d){var p=t.length-1,y=t[p];if(typeof y=="object")if(y[c]===d||p===0)e.push(c),t.push(d.pushed);else for(;p-->=0;){if(y=t[p],typeof y=="object"&&y[c]===d){p+=2,t.length=p,e.length=p,--p,t[p]=d,e[p]=c;break}p--}}function i(c,d){if(d!=null&&typeof d=="object"){c&&s(c,d);let p=u.get(d);if(p)return"[Circular Reference]"+p;u.set(d,e.join("."))}return d}return function(d,p){try{return t.push(d),JSON.stringify(d,i,p)}finally{n()}}}();JSON.stringifyWithCircularRefs===void 0&&(JSON.stringifyWithCircularRefs=_t);var Et=function(){let u=new Map,t=[],e=["this"];function n(){u.clear(),t.length=0,e.length=1}function s(c,d){var p=t.length-1;if(t[p]){var y=t[p];if(typeof y=="object")if(y[c]===d||p===0)e.push(c),t.push(d.pushed);else for(;p-->=0;){if(y=t[p],typeof y=="object"&&y[c]===d){p+=2,t.length=p,e.length=p,--p,t[p]=d,e[p]=c;break}p++}}}function i(c,d){let p;if(d!=null)if(typeof d=="object"){let y=d.constructor.name;c&&y==="Object"&&s(c,d);let v=u.get(d);if(v)return"[Circular Reference]"+v;if(u.set(d,e.join(".")),y==="Array")d.length>20?p=d.slice(d.length-20):p=d;else if(y.includes("Set"))p=Array.from(d);else if(y!=="Object"&&y!=="Number"&&y!=="String"&&y!=="Boolean")p="instanceof_"+y;else if(y==="Object"){let m={};for(let l in d)if(d[l]==null)m[l]=d[l];else if(Array.isArray(d[l]))d[l].length>20?m[l]=d[l].slice(d[l].length-20):m[l]=d[l];else if(d[l].constructor.name==="Object"){m[l]={};for(let h in d[l])if(Array.isArray(d[l][h]))d[l][h].length>20?m[l][h]=d[l][h].slice(d[l][h].length-20):m[l][h]=d[l][h];else if(d[l][h]!=null){let a=d[l][h].constructor.name;a.includes("Set")?m[l][h]=Array.from(d[l][h]):a!=="Number"&&a!=="String"&&a!=="Boolean"?m[l][h]="instanceof_"+a:m[l][h]=d[l][h]}else m[l][h]=d[l][h]}else{let h=d[l].constructor.name;h.includes("Set")?m[l]=Array.from(d[l]):h!=="Number"&&h!=="String"&&h!=="Boolean"?m[l]="instanceof_"+h:m[l]=d[l]}p=m}else p=d}else p=d;return p}return function(d,p){t.push(d);let y=JSON.stringify(d,i,p);return n(),y}}();JSON.stringifyFast===void 0&&(JSON.stringifyFast=Et);function Cr(u,t,e,n){return typeof e=="object"?(e.operator=u,new Q(e,t,n)):new Q({operator:u},t,n)}var we=class extends Ae{constructor(e={}){super(void 0,e.name,e.props);this.routes={};this.loadDefaultRoutes=!1;this.name=`service${Math.floor(Math.random()*1e14)}`;this.keepState=!0;this.firstLoad=!0;this.init=e=>{e=Object.assign({},e),"loadDefaultRoutes"in e&&(this.loadDefaultRoutes=e.loadDefaultRoutes),e.customRoutes?Object.assign(e.customRoutes,this.customRoutes):e.customRoutes=this.customRoutes,e.customChildren?Object.assign(e.customChildren,this.customChildren):e.customChildren=this.customChildren,Array.isArray(e.routes)?e.routes.forEach(n=>{this.load(n,e.includeClassName,e.routeFormat,e.customRoutes,e.customChildren)}):(e.routes||Object.keys(this.routes).length>0&&this.firstLoad)&&this.load(e.routes,e.includeClassName,e.routeFormat,e.customRoutes,e.customChildren)};this.load=(e,n=!0,s=".",i,c)=>{if(!e&&!this.loadDefaultRoutes&&(Object.keys(this.routes).length>0||this.firstLoad))return;this.firstLoad&&(this.firstLoad=!1);let d;if(e){if(!(e instanceof Ae)&&e?.name)if(e.module){let p=e;e={},Object.getOwnPropertyNames(e.module).forEach(y=>{n?e[p.name+s+y]=e.module[y]:e[y]=e.module[y]})}else typeof e=="function"&&(d=new e({loadDefaultRoutes:this.loadDefaultRoutes}),d.load(),e=d.routes);else if(e instanceof Ae||e.source instanceof Ae){d=e,e={};let p;n&&(p=d.name,p||(p=d.tag,d.name=p),p||(p=`graph${Math.floor(Math.random()*1e15)}`,d.name=p,d.tag=p)),d.nodes.forEach(y=>{e[y.tag]=y;let v={},m=(l,h)=>{if((!v[l.tag]||h&&n&&!v[h?.tag+s+l.tag])&&(h?v[h.tag+s+l.tag]=!0:v[l.tag]=!0,l instanceof Ae||l.source instanceof Ae)){if(n){let a=l.name;a||(a=l.tag,l.name=a),a||(a=`graph${Math.floor(Math.random()*1e15)}`,l.name=a,l.tag=a)}l.nodes.forEach(a=>{n?e[l.tag+s+a.tag]=a:e[a.tag]||(e[a.tag]=a),m(a,l)})}};m(y)})}else if(typeof e=="object"){let p=e.constructor.name;if(p==="Object"&&(p=Object.prototype.toString.call(e),p&&(p=p.split(" ")[1]),p&&(p=p.split("]")[0])),p&&p!=="Object"){let y=e;e={},Object.getOwnPropertyNames(y).forEach(v=>{n?e[p+s+v]=y[v]:e[v]=y[v]})}}if(d instanceof Ae&&d.name&&n){e=Object.assign({},e);for(let p in e){let y=e[p];delete e[p],e[d.name+s+p]=y}}}if(this.loadDefaultRoutes){let p=Object.assign({},this.defaultRoutes);e?(Object.assign(p,this.routes),e=Object.assign(p,e)):e=Object.assign(p,this.routes),this.loadDefaultRoutes=!1}e||(e=this.routes);for(let p in e){let y=(v,m)=>{if(v.tag||(v.tag=m),typeof v?.children=="object"){e:for(let l in v.children)if(typeof v.children[l]=="object"){let h=v.children[l];if(h.tag&&e[h.tag])continue;if(c){for(let a in c)if(h=c[a](h,l,v,e),!h)continue e}h.tag?(e[h.tag]=v.children[l],y(e[h.tag],l)):h.id?(h.tag=h.id,e[h.tag]=v.children[l],y(e[h.tag],l)):(e[l]=v.children[l],y(e[l],l))}}};y(e[p],p)}e:for(let p in e)if(typeof e[p]=="object"){let y=e[p];if(typeof y=="object"){if(i){for(let v in i)if(y=i[v](y,p,e),!y)continue e}y.get&&y.get,y.post,y.delete,y.put,y.head,y.patch,y.options,y.connect,y.trace,y.post&&!y.operator?e[p].operator=y.post:!y.operator&&typeof y.get=="function"&&(e[p].operator=y.get)}this.routes[p]?typeof this.routes[p]=="object"?Object.assign(this.routes[p],e[p]):this.routes[p]=e[p]:this.routes[p]=e[p]}else this.routes[p]?typeof this.routes[p]=="object"?Object.assign(this.routes[p],e[p]):this.routes[p]=e[p]:this.routes[p]=e[p];this.setTree(this.routes);for(let p in this.routes)this.routes[p]?.aliases&&this.routes[p].aliases.forEach(v=>{d?.name&&n?e[d.name+s+v]=this.routes[p]:e[v]=this.routes[p]});return this.routes};this.unload=(e=this.routes)=>{if(!e)return;let n;!(e instanceof we)&&typeof e=="function"?(n=new we,e=n.routes):e instanceof we&&(e=e.routes);for(let s in e)delete this.routes[s],this.nodes.get(s)&&this.remove(s);return this.routes};this.handleMethod=(e,n,s,i)=>{let c=n.toLowerCase();return c==="get"&&this.routes[e]?.get?.transform instanceof Function?Array.isArray(s)?this.routes[e].get.transform(...s):this.routes[e].get.transform(s):this.routes[e]?.[c]?this.routes[e][c]instanceof Function?this.routes[e][c](s):(s&&(this.routes[e][c]=s),this.routes[e][c]):this.handleServiceMessage({route:e,args:s,method:n,origin:i})};this.transmit=(...e)=>{if(typeof e[0]=="object"){if(e[0].method)return this.handleMethod(e[0].route,e[0].method,e[0].args);if(e[0].route)return this.handleServiceMessage(e[0]);if(e[0].node)return this.handleGraphNodeCall(e[0].node,e[0].args,e[0].origin);this.keepState&&(e[0].route&&this.setState({[e[0].route]:e[0].args}),e[0].node&&this.setState({[e[0].node]:e[0].args}))}else return e};this.receive=(...e)=>{if(e[0]&&typeof e[0]=="string"){let n=e[0].substring(0,8);(n.includes("{")||n.includes("["))&&(n.includes("\\")&&(e[0]=e[0].replace(/\\/g,"")),e[0][0]==='"'&&(e[0]=e[0].substring(1,e[0].length-1)),e[0]=JSON.parse(e[0]))}if(typeof e[0]=="object"){if(e[0].method)return this.handleMethod(e[0].route,e[0].method,e[0].args);if(e[0].route)return this.handleServiceMessage(e[0]);if(e[0].node)return this.handleGraphNodeCall(e[0].node,e[0].args,e[0].origin);this.keepState&&(e[0].route&&this.setState({[e[0].route]:e[0].args}),e[0].node&&this.setState({[e[0].node]:e[0].args}))}else return e};this.pipe=(e,n,s,i,c,d)=>{if(e instanceof Q)return d?e.subscribe(p=>{let y=d(p);y!==void 0?this.transmit({route:n,args:y,origin:i,method:c}):this.transmit({route:n,args:p,origin:i,method:c},s)}):this.subscribe(e,p=>{this.transmit({route:n,args:p,origin:i,method:c},s)});if(typeof e=="string")return this.subscribe(e,p=>{this.transmit({route:n,args:p,origin:i,method:c},s)})};this.pipeOnce=(e,n,s,i,c,d)=>{if(e instanceof Q)return d?e.state.subscribeTriggerOnce(e.tag,p=>{let y=d(p);y!==void 0?this.transmit({route:n,args:y,origin:i,method:c}):this.transmit({route:n,args:p,origin:i,method:c},s)}):this.state.subscribeTriggerOnce(e.tag,p=>{this.transmit({route:n,args:p,origin:i,method:c},s)});if(typeof e=="string")return this.state.subscribeTriggerOnce(e,p=>{this.transmit({route:n,args:p,origin:i,method:c},s)})};this.terminate=(...e)=>{this.nodes.forEach(n=>{n.stopNode()})};this.recursivelyAssign=(e,n)=>{for(let s in n)typeof n[s]=="object"?typeof e[s]=="object"?this.recursivelyAssign(e[s],n[s]):e[s]=this.recursivelyAssign({},n[s]):e[s]=n[s];return e};this.defaultRoutes={"/":{get:()=>this.print(),aliases:[""]},ping:()=>(console.log("ping"),"pong"),echo:(...e)=>(this.transmit(...e),e),assign:e=>typeof e=="object"?(Object.assign(this,e),!0):!1,recursivelyAssign:e=>typeof e=="object"?(this.recursivelyAssign(this,e),!0):!1,log:{post:(...e)=>{console.log("Log: ",...e)},aliases:["info"]},error:e=>{let n=new Error(e);return console.error(e),n},state:e=>e?this.state.data[e]:this.state.data,printState:e=>e?_t(this.state.data[e]):_t(this.state.data),transmit:this.transmit,receive:this.receive,load:this.load,unload:this.unload,pipe:this.pipe,terminate:this.terminate,run:this.run,_run:this._run,subscribe:this.subscribe,unsubscribe:this.unsubscribe,stopNode:this.stopNode,get:this.get,add:this.add,remove:this.remove,setTree:this.setTree,setState:this.setState,print:this.print,reconstruct:this.reconstruct,handleMethod:this.handleMethod,handleServiceMessage:this.handleServiceMessage,handleGraphNodeCall:this.handleGraphNodeCall};e.name&&(this.name=e.name),(e.routes||Object.keys(this.routes).length>0)&&this.init(e)}handleServiceMessage(e){let n;return typeof e=="object"&&(e.route?n=e.route:e.node&&(n=e.node)),n?e.origin?Array.isArray(e.args)?this._run(n,e.origin,...e.args):this._run(n,e.origin,e.args):Array.isArray(e.args)?this.run(n,...e.args):this.run(n,e.args):e}handleGraphNodeCall(e,n,s){if(!e)return n;if(n?.args)this.handleServiceMessage(n);else return s?Array.isArray(n)?this._run(e,s,...n):this._run(e,s,n):Array.isArray(n)?this.run(e,...n):this.run(e,n)}isTypedArray(e){return ArrayBuffer.isView(e)&&Object.prototype.toString.call(e)!=="[object DataView]"}};var Ze=class extends HTMLElement{constructor(){super();Ee(this,"template",(e,n=this)=>`<div> Custom Fragment Props: ${JSON.stringify(e)} </div>`);Ee(this,"props",{});Ee(this,"useShadow",!1);Ee(this,"styles");Ee(this,"oncreate");Ee(this,"onresize");Ee(this,"ondelete");Ee(this,"onchanged");Ee(this,"renderonchanged",!1);Ee(this,"FRAGMENT");Ee(this,"attachedShadow",!1);Ee(this,"obsAttributes",["props","options","onchanged","onresize","ondelete","oncreate","template"]);Ee(this,"delete",()=>{this.remove(),typeof this.ondelete=="function"&&this.ondelete(this.props)});Ee(this,"render",(e=this.props)=>{typeof this.template=="function"?this.templateResult=this.template(e,this):this.templateResult=this.template;let n=document.createElement("template");typeof this.templateResult=="string"?n.innerHTML=this.templateResult:this.templateResult instanceof HTMLElement&&(this.templateResult.parentNode&&this.templateResult.parentNode.removeChild(this.templateResult),n.appendChild(this.templateResult));let s=n.content;this.FRAGMENT&&(this.useShadow?this.shadowRoot.removeChild(this.FRAGMENT):this.removeChild(this.FRAGMENT)),this.useShadow?(this.attachedShadow||this.attachShadow({mode:"open"}),this.shadowRoot.prepend(s),this.FRAGMENT=this.shadowRoot.childNodes[0]):this.prepend(s),this.FRAGMENT=this.childNodes[0];let i=new CustomEvent("rendered",{detail:{props:this.props,self:this}});this.dispatchEvent("rendered"),this.oncreate&&this.oncreate(this,e)});Ee(this,"state",{pushToState:{},data:{},triggers:{},setState(e){if(Object.assign(this.pushToState,e),Object.keys(this.triggers).length>0)for(let n of Object.getOwnPropertyNames(this.triggers))this.pushToState[n]&&(this.data[n]=this.pushToState[n],delete this.pushToState[n],this.triggers[n].forEach(s=>{s.onchanged(this.data[n])}));return this.pushToState},subscribeTrigger(e,n=s=>{}){if(e){this.triggers[e]||(this.triggers[e]=[]);let s=this.triggers[e].length;return this.triggers[e].push({idx:s,onchanged:n}),this.triggers[e].length-1}else return},unsubscribeTrigger(e,n){let s,i=this.triggers[e];if(i)if(!n)delete this.triggers[e];else return i.find(d=>{if(d.idx===n)return!0})&&i.splice(s,1),!0},subscribeTriggerOnce(e=void 0,n=s=>{}){let s,i=c=>{n(c),this.unsubscribeTrigger(e,s)};s=this.subscribeTrigger(e,i)}})}get observedAttributes(){return this.obsAttributes}get obsAttributes(){return this.obsAttributes}set obsAttributes(e){typeof e=="string"?this.obsAttributes.push(e):Array.isArray(e)&&(this.obsAttributes=e)}static get tag(){return this.name.toLowerCase()+"-"}static addElement(e=this.tag,n=this,s=void 0){Fr(n,e,s)}attributeChangedCallback(e,n,s){if(e==="onchanged"){let i=s;if(typeof i=="string"&&(i=Ue(i)),typeof i=="function"){this.onchanged=i,this.state.data.props=this.props,this.state.unsubscribeTrigger("props"),this.state.subscribeTrigger("props",this.onchanged);let c=new CustomEvent("changed",{detail:{props:this.props,self:this}});this.state.subscribeTrigger("props",()=>{this.dispatchEvent(c)})}}else if(e==="onresize"){let i=s;if(typeof i=="string"&&(i=Ue(i)),typeof i=="function"){if(this.ONRESIZE)try{window.removeEventListener("resize",this.ONRESIZE)}catch{}this.ONRESIZE=c=>{this.onresize(this.props,this)},this.onresize=i,window.addEventListener("resize",this.ONRESIZE)}}else if(e==="ondelete"){let i=s;typeof i=="string"&&(i=Ue(i)),typeof i=="function"&&(this.ondelete=()=>{this.ONRESIZE&&window.removeEventListener("resize",this.ONRESIZE),this.state.unsubscribeTrigger("props"),i&&i(this.props,this)})}else if(e==="oncreate"){let i=s;typeof i=="string"&&(i=Ue(i)),typeof i=="function"&&(this.oncreate=i)}else if(e==="renderonchanged"){let i=s;typeof this.renderonchanged=="number"&&this.unsubscribeTrigger(this.renderonchanged),typeof i=="string"&&(i=Ue(i)),typeof i=="function"?this.renderonchanged=this.state.subscribeTrigger("props",c=>{this.render(c),i(this,c)}):i!=!1&&(this.renderonchanged=this.state.subscribeTrigger("props",this.render))}else if(e==="props"){let i=s;typeof i=="string"&&(i=JSON.parse(i)),Object.assign(this.props,i),this.state.setState({props:this.props})}else if(e==="template"){let i=s;this.template=i,this.render(this.props);let c=new CustomEvent("created",{detail:{props:this.props}});this.dispatchEvent(c)}else{let i=s;if(e.includes("eval_"))e=e.split("_"),e.shift(),e=e.join(),i=Ue(s);else if(typeof s=="string")try{i=JSON.parse(s)}catch{i=s}this[e]=i,e!=="props"&&(this.props[e]=i)}}connectedCallback(){let e=this.getAttribute("props");typeof e=="string"&&(e=JSON.parse(e)),Object.assign(this.props,e),this.state.setState({props:this.props}),Array.from(this.attributes).forEach(d=>{let p=d.name,y=d.value;if(p.includes("eval_"))p=p.split("_"),p.shift(),p=p.join(),y=Ue(d.value);else if(typeof d.value=="string")try{y=JSON.parse(d.value)}catch{y=d.value}this[p]||Object.defineProperties(this,d,{value:y,writable:!0,get(){return this[p]},set(v){this.setAttribute(p,v)}}),this[p]=y,p!=="props"&&(this.props[p]=y),this.obsAttributes.push(p)});let n=new CustomEvent("resized",{detail:{props:this.props,self:this}}),s=new CustomEvent("changed",{detail:{props:this.props,self:this}}),i=new CustomEvent("deleted",{detail:{props:this.props,self:this}}),c=new CustomEvent("created",{detail:{props:this.props,self:this}});if(this.styles){let d=`
            <style>
                ${templateStr}
            </style>
            `;this.template.indexOf("<style")?this.template.splice(this.template.indexOf("<style"+7),this.template.indexOf("</style"),templateStr):this.template.indexOf("<head")?this.template.splice(this.template.indexOf("<head"+6),0,d):this.template=d+this.template,this.useShadow=!0}if(this.render(this.props),this.dispatchEvent(c),this.state.subscribeTrigger("props",()=>{this.dispatchEvent(s)}),typeof this.onresize=="function"){if(this.ONRESIZE)try{window.removeEventListener("resize",this.ONRESIZE)}catch{}this.ONRESIZE=d=>{this.onresize(this,this.props),this.dispatchEvent(n)},window.addEventListener("resize",this.ONRESIZE)}if(typeof this.ondelete=="function"){let d=this.ondelete;this.ondelete=(p=this.props)=>{this.ONRESIZE&&window.removeEventListener("resize",this.ONRESIZE),this.state.unsubscribeTrigger("props"),this.dispatchEvent(i),d(this,p)}}if(typeof this.onchanged=="function"&&(this.state.data.props=this.props,this.state.subscribeTrigger("props",this.onchanged)),this.renderonchanged){let d=this.renderonchanged;typeof this.renderonchanged=="number"&&this.unsubscribeTrigger(this.renderonchanged),typeof d=="string"&&(d=Ue(d)),typeof d=="function"?this.renderonchanged=this.state.subscribeTrigger("props",p=>{this.render(p),d(this,p)}):d!==!1&&(this.renderonchanged=this.state.subscribeTrigger("props",this.render))}}get props(){return this.props}set props(e={}){this.setAttribute("props",e)}get template(){return this.template}set template(e){this.setAttribute("template",e)}get render(){return this.render}get delete(){return this.delete}get state(){return this.state}get onchanged(){return this.onchanged}set onchanged(e){this.setAttribute("onchanged",e)}get styles(){return this.styles}set styles(e){let n=`
        <style>
            ${e}
        </style>
        `;this.template.indexOf("<style")?this.template.splice(this.template.indexOf("<style"+7),this.template.indexOf("</style"),e):this.template.indexOf("<head")?this.template.splice(this.template.indexOf("<head"+6),0,n):this.template=n+this.template,this.querySelector("style")?this.useShadow?this.querySelector("style").innerHTML=e:(this.useShadow=!0,this.render()):(this.useShadow=!0,this.render())}get renderonchanged(){return this.renderonchanged}set renderonchanged(e){this.setAttribute("renderonchanged",e)}get onresize(){return this.props}set onresize(e){this.setAttribute("onresize",e)}get ondelete(){return this.props}set ondelete(e){this.setAttribute("ondelete",e)}get oncreate(){return this.oncreate}set oncreate(e){this.setAttribute("oncreated",e)}};function Fr(u,t,e=null){try{e?t?window.customElements.define(t,u,{extends:e}):window.customElements.define(u.name.toLowerCase()+"-",u,{extends:e}):t?window.customElements.define(t,u):window.customElements.define(u.name.toLowerCase()+"-",u)}catch{}}function Ue(u){let t=c=>c.replace(/^\W*(function[^{]+\{([\s\S]*)\}|[^=]+=>[^{]*\{([\s\S]*)\}|[^=]+=>(.+))/i,"$2$3$4"),n=(c=>{let d=c.indexOf(")");return c.slice(0,c.indexOf("{",d)+1)})(u),s=t(u),i;try{if(n.includes("function ")){let c=n.split("(")[1].split(")")[0];i=new Function(c,s)}else if(n.substring(0,6)===s.substring(0,6)){let c=n.split("(")[1].split(")")[0];i=new Function(c,s.substring(s.indexOf("{")+1,s.length-1))}else try{i=(0,eval)(n+s+"}")}catch{i=(0,eval)(u)}}catch{}return i}var kt=class extends we{constructor(e,n){super({props:e.props,name:e.name});this.loadDefaultRoutes=!1;this.name=`dom${Math.floor(Math.random()*1e15)}`;this.keepState=!0;this.parentNode=document.body;this.customRoutes={dom:(e,n,s)=>(e.template?(s[n].tag||(s[n].tag=n),this.addComponent(s[n],s[n].generateChildElementNodes)):e.context?(s[n].tag||(s[n].tag=n),this.addCanvasComponent(s[n])):(e.tagName||e.element)&&(s[n].tag||(s[n].tag=n),this.addElement(s[n],s[n].generateChildElementNodes)),e)};this.customChildren={dom:(e,n,s,i)=>((s.tag||s.id)&&(s.template||s.context||s.tagName||s.element)&&(e.template||e.context||e.tagName||e.element)&&!e.parentNode&&(s.tag&&(e.parentNode=s.tag),s.id&&(e.parentNode=s.id)),e)};this.elements={};this.components={};this.templates={};this.addElement=(e,n=!1)=>{let s=this.createElement(e),i=e.oncreate;delete e.oncreate,e.element||(e.element=s),e.operator||(e.operator=(p,y,v)=>{if(typeof v=="object")for(let m in v)p.element&&(typeof p.element[m]=="function"&&typeof v[m]!="function"?Array.isArray(v[m])?p.element[m](...v[m]):p.element[m](v[m]):m==="style"?Object.assign(p.element[m],v[m]):p.element[m]=v[m]);return v});let c=new Q(e,void 0,this);s.node=c;let d=Array.from(s.querySelectorAll("*"));if(n&&(d=d.map((p,y)=>this.addElement({element:p}))),this.elements[e.id]={element:s,node:c,parentNode:e.parentNode,divs:d},e.onresize){let p=e.onresize;e.onresize=y=>{p(y,s,this.elements[e.id])},window.addEventListener("resize",e.onresize)}return s.parentNode||setTimeout(()=>{typeof e.parentNode=="string"&&(e.parentNode=document.getElementById(e.parentNode)),typeof e.parentNode=="object"&&e.parentNode.appendChild(s),i&&i(s,this.elements[e.id])},.01),this.elements[e.id]};this.createElement=e=>{let n;if(e.element?typeof e.element=="string"?(n=document.querySelector(e.element),n||(n=document.getElementById(e.element))):n=e.element:e.tagName?n=document.createElement(e.tagName):e.id&&document.getElementById(e.id)&&(n=document.getElementById(e.id)),!!n)return this.updateOptions(e,n),n};this.updateOptions=(e,n)=>(!e.id&&e.tag&&(e.id=e.tag),!e.tag&&e.id&&(e.tag=e.id),e.id||(e.id=`${e.tagName??"element"}${Math.floor(Math.random()*1e15)}`),typeof e.parentNode=="string"&&document.getElementById(e.parentNode)&&(e.parentNode=document.getElementById(e.parentNode)),e.parentNode||(this.parentNode||(this.parentNode=document.body),e.parentNode=this.parentNode),n.id=e.id,e.style&&Object.assign(n.style,e.style),e.innerHTML&&n.innerHTML!==e.innerHTML&&(n.innerHTML=e.innerHTML),e.innerText&&n.innerText!==e.innerText&&(n.innerText=e.innerText),e.attributes&&Object.assign(n,e.attributes),e);this.addComponent=(e,n=!0)=>{if(e.oncreate){let y=e.oncreate;e.oncreate=v=>{y(v,e)}}if(e.onresize){let y=e.onresize;e.onresize=v=>{y(v,e)}}if(e.ondelete){let y=e.ondelete;e.ondelete=v=>{y(v,e)}}if(typeof e.renderonchanged=="function"){let y=e.renderonchanged;e.renderonchanged=v=>{y(v,e)}}class s extends Ze{constructor(){super(...arguments);this.props=e.props;this.styles=e.styles;this.template=e.template;this.oncreate=e.oncreate;this.onresize=e.onresize;this.ondelete=e.ondelete;this.renderonchanged=e.renderonchanged}}delete e.oncreate,e.tagName||(e.tagName=`custom-element${Math.random()*1e15}`),s.addElement(e.tagName);let i=document.createElement(e.tagName),c=this.updateOptions(e,i);this.templates[c.id]=c;let d=Array.from(i.querySelectorAll("*"));n&&(d=d.map(y=>this.addElement({element:y}))),e.element||(e.element=i),e.operator||(e.operator=(y,v,m)=>{if(typeof m=="object")for(let l in m)y.element&&(typeof y.element[l]=="function"&&typeof m[l]!="function"?Array.isArray(m[l])?y.element[l](...m[l]):y.element[l](m[l]):l==="style"?Object.assign(y.element[l],m[l]):y.element[l]=m[l]);return m});let p=new Q(e,void 0,this);return i.node=p,this.components[c.id]={element:i,class:s,node:p,divs:d,...c},i.parentNode||setTimeout(()=>{typeof e.parentNode=="string"&&(e.parentNode=document.getElementById(e.parentNode)),typeof e.parentNode=="object"&&e.parentNode.appendChild(i)},.01),this.components[c.id]};this.addCanvasComponent=e=>{if(e.canvas?e.template=e.canvas:(e.template="<canvas ",e.width&&(e.template+=`width="${e.width}"`),e.height&&(e.template+=`height="${e.height}"`),e.template+=" ></canvas>"),e.oncreate){let v=e.oncreate;e.oncreate=m=>{v(m,e)}}if(e.onresize){let v=e.onresize;e.onresize=m=>{v(m,e)}}if(e.ondelete){let v=e.ondelete;e.ondelete=m=>{v(m,e)}}if(typeof e.renderonchanged=="function"){let v=e.renderonchanged;e.renderonchanged=m=>{v(m,e)}}class n extends Ze{constructor(){super(...arguments);this.props=e.props;this.styles=e.styles;this.template=e.template;this.oncreate=e.oncreate;this.onresize=e.onresize;this.ondelete=e.ondelete;this.renderonchanged=e.renderonchanged}}delete e.oncreate,e.tagName||(e.tagName=`custom-element${Math.random()*1e15}`),n.addElement(e.tagName);let s=document.createElement(e.tagName),i=this.updateOptions(e,s),c=()=>{this.components[i.id]?.animating&&(this.components[i.id].draw(this.components[i.id].element,this.components[i.id]),requestAnimationFrame(c))};this.templates[i.id]=i,e.element||(e.element=s),e.operator||(e.operator=(v,m,l)=>{if(typeof l=="object")for(let h in l)v.element&&(typeof v.element[h]=="function"&&typeof l[h]!="function"?Array.isArray(l[h])?v.element[h](...l[h]):v.element[h](l[h]):h==="style"?Object.assign(v.element[h],l[h]):v.element[h]=l[h]);return l});let d=new Q(e,void 0,this);s.node=d;let p=s.querySelector("canvas");i.style&&Object.assign(p.style,i.style);let y;return typeof i.context=="object"?y=e.context:typeof i.context=="string"&&(y=p.getContext(i.context)),this.components[i.id]={element:s,class:n,template:i.template,canvas:p,node:d,...i},this.components[i.id].context=y,s.canvas=p,s.context=y,d.canvas=p,d.context=y,s.parentNode||setTimeout(()=>{typeof e.parentNode=="string"&&(e.parentNode=document.getElementById(e.parentNode)),typeof e.parentNode=="object"&&e.parentNode.appendChild(s)},.01),d.runAnimation(c),this.components[i.id]};this.terminate=e=>{if(typeof e=="object")e.animating&&(e.animating=!1),e.element&&(e=e.element);else if(typeof e=="string"&&this.components[e]){this.components[e].node.isAnimating&&this.components[e].node.stopNode(),this.components[e].divs&&this.components[e].divs.forEach(s=>this.terminate(s));let n=this.components[e].element;delete this.components[e],e=n}else if(typeof e=="string"&&this.elements[e]){this.elements[e].divs&&this.elements[e].divs.forEach(s=>this.terminate(s));let n=this.elements[e].element;this.elements[e].onresize&&window.removeEventListener("resize",this.elements[e].onresize),this.elements[e].ondelete&&this.elements[e].ondelete(n,this.elements[e]),delete this.elements[e],e=n}return e?(this.nodes.get(e.id)&&this.removeTree(e.id),e instanceof Ze?e.delete():e?.parentNode&&e.parentNode.removeChild(e),!0):!1};this.defaultRoutes={addElement:this.addElement,addComponent:this.addComponent,addCanvasComponent:this.addCanvasComponent,terminate:this.terminate};n instanceof HTMLElement?this.parentNode=n:e.parentNode instanceof HTMLElement&&(this.parentNode=n),this.init(e)}};var Ir=zt(On());var Rr=Object.create,Vn=Object.defineProperty,Nr=Object.getOwnPropertyDescriptor,Lr=Object.getOwnPropertyNames,Mr=Object.getPrototypeOf,$r=Object.prototype.hasOwnProperty,It=(u=>typeof Ge<"u"?Ge:typeof Proxy<"u"?new Proxy(u,{get:(t,e)=>(typeof Ge<"u"?Ge:t)[e]}):u)(function(u){if(typeof Ge<"u")return Ge.apply(this,arguments);throw new Error('Dynamic require of "'+u+'" is not supported')}),Or=(u,t)=>()=>(t||u((t={exports:{}}).exports,t),t.exports),Vr=(u,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Lr(t))!$r.call(u,s)&&s!==e&&Vn(u,s,{get:()=>t[s],enumerable:!(n=Nr(t,s))||n.enumerable});return u},Pr=(u,t,e)=>(e=u!=null?Rr(Mr(u)):{},Vr(t||!u||!u.__esModule?Vn(e,"default",{value:u,enumerable:!0}):e,u)),Br=Or((u,t)=>{(function(e){if(typeof u=="object"&&typeof t<"u")t.exports=e();else if(typeof define=="function"&&define.amd)define([],e);else{var n;typeof window<"u"?n=window:typeof global<"u"?n=global:typeof self<"u"?n=self:n=this,e()}})(function(){var e,n,s;return function(){function i(c,d,p){function y(l,h){if(!d[l]){if(!c[l]){var a=typeof It=="function"&&It;if(!h&&a)return a(l,!0);if(v)return v(l,!0);var o=new Error("Cannot find module '"+l+"'");throw o.code="MODULE_NOT_FOUND",o}var b=d[l]={exports:{}};c[l][0].call(b.exports,function(w){var I=c[l][1][w];return y(I||w)},b,b.exports,i,c,d,p)}return d[l].exports}for(var v=typeof It=="function"&&It,m=0;m<p.length;m++)y(p[m]);return y}return i}()({1:[function(i,c,d){(function(p,y){typeof d=="object"&&typeof c<"u"?y(d):typeof e=="function"&&e.amd?e(["exports"],y):(p=p||self,y(p.acorn={}))})(this,function(p){"use strict";var y={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},v="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",m={5:v,"5module":v+" export import",6:v+" const class extends export import super"},l=/^in(stanceof)?$/,h="\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",a="\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F",o=new RegExp("["+h+"]"),b=new RegExp("["+h+a+"]");h=a=null;var w=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541],I=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];function S(r,g){for(var E=65536,F=0;F<g.length;F+=2){if(E+=g[F],E>r)return!1;if(E+=g[F+1],E>=r)return!0}}function D(r,g){return r<65?r===36:r<91?!0:r<97?r===95:r<123?!0:r<=65535?r>=170&&o.test(String.fromCharCode(r)):g===!1?!1:S(r,w)}function C(r,g){return r<48?r===36:r<58?!0:r<65?!1:r<91?!0:r<97?r===95:r<123?!0:r<=65535?r>=170&&b.test(String.fromCharCode(r)):g===!1?!1:S(r,w)||S(r,I)}var T=function(r,g){g===void 0&&(g={}),this.label=r,this.keyword=g.keyword,this.beforeExpr=!!g.beforeExpr,this.startsExpr=!!g.startsExpr,this.isLoop=!!g.isLoop,this.isAssign=!!g.isAssign,this.prefix=!!g.prefix,this.postfix=!!g.postfix,this.binop=g.binop||null,this.updateContext=null};function _(r,g){return new T(r,{beforeExpr:!0,binop:g})}var k={beforeExpr:!0},M={startsExpr:!0},P={};function A(r,g){return g===void 0&&(g={}),g.keyword=r,P[r]=new T(r,g)}var f={num:new T("num",M),regexp:new T("regexp",M),string:new T("string",M),name:new T("name",M),eof:new T("eof"),bracketL:new T("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new T("]"),braceL:new T("{",{beforeExpr:!0,startsExpr:!0}),braceR:new T("}"),parenL:new T("(",{beforeExpr:!0,startsExpr:!0}),parenR:new T(")"),comma:new T(",",k),semi:new T(";",k),colon:new T(":",k),dot:new T("."),question:new T("?",k),arrow:new T("=>",k),template:new T("template"),invalidTemplate:new T("invalidTemplate"),ellipsis:new T("...",k),backQuote:new T("`",M),dollarBraceL:new T("${",{beforeExpr:!0,startsExpr:!0}),eq:new T("=",{beforeExpr:!0,isAssign:!0}),assign:new T("_=",{beforeExpr:!0,isAssign:!0}),incDec:new T("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new T("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:_("||",1),logicalAND:_("&&",2),bitwiseOR:_("|",3),bitwiseXOR:_("^",4),bitwiseAND:_("&",5),equality:_("==/!=/===/!==",6),relational:_("</>/<=/>=",7),bitShift:_("<</>>/>>>",8),plusMin:new T("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:_("%",10),star:_("*",10),slash:_("/",10),starstar:new T("**",{beforeExpr:!0}),_break:A("break"),_case:A("case",k),_catch:A("catch"),_continue:A("continue"),_debugger:A("debugger"),_default:A("default",k),_do:A("do",{isLoop:!0,beforeExpr:!0}),_else:A("else",k),_finally:A("finally"),_for:A("for",{isLoop:!0}),_function:A("function",M),_if:A("if"),_return:A("return",k),_switch:A("switch"),_throw:A("throw",k),_try:A("try"),_var:A("var"),_const:A("const"),_while:A("while",{isLoop:!0}),_with:A("with"),_new:A("new",{beforeExpr:!0,startsExpr:!0}),_this:A("this",M),_super:A("super",M),_class:A("class",M),_extends:A("extends",k),_export:A("export"),_import:A("import",M),_null:A("null",M),_true:A("true",M),_false:A("false",M),_in:A("in",{beforeExpr:!0,binop:7}),_instanceof:A("instanceof",{beforeExpr:!0,binop:7}),_typeof:A("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:A("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:A("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},R=/\r\n?|\n|\u2028|\u2029/,N=new RegExp(R.source,"g");function K(r,g){return r===10||r===13||!g&&(r===8232||r===8233)}var O=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,V=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,j=Object.prototype,z=j.hasOwnProperty,q=j.toString;function H(r,g){return z.call(r,g)}var U=Array.isArray||function(r){return q.call(r)==="[object Array]"};function J(r){return new RegExp("^(?:"+r.replace(/ /g,"|")+")$")}var ee=function(r,g){this.line=r,this.column=g};ee.prototype.offset=function(r){return new ee(this.line,this.column+r)};var Z=function(r,g,E){this.start=g,this.end=E,r.sourceFile!==null&&(this.source=r.sourceFile)};function Y(r,g){for(var E=1,F=0;;){N.lastIndex=F;var L=N.exec(r);if(L&&L.index<g)++E,F=L.index+L[0].length;else return new ee(E,g-F)}}var X={ecmaVersion:10,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:!1,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1};function ge(r){var g={};for(var E in X)g[E]=r&&H(r,E)?r[E]:X[E];if(g.ecmaVersion>=2015&&(g.ecmaVersion-=2009),g.allowReserved==null&&(g.allowReserved=g.ecmaVersion<5),U(g.onToken)){var F=g.onToken;g.onToken=function(L){return F.push(L)}}return U(g.onComment)&&(g.onComment=re(g,g.onComment)),g}function re(r,g){return function(E,F,L,B,G,W){var ne={type:E?"Block":"Line",value:F,start:L,end:B};r.locations&&(ne.loc=new Z(this,G,W)),r.ranges&&(ne.range=[L,B]),g.push(ne)}}var se=1,Ce=2,ie=se|Ce,me=4,ve=8,be=16,ae=32,de=64,Te=128;function Fe(r,g){return Ce|(r?me:0)|(g?ve:0)}var $e=0,qe=1,Oe=2,en=3,tn=4,nn=5,ye=function(r,g,E){this.options=r=ge(r),this.sourceFile=r.sourceFile,this.keywords=J(m[r.ecmaVersion>=6?6:r.sourceType==="module"?"5module":5]);var F="";if(r.allowReserved!==!0){for(var L=r.ecmaVersion;!(F=y[L]);L--);r.sourceType==="module"&&(F+=" await")}this.reservedWords=J(F);var B=(F?F+" ":"")+y.strict;this.reservedWordsStrict=J(B),this.reservedWordsStrictBind=J(B+" "+y.strictBind),this.input=String(g),this.containsEsc=!1,E?(this.pos=E,this.lineStart=this.input.lastIndexOf(`
`,E-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(R).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=f.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule=r.sourceType==="module",this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports={},this.pos===0&&r.allowHashBang&&this.input.slice(0,2)==="#!"&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(se),this.regexpState=null},je={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0}};ye.prototype.parse=function(){var r=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(r)},je.inFunction.get=function(){return(this.currentVarScope().flags&Ce)>0},je.inGenerator.get=function(){return(this.currentVarScope().flags&ve)>0},je.inAsync.get=function(){return(this.currentVarScope().flags&me)>0},je.allowSuper.get=function(){return(this.currentThisScope().flags&de)>0},je.allowDirectSuper.get=function(){return(this.currentThisScope().flags&Te)>0},je.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},ye.prototype.inNonArrowFunction=function(){return(this.currentThisScope().flags&Ce)>0},ye.extend=function(){for(var r=[],g=arguments.length;g--;)r[g]=arguments[g];for(var E=this,F=0;F<r.length;F++)E=r[F](E);return E},ye.parse=function(r,g){return new this(g,r).parse()},ye.parseExpressionAt=function(r,g,E){var F=new this(E,r,g);return F.nextToken(),F.parseExpression()},ye.tokenizer=function(r,g){return new this(g,r)},Object.defineProperties(ye.prototype,je);var ke=ye.prototype,Kn=/^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;ke.strictDirective=function(r){for(;;){V.lastIndex=r,r+=V.exec(this.input)[0].length;var g=Kn.exec(this.input.slice(r));if(!g)return!1;if((g[1]||g[2])==="use strict")return!0;r+=g[0].length,V.lastIndex=r,r+=V.exec(this.input)[0].length,this.input[r]===";"&&r++}},ke.eat=function(r){return this.type===r?(this.next(),!0):!1},ke.isContextual=function(r){return this.type===f.name&&this.value===r&&!this.containsEsc},ke.eatContextual=function(r){return this.isContextual(r)?(this.next(),!0):!1},ke.expectContextual=function(r){this.eatContextual(r)||this.unexpected()},ke.canInsertSemicolon=function(){return this.type===f.eof||this.type===f.braceR||R.test(this.input.slice(this.lastTokEnd,this.start))},ke.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},ke.semicolon=function(){!this.eat(f.semi)&&!this.insertSemicolon()&&this.unexpected()},ke.afterTrailingComma=function(r,g){if(this.type===r)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),g||this.next(),!0},ke.expect=function(r){this.eat(r)||this.unexpected()},ke.unexpected=function(r){this.raise(r??this.start,"Unexpected token")};function ut(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1}ke.checkPatternErrors=function(r,g){if(r){r.trailingComma>-1&&this.raiseRecoverable(r.trailingComma,"Comma is not permitted after the rest element");var E=g?r.parenthesizedAssign:r.parenthesizedBind;E>-1&&this.raiseRecoverable(E,"Parenthesized pattern")}},ke.checkExpressionErrors=function(r,g){if(!r)return!1;var E=r.shorthandAssign,F=r.doubleProto;if(!g)return E>=0||F>=0;E>=0&&this.raise(E,"Shorthand property assignments are valid only in destructuring patterns"),F>=0&&this.raiseRecoverable(F,"Redefinition of __proto__ property")},ke.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},ke.isSimpleAssignTarget=function(r){return r.type==="ParenthesizedExpression"?this.isSimpleAssignTarget(r.expression):r.type==="Identifier"||r.type==="MemberExpression"};var oe=ye.prototype;oe.parseTopLevel=function(r){var g={};for(r.body||(r.body=[]);this.type!==f.eof;){var E=this.parseStatement(null,!0,g);r.body.push(E)}if(this.inModule)for(var F=0,L=Object.keys(this.undefinedExports);F<L.length;F+=1){var B=L[F];this.raiseRecoverable(this.undefinedExports[B].start,"Export '"+B+"' is not defined")}return this.adaptDirectivePrologue(r.body),this.next(),r.sourceType=this.options.sourceType,this.finishNode(r,"Program")};var $t={kind:"loop"},Un={kind:"switch"};oe.isLet=function(r){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;V.lastIndex=this.pos;var g=V.exec(this.input),E=this.pos+g[0].length,F=this.input.charCodeAt(E);if(F===91)return!0;if(r)return!1;if(F===123)return!0;if(D(F,!0)){for(var L=E+1;C(this.input.charCodeAt(L),!0);)++L;var B=this.input.slice(E,L);if(!l.test(B))return!0}return!1},oe.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;V.lastIndex=this.pos;var r=V.exec(this.input),g=this.pos+r[0].length;return!R.test(this.input.slice(this.pos,g))&&this.input.slice(g,g+8)==="function"&&(g+8===this.input.length||!C(this.input.charAt(g+8)))},oe.parseStatement=function(r,g,E){var F=this.type,L=this.startNode(),B;switch(this.isLet(r)&&(F=f._var,B="let"),F){case f._break:case f._continue:return this.parseBreakContinueStatement(L,F.keyword);case f._debugger:return this.parseDebuggerStatement(L);case f._do:return this.parseDoStatement(L);case f._for:return this.parseForStatement(L);case f._function:return r&&(this.strict||r!=="if"&&r!=="label")&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(L,!1,!r);case f._class:return r&&this.unexpected(),this.parseClass(L,!0);case f._if:return this.parseIfStatement(L);case f._return:return this.parseReturnStatement(L);case f._switch:return this.parseSwitchStatement(L);case f._throw:return this.parseThrowStatement(L);case f._try:return this.parseTryStatement(L);case f._const:case f._var:return B=B||this.value,r&&B!=="var"&&this.unexpected(),this.parseVarStatement(L,B);case f._while:return this.parseWhileStatement(L);case f._with:return this.parseWithStatement(L);case f.braceL:return this.parseBlock(!0,L);case f.semi:return this.parseEmptyStatement(L);case f._export:case f._import:if(this.options.ecmaVersion>10&&F===f._import){V.lastIndex=this.pos;var G=V.exec(this.input),W=this.pos+G[0].length,ne=this.input.charCodeAt(W);if(ne===40)return this.parseExpressionStatement(L,this.parseExpression())}return this.options.allowImportExportEverywhere||(g||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),F===f._import?this.parseImport(L):this.parseExport(L,E);default:if(this.isAsyncFunction())return r&&this.unexpected(),this.next(),this.parseFunctionStatement(L,!0,!r);var fe=this.value,De=this.parseExpression();return F===f.name&&De.type==="Identifier"&&this.eat(f.colon)?this.parseLabeledStatement(L,fe,De,r):this.parseExpressionStatement(L,De)}},oe.parseBreakContinueStatement=function(r,g){var E=g==="break";this.next(),this.eat(f.semi)||this.insertSemicolon()?r.label=null:this.type!==f.name?this.unexpected():(r.label=this.parseIdent(),this.semicolon());for(var F=0;F<this.labels.length;++F){var L=this.labels[F];if((r.label==null||L.name===r.label.name)&&(L.kind!=null&&(E||L.kind==="loop")||r.label&&E))break}return F===this.labels.length&&this.raise(r.start,"Unsyntactic "+g),this.finishNode(r,E?"BreakStatement":"ContinueStatement")},oe.parseDebuggerStatement=function(r){return this.next(),this.semicolon(),this.finishNode(r,"DebuggerStatement")},oe.parseDoStatement=function(r){return this.next(),this.labels.push($t),r.body=this.parseStatement("do"),this.labels.pop(),this.expect(f._while),r.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(f.semi):this.semicolon(),this.finishNode(r,"DoWhileStatement")},oe.parseForStatement=function(r){this.next();var g=this.options.ecmaVersion>=9&&(this.inAsync||!this.inFunction&&this.options.allowAwaitOutsideFunction)&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push($t),this.enterScope(0),this.expect(f.parenL),this.type===f.semi)return g>-1&&this.unexpected(g),this.parseFor(r,null);var E=this.isLet();if(this.type===f._var||this.type===f._const||E){var F=this.startNode(),L=E?"let":this.value;return this.next(),this.parseVar(F,!0,L),this.finishNode(F,"VariableDeclaration"),(this.type===f._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&F.declarations.length===1?(this.options.ecmaVersion>=9&&(this.type===f._in?g>-1&&this.unexpected(g):r.await=g>-1),this.parseForIn(r,F)):(g>-1&&this.unexpected(g),this.parseFor(r,F))}var B=new ut,G=this.parseExpression(!0,B);return this.type===f._in||this.options.ecmaVersion>=6&&this.isContextual("of")?(this.options.ecmaVersion>=9&&(this.type===f._in?g>-1&&this.unexpected(g):r.await=g>-1),this.toAssignable(G,!1,B),this.checkLVal(G),this.parseForIn(r,G)):(this.checkExpressionErrors(B,!0),g>-1&&this.unexpected(g),this.parseFor(r,G))},oe.parseFunctionStatement=function(r,g,E){return this.next(),this.parseFunction(r,tt|(E?0:Ot),!1,g)},oe.parseIfStatement=function(r){return this.next(),r.test=this.parseParenExpression(),r.consequent=this.parseStatement("if"),r.alternate=this.eat(f._else)?this.parseStatement("if"):null,this.finishNode(r,"IfStatement")},oe.parseReturnStatement=function(r){return!this.inFunction&&!this.options.allowReturnOutsideFunction&&this.raise(this.start,"'return' outside of function"),this.next(),this.eat(f.semi)||this.insertSemicolon()?r.argument=null:(r.argument=this.parseExpression(),this.semicolon()),this.finishNode(r,"ReturnStatement")},oe.parseSwitchStatement=function(r){this.next(),r.discriminant=this.parseParenExpression(),r.cases=[],this.expect(f.braceL),this.labels.push(Un),this.enterScope(0);for(var g,E=!1;this.type!==f.braceR;)if(this.type===f._case||this.type===f._default){var F=this.type===f._case;g&&this.finishNode(g,"SwitchCase"),r.cases.push(g=this.startNode()),g.consequent=[],this.next(),F?g.test=this.parseExpression():(E&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),E=!0,g.test=null),this.expect(f.colon)}else g||this.unexpected(),g.consequent.push(this.parseStatement(null));return this.exitScope(),g&&this.finishNode(g,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(r,"SwitchStatement")},oe.parseThrowStatement=function(r){return this.next(),R.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),r.argument=this.parseExpression(),this.semicolon(),this.finishNode(r,"ThrowStatement")};var jn=[];oe.parseTryStatement=function(r){if(this.next(),r.block=this.parseBlock(),r.handler=null,this.type===f._catch){var g=this.startNode();if(this.next(),this.eat(f.parenL)){g.param=this.parseBindingAtom();var E=g.param.type==="Identifier";this.enterScope(E?ae:0),this.checkLVal(g.param,E?tn:Oe),this.expect(f.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),g.param=null,this.enterScope(0);g.body=this.parseBlock(!1),this.exitScope(),r.handler=this.finishNode(g,"CatchClause")}return r.finalizer=this.eat(f._finally)?this.parseBlock():null,!r.handler&&!r.finalizer&&this.raise(r.start,"Missing catch or finally clause"),this.finishNode(r,"TryStatement")},oe.parseVarStatement=function(r,g){return this.next(),this.parseVar(r,!1,g),this.semicolon(),this.finishNode(r,"VariableDeclaration")},oe.parseWhileStatement=function(r){return this.next(),r.test=this.parseParenExpression(),this.labels.push($t),r.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(r,"WhileStatement")},oe.parseWithStatement=function(r){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),r.object=this.parseParenExpression(),r.body=this.parseStatement("with"),this.finishNode(r,"WithStatement")},oe.parseEmptyStatement=function(r){return this.next(),this.finishNode(r,"EmptyStatement")},oe.parseLabeledStatement=function(r,g,E,F){for(var L=0,B=this.labels;L<B.length;L+=1){var G=B[L];G.name===g&&this.raise(E.start,"Label '"+g+"' is already declared")}for(var W=this.type.isLoop?"loop":this.type===f._switch?"switch":null,ne=this.labels.length-1;ne>=0;ne--){var fe=this.labels[ne];if(fe.statementStart===r.start)fe.statementStart=this.start,fe.kind=W;else break}return this.labels.push({name:g,kind:W,statementStart:this.start}),r.body=this.parseStatement(F?F.indexOf("label")===-1?F+"label":F:"label"),this.labels.pop(),r.label=E,this.finishNode(r,"LabeledStatement")},oe.parseExpressionStatement=function(r,g){return r.expression=g,this.semicolon(),this.finishNode(r,"ExpressionStatement")},oe.parseBlock=function(r,g){for(r===void 0&&(r=!0),g===void 0&&(g=this.startNode()),g.body=[],this.expect(f.braceL),r&&this.enterScope(0);!this.eat(f.braceR);){var E=this.parseStatement(null);g.body.push(E)}return r&&this.exitScope(),this.finishNode(g,"BlockStatement")},oe.parseFor=function(r,g){return r.init=g,this.expect(f.semi),r.test=this.type===f.semi?null:this.parseExpression(),this.expect(f.semi),r.update=this.type===f.parenR?null:this.parseExpression(),this.expect(f.parenR),r.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(r,"ForStatement")},oe.parseForIn=function(r,g){var E=this.type===f._in;return this.next(),g.type==="VariableDeclaration"&&g.declarations[0].init!=null&&(!E||this.options.ecmaVersion<8||this.strict||g.kind!=="var"||g.declarations[0].id.type!=="Identifier")?this.raise(g.start,(E?"for-in":"for-of")+" loop variable declaration may not have an initializer"):g.type==="AssignmentPattern"&&this.raise(g.start,"Invalid left-hand side in for-loop"),r.left=g,r.right=E?this.parseExpression():this.parseMaybeAssign(),this.expect(f.parenR),r.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(r,E?"ForInStatement":"ForOfStatement")},oe.parseVar=function(r,g,E){for(r.declarations=[],r.kind=E;;){var F=this.startNode();if(this.parseVarId(F,E),this.eat(f.eq)?F.init=this.parseMaybeAssign(g):E==="const"&&!(this.type===f._in||this.options.ecmaVersion>=6&&this.isContextual("of"))?this.unexpected():F.id.type!=="Identifier"&&!(g&&(this.type===f._in||this.isContextual("of")))?this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):F.init=null,r.declarations.push(this.finishNode(F,"VariableDeclarator")),!this.eat(f.comma))break}return r},oe.parseVarId=function(r,g){r.id=this.parseBindingAtom(),this.checkLVal(r.id,g==="var"?qe:Oe,!1)};var tt=1,Ot=2,rn=4;oe.parseFunction=function(r,g,E,F){this.initFunction(r),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!F)&&(this.type===f.star&&g&Ot&&this.unexpected(),r.generator=this.eat(f.star)),this.options.ecmaVersion>=8&&(r.async=!!F),g&tt&&(r.id=g&rn&&this.type!==f.name?null:this.parseIdent(),r.id&&!(g&Ot)&&this.checkLVal(r.id,this.strict||r.generator||r.async?this.treatFunctionsAsVar?qe:Oe:en));var L=this.yieldPos,B=this.awaitPos,G=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(Fe(r.async,r.generator)),g&tt||(r.id=this.type===f.name?this.parseIdent():null),this.parseFunctionParams(r),this.parseFunctionBody(r,E,!1),this.yieldPos=L,this.awaitPos=B,this.awaitIdentPos=G,this.finishNode(r,g&tt?"FunctionDeclaration":"FunctionExpression")},oe.parseFunctionParams=function(r){this.expect(f.parenL),r.params=this.parseBindingList(f.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},oe.parseClass=function(r,g){this.next();var E=this.strict;this.strict=!0,this.parseClassId(r,g),this.parseClassSuper(r);var F=this.startNode(),L=!1;for(F.body=[],this.expect(f.braceL);!this.eat(f.braceR);){var B=this.parseClassElement(r.superClass!==null);B&&(F.body.push(B),B.type==="MethodDefinition"&&B.kind==="constructor"&&(L&&this.raise(B.start,"Duplicate constructor in the same class"),L=!0))}return r.body=this.finishNode(F,"ClassBody"),this.strict=E,this.finishNode(r,g?"ClassDeclaration":"ClassExpression")},oe.parseClassElement=function(r){var g=this;if(this.eat(f.semi))return null;var E=this.startNode(),F=function(ne,fe){fe===void 0&&(fe=!1);var De=g.start,Be=g.startLoc;return g.eatContextual(ne)?g.type!==f.parenL&&(!fe||!g.canInsertSemicolon())?!0:(E.key&&g.unexpected(),E.computed=!1,E.key=g.startNodeAt(De,Be),E.key.name=ne,g.finishNode(E.key,"Identifier"),!1):!1};E.kind="method",E.static=F("static");var L=this.eat(f.star),B=!1;L||(this.options.ecmaVersion>=8&&F("async",!0)?(B=!0,L=this.options.ecmaVersion>=9&&this.eat(f.star)):F("get")?E.kind="get":F("set")&&(E.kind="set")),E.key||this.parsePropertyName(E);var G=E.key,W=!1;return!E.computed&&!E.static&&(G.type==="Identifier"&&G.name==="constructor"||G.type==="Literal"&&G.value==="constructor")?(E.kind!=="method"&&this.raise(G.start,"Constructor can't have get/set modifier"),L&&this.raise(G.start,"Constructor can't be a generator"),B&&this.raise(G.start,"Constructor can't be an async method"),E.kind="constructor",W=r):E.static&&G.type==="Identifier"&&G.name==="prototype"&&this.raise(G.start,"Classes may not have a static property named prototype"),this.parseClassMethod(E,L,B,W),E.kind==="get"&&E.value.params.length!==0&&this.raiseRecoverable(E.value.start,"getter should have no params"),E.kind==="set"&&E.value.params.length!==1&&this.raiseRecoverable(E.value.start,"setter should have exactly one param"),E.kind==="set"&&E.value.params[0].type==="RestElement"&&this.raiseRecoverable(E.value.params[0].start,"Setter cannot use rest params"),E},oe.parseClassMethod=function(r,g,E,F){return r.value=this.parseMethod(g,E,F),this.finishNode(r,"MethodDefinition")},oe.parseClassId=function(r,g){this.type===f.name?(r.id=this.parseIdent(),g&&this.checkLVal(r.id,Oe,!1)):(g===!0&&this.unexpected(),r.id=null)},oe.parseClassSuper=function(r){r.superClass=this.eat(f._extends)?this.parseExprSubscripts():null},oe.parseExport=function(r,g){if(this.next(),this.eat(f.star))return this.expectContextual("from"),this.type!==f.string&&this.unexpected(),r.source=this.parseExprAtom(),this.semicolon(),this.finishNode(r,"ExportAllDeclaration");if(this.eat(f._default)){this.checkExport(g,"default",this.lastTokStart);var E;if(this.type===f._function||(E=this.isAsyncFunction())){var F=this.startNode();this.next(),E&&this.next(),r.declaration=this.parseFunction(F,tt|rn,!1,E)}else if(this.type===f._class){var L=this.startNode();r.declaration=this.parseClass(L,"nullableID")}else r.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(r,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())r.declaration=this.parseStatement(null),r.declaration.type==="VariableDeclaration"?this.checkVariableExport(g,r.declaration.declarations):this.checkExport(g,r.declaration.id.name,r.declaration.id.start),r.specifiers=[],r.source=null;else{if(r.declaration=null,r.specifiers=this.parseExportSpecifiers(g),this.eatContextual("from"))this.type!==f.string&&this.unexpected(),r.source=this.parseExprAtom();else{for(var B=0,G=r.specifiers;B<G.length;B+=1){var W=G[B];this.checkUnreserved(W.local),this.checkLocalExport(W.local)}r.source=null}this.semicolon()}return this.finishNode(r,"ExportNamedDeclaration")},oe.checkExport=function(r,g,E){!r||(H(r,g)&&this.raiseRecoverable(E,"Duplicate export '"+g+"'"),r[g]=!0)},oe.checkPatternExport=function(r,g){var E=g.type;if(E==="Identifier")this.checkExport(r,g.name,g.start);else if(E==="ObjectPattern")for(var F=0,L=g.properties;F<L.length;F+=1){var B=L[F];this.checkPatternExport(r,B)}else if(E==="ArrayPattern")for(var G=0,W=g.elements;G<W.length;G+=1){var ne=W[G];ne&&this.checkPatternExport(r,ne)}else E==="Property"?this.checkPatternExport(r,g.value):E==="AssignmentPattern"?this.checkPatternExport(r,g.left):E==="RestElement"?this.checkPatternExport(r,g.argument):E==="ParenthesizedExpression"&&this.checkPatternExport(r,g.expression)},oe.checkVariableExport=function(r,g){if(r)for(var E=0,F=g;E<F.length;E+=1){var L=F[E];this.checkPatternExport(r,L.id)}},oe.shouldParseExportStatement=function(){return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()},oe.parseExportSpecifiers=function(r){var g=[],E=!0;for(this.expect(f.braceL);!this.eat(f.braceR);){if(E)E=!1;else if(this.expect(f.comma),this.afterTrailingComma(f.braceR))break;var F=this.startNode();F.local=this.parseIdent(!0),F.exported=this.eatContextual("as")?this.parseIdent(!0):F.local,this.checkExport(r,F.exported.name,F.exported.start),g.push(this.finishNode(F,"ExportSpecifier"))}return g},oe.parseImport=function(r){return this.next(),this.type===f.string?(r.specifiers=jn,r.source=this.parseExprAtom()):(r.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),r.source=this.type===f.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(r,"ImportDeclaration")},oe.parseImportSpecifiers=function(){var r=[],g=!0;if(this.type===f.name){var E=this.startNode();if(E.local=this.parseIdent(),this.checkLVal(E.local,Oe),r.push(this.finishNode(E,"ImportDefaultSpecifier")),!this.eat(f.comma))return r}if(this.type===f.star){var F=this.startNode();return this.next(),this.expectContextual("as"),F.local=this.parseIdent(),this.checkLVal(F.local,Oe),r.push(this.finishNode(F,"ImportNamespaceSpecifier")),r}for(this.expect(f.braceL);!this.eat(f.braceR);){if(g)g=!1;else if(this.expect(f.comma),this.afterTrailingComma(f.braceR))break;var L=this.startNode();L.imported=this.parseIdent(!0),this.eatContextual("as")?L.local=this.parseIdent():(this.checkUnreserved(L.imported),L.local=L.imported),this.checkLVal(L.local,Oe),r.push(this.finishNode(L,"ImportSpecifier"))}return r},oe.adaptDirectivePrologue=function(r){for(var g=0;g<r.length&&this.isDirectiveCandidate(r[g]);++g)r[g].directive=r[g].expression.raw.slice(1,-1)},oe.isDirectiveCandidate=function(r){return r.type==="ExpressionStatement"&&r.expression.type==="Literal"&&typeof r.expression.value=="string"&&(this.input[r.start]==='"'||this.input[r.start]==="'")};var Ve=ye.prototype;Ve.toAssignable=function(r,g,E){if(this.options.ecmaVersion>=6&&r)switch(r.type){case"Identifier":this.inAsync&&r.name==="await"&&this.raise(r.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"RestElement":break;case"ObjectExpression":r.type="ObjectPattern",E&&this.checkPatternErrors(E,!0);for(var F=0,L=r.properties;F<L.length;F+=1){var B=L[F];this.toAssignable(B,g),B.type==="RestElement"&&(B.argument.type==="ArrayPattern"||B.argument.type==="ObjectPattern")&&this.raise(B.argument.start,"Unexpected token")}break;case"Property":r.kind!=="init"&&this.raise(r.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(r.value,g);break;case"ArrayExpression":r.type="ArrayPattern",E&&this.checkPatternErrors(E,!0),this.toAssignableList(r.elements,g);break;case"SpreadElement":r.type="RestElement",this.toAssignable(r.argument,g),r.argument.type==="AssignmentPattern"&&this.raise(r.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":r.operator!=="="&&this.raise(r.left.end,"Only '=' operator can be used for specifying default value."),r.type="AssignmentPattern",delete r.operator,this.toAssignable(r.left,g);case"AssignmentPattern":break;case"ParenthesizedExpression":this.toAssignable(r.expression,g,E);break;case"MemberExpression":if(!g)break;default:this.raise(r.start,"Assigning to rvalue")}else E&&this.checkPatternErrors(E,!0);return r},Ve.toAssignableList=function(r,g){for(var E=r.length,F=0;F<E;F++){var L=r[F];L&&this.toAssignable(L,g)}if(E){var B=r[E-1];this.options.ecmaVersion===6&&g&&B&&B.type==="RestElement"&&B.argument.type!=="Identifier"&&this.unexpected(B.argument.start)}return r},Ve.parseSpread=function(r){var g=this.startNode();return this.next(),g.argument=this.parseMaybeAssign(!1,r),this.finishNode(g,"SpreadElement")},Ve.parseRestBinding=function(){var r=this.startNode();return this.next(),this.options.ecmaVersion===6&&this.type!==f.name&&this.unexpected(),r.argument=this.parseBindingAtom(),this.finishNode(r,"RestElement")},Ve.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case f.bracketL:var r=this.startNode();return this.next(),r.elements=this.parseBindingList(f.bracketR,!0,!0),this.finishNode(r,"ArrayPattern");case f.braceL:return this.parseObj(!0)}return this.parseIdent()},Ve.parseBindingList=function(r,g,E){for(var F=[],L=!0;!this.eat(r);)if(L?L=!1:this.expect(f.comma),g&&this.type===f.comma)F.push(null);else{if(E&&this.afterTrailingComma(r))break;if(this.type===f.ellipsis){var B=this.parseRestBinding();this.parseBindingListItem(B),F.push(B),this.type===f.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(r);break}else{var G=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(G),F.push(G)}}return F},Ve.parseBindingListItem=function(r){return r},Ve.parseMaybeDefault=function(r,g,E){if(E=E||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(f.eq))return E;var F=this.startNodeAt(r,g);return F.left=E,F.right=this.parseMaybeAssign(),this.finishNode(F,"AssignmentPattern")},Ve.checkLVal=function(r,g,E){switch(g===void 0&&(g=$e),r.type){case"Identifier":g===Oe&&r.name==="let"&&this.raiseRecoverable(r.start,"let is disallowed as a lexically bound name"),this.strict&&this.reservedWordsStrictBind.test(r.name)&&this.raiseRecoverable(r.start,(g?"Binding ":"Assigning to ")+r.name+" in strict mode"),E&&(H(E,r.name)&&this.raiseRecoverable(r.start,"Argument name clash"),E[r.name]=!0),g!==$e&&g!==nn&&this.declareName(r.name,g,r.start);break;case"MemberExpression":g&&this.raiseRecoverable(r.start,"Binding member expression");break;case"ObjectPattern":for(var F=0,L=r.properties;F<L.length;F+=1){var B=L[F];this.checkLVal(B,g,E)}break;case"Property":this.checkLVal(r.value,g,E);break;case"ArrayPattern":for(var G=0,W=r.elements;G<W.length;G+=1){var ne=W[G];ne&&this.checkLVal(ne,g,E)}break;case"AssignmentPattern":this.checkLVal(r.left,g,E);break;case"RestElement":this.checkLVal(r.argument,g,E);break;case"ParenthesizedExpression":this.checkLVal(r.expression,g,E);break;default:this.raise(r.start,(g?"Binding":"Assigning to")+" rvalue")}};var ue=ye.prototype;ue.checkPropClash=function(r,g,E){if(!(this.options.ecmaVersion>=9&&r.type==="SpreadElement")&&!(this.options.ecmaVersion>=6&&(r.computed||r.method||r.shorthand))){var F=r.key,L;switch(F.type){case"Identifier":L=F.name;break;case"Literal":L=String(F.value);break;default:return}var B=r.kind;if(this.options.ecmaVersion>=6){L==="__proto__"&&B==="init"&&(g.proto&&(E?E.doubleProto<0&&(E.doubleProto=F.start):this.raiseRecoverable(F.start,"Redefinition of __proto__ property")),g.proto=!0);return}L="$"+L;var G=g[L];if(G){var W;B==="init"?W=this.strict&&G.init||G.get||G.set:W=G.init||G[B],W&&this.raiseRecoverable(F.start,"Redefinition of property")}else G=g[L]={init:!1,get:!1,set:!1};G[B]=!0}},ue.parseExpression=function(r,g){var E=this.start,F=this.startLoc,L=this.parseMaybeAssign(r,g);if(this.type===f.comma){var B=this.startNodeAt(E,F);for(B.expressions=[L];this.eat(f.comma);)B.expressions.push(this.parseMaybeAssign(r,g));return this.finishNode(B,"SequenceExpression")}return L},ue.parseMaybeAssign=function(r,g,E){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(r);this.exprAllowed=!1}var F=!1,L=-1,B=-1;g?(L=g.parenthesizedAssign,B=g.trailingComma,g.parenthesizedAssign=g.trailingComma=-1):(g=new ut,F=!0);var G=this.start,W=this.startLoc;(this.type===f.parenL||this.type===f.name)&&(this.potentialArrowAt=this.start);var ne=this.parseMaybeConditional(r,g);if(E&&(ne=E.call(this,ne,G,W)),this.type.isAssign){var fe=this.startNodeAt(G,W);return fe.operator=this.value,fe.left=this.type===f.eq?this.toAssignable(ne,!1,g):ne,F||(g.parenthesizedAssign=g.trailingComma=g.doubleProto=-1),g.shorthandAssign>=fe.left.start&&(g.shorthandAssign=-1),this.checkLVal(ne),this.next(),fe.right=this.parseMaybeAssign(r),this.finishNode(fe,"AssignmentExpression")}else F&&this.checkExpressionErrors(g,!0);return L>-1&&(g.parenthesizedAssign=L),B>-1&&(g.trailingComma=B),ne},ue.parseMaybeConditional=function(r,g){var E=this.start,F=this.startLoc,L=this.parseExprOps(r,g);if(this.checkExpressionErrors(g))return L;if(this.eat(f.question)){var B=this.startNodeAt(E,F);return B.test=L,B.consequent=this.parseMaybeAssign(),this.expect(f.colon),B.alternate=this.parseMaybeAssign(r),this.finishNode(B,"ConditionalExpression")}return L},ue.parseExprOps=function(r,g){var E=this.start,F=this.startLoc,L=this.parseMaybeUnary(g,!1);return this.checkExpressionErrors(g)||L.start===E&&L.type==="ArrowFunctionExpression"?L:this.parseExprOp(L,E,F,-1,r)},ue.parseExprOp=function(r,g,E,F,L){var B=this.type.binop;if(B!=null&&(!L||this.type!==f._in)&&B>F){var G=this.type===f.logicalOR||this.type===f.logicalAND,W=this.value;this.next();var ne=this.start,fe=this.startLoc,De=this.parseExprOp(this.parseMaybeUnary(null,!1),ne,fe,B,L),Be=this.buildBinary(g,E,r,De,W,G);return this.parseExprOp(Be,g,E,F,L)}return r},ue.buildBinary=function(r,g,E,F,L,B){var G=this.startNodeAt(r,g);return G.left=E,G.operator=L,G.right=F,this.finishNode(G,B?"LogicalExpression":"BinaryExpression")},ue.parseMaybeUnary=function(r,g){var E=this.start,F=this.startLoc,L;if(this.isContextual("await")&&(this.inAsync||!this.inFunction&&this.options.allowAwaitOutsideFunction))L=this.parseAwait(),g=!0;else if(this.type.prefix){var B=this.startNode(),G=this.type===f.incDec;B.operator=this.value,B.prefix=!0,this.next(),B.argument=this.parseMaybeUnary(null,!0),this.checkExpressionErrors(r,!0),G?this.checkLVal(B.argument):this.strict&&B.operator==="delete"&&B.argument.type==="Identifier"?this.raiseRecoverable(B.start,"Deleting local variable in strict mode"):g=!0,L=this.finishNode(B,G?"UpdateExpression":"UnaryExpression")}else{if(L=this.parseExprSubscripts(r),this.checkExpressionErrors(r))return L;for(;this.type.postfix&&!this.canInsertSemicolon();){var W=this.startNodeAt(E,F);W.operator=this.value,W.prefix=!1,W.argument=L,this.checkLVal(L),this.next(),L=this.finishNode(W,"UpdateExpression")}}return!g&&this.eat(f.starstar)?this.buildBinary(E,F,L,this.parseMaybeUnary(null,!1),"**",!1):L},ue.parseExprSubscripts=function(r){var g=this.start,E=this.startLoc,F=this.parseExprAtom(r);if(F.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")")return F;var L=this.parseSubscripts(F,g,E);return r&&L.type==="MemberExpression"&&(r.parenthesizedAssign>=L.start&&(r.parenthesizedAssign=-1),r.parenthesizedBind>=L.start&&(r.parenthesizedBind=-1)),L},ue.parseSubscripts=function(r,g,E,F){for(var L=this.options.ecmaVersion>=8&&r.type==="Identifier"&&r.name==="async"&&this.lastTokEnd===r.end&&!this.canInsertSemicolon()&&this.input.slice(r.start,r.end)==="async";;){var B=this.parseSubscript(r,g,E,F,L);if(B===r||B.type==="ArrowFunctionExpression")return B;r=B}},ue.parseSubscript=function(r,g,E,F,L){var B=this.eat(f.bracketL);if(B||this.eat(f.dot)){var G=this.startNodeAt(g,E);G.object=r,G.property=B?this.parseExpression():this.parseIdent(this.options.allowReserved!=="never"),G.computed=!!B,B&&this.expect(f.bracketR),r=this.finishNode(G,"MemberExpression")}else if(!F&&this.eat(f.parenL)){var W=new ut,ne=this.yieldPos,fe=this.awaitPos,De=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var Be=this.parseExprList(f.parenR,this.options.ecmaVersion>=8,!1,W);if(L&&!this.canInsertSemicolon()&&this.eat(f.arrow))return this.checkPatternErrors(W,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=ne,this.awaitPos=fe,this.awaitIdentPos=De,this.parseArrowExpression(this.startNodeAt(g,E),Be,!0);this.checkExpressionErrors(W,!0),this.yieldPos=ne||this.yieldPos,this.awaitPos=fe||this.awaitPos,this.awaitIdentPos=De||this.awaitIdentPos;var Xe=this.startNodeAt(g,E);Xe.callee=r,Xe.arguments=Be,r=this.finishNode(Xe,"CallExpression")}else if(this.type===f.backQuote){var We=this.startNodeAt(g,E);We.tag=r,We.quasi=this.parseTemplate({isTagged:!0}),r=this.finishNode(We,"TaggedTemplateExpression")}return r},ue.parseExprAtom=function(r){this.type===f.slash&&this.readRegexp();var g,E=this.potentialArrowAt===this.start;switch(this.type){case f._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),g=this.startNode(),this.next(),this.type===f.parenL&&!this.allowDirectSuper&&this.raise(g.start,"super() call outside constructor of a subclass"),this.type!==f.dot&&this.type!==f.bracketL&&this.type!==f.parenL&&this.unexpected(),this.finishNode(g,"Super");case f._this:return g=this.startNode(),this.next(),this.finishNode(g,"ThisExpression");case f.name:var F=this.start,L=this.startLoc,B=this.containsEsc,G=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!B&&G.name==="async"&&!this.canInsertSemicolon()&&this.eat(f._function))return this.parseFunction(this.startNodeAt(F,L),0,!1,!0);if(E&&!this.canInsertSemicolon()){if(this.eat(f.arrow))return this.parseArrowExpression(this.startNodeAt(F,L),[G],!1);if(this.options.ecmaVersion>=8&&G.name==="async"&&this.type===f.name&&!B)return G=this.parseIdent(!1),(this.canInsertSemicolon()||!this.eat(f.arrow))&&this.unexpected(),this.parseArrowExpression(this.startNodeAt(F,L),[G],!0)}return G;case f.regexp:var W=this.value;return g=this.parseLiteral(W.value),g.regex={pattern:W.pattern,flags:W.flags},g;case f.num:case f.string:return this.parseLiteral(this.value);case f._null:case f._true:case f._false:return g=this.startNode(),g.value=this.type===f._null?null:this.type===f._true,g.raw=this.type.keyword,this.next(),this.finishNode(g,"Literal");case f.parenL:var ne=this.start,fe=this.parseParenAndDistinguishExpression(E);return r&&(r.parenthesizedAssign<0&&!this.isSimpleAssignTarget(fe)&&(r.parenthesizedAssign=ne),r.parenthesizedBind<0&&(r.parenthesizedBind=ne)),fe;case f.bracketL:return g=this.startNode(),this.next(),g.elements=this.parseExprList(f.bracketR,!0,!0,r),this.finishNode(g,"ArrayExpression");case f.braceL:return this.parseObj(!1,r);case f._function:return g=this.startNode(),this.next(),this.parseFunction(g,0);case f._class:return this.parseClass(this.startNode(),!1);case f._new:return this.parseNew();case f.backQuote:return this.parseTemplate();case f._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},ue.parseExprImport=function(){var r=this.startNode();switch(this.next(),this.type){case f.parenL:return this.parseDynamicImport(r);default:this.unexpected()}},ue.parseDynamicImport=function(r){if(this.next(),r.source=this.parseMaybeAssign(),!this.eat(f.parenR)){var g=this.start;this.eat(f.comma)&&this.eat(f.parenR)?this.raiseRecoverable(g,"Trailing comma is not allowed in import()"):this.unexpected(g)}return this.finishNode(r,"ImportExpression")},ue.parseLiteral=function(r){var g=this.startNode();return g.value=r,g.raw=this.input.slice(this.start,this.end),g.raw.charCodeAt(g.raw.length-1)===110&&(g.bigint=g.raw.slice(0,-1)),this.next(),this.finishNode(g,"Literal")},ue.parseParenExpression=function(){this.expect(f.parenL);var r=this.parseExpression();return this.expect(f.parenR),r},ue.parseParenAndDistinguishExpression=function(r){var g=this.start,E=this.startLoc,F,L=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var B=this.start,G=this.startLoc,W=[],ne=!0,fe=!1,De=new ut,Be=this.yieldPos,Xe=this.awaitPos,We;for(this.yieldPos=0,this.awaitPos=0;this.type!==f.parenR;)if(ne?ne=!1:this.expect(f.comma),L&&this.afterTrailingComma(f.parenR,!0)){fe=!0;break}else if(this.type===f.ellipsis){We=this.start,W.push(this.parseParenItem(this.parseRestBinding())),this.type===f.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}else W.push(this.parseMaybeAssign(!1,De,this.parseParenItem));var ar=this.start,or=this.startLoc;if(this.expect(f.parenR),r&&!this.canInsertSemicolon()&&this.eat(f.arrow))return this.checkPatternErrors(De,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=Be,this.awaitPos=Xe,this.parseParenArrowList(g,E,W);(!W.length||fe)&&this.unexpected(this.lastTokStart),We&&this.unexpected(We),this.checkExpressionErrors(De,!0),this.yieldPos=Be||this.yieldPos,this.awaitPos=Xe||this.awaitPos,W.length>1?(F=this.startNodeAt(B,G),F.expressions=W,this.finishNodeAt(F,"SequenceExpression",ar,or)):F=W[0]}else F=this.parseParenExpression();if(this.options.preserveParens){var vn=this.startNodeAt(g,E);return vn.expression=F,this.finishNode(vn,"ParenthesizedExpression")}else return F},ue.parseParenItem=function(r){return r},ue.parseParenArrowList=function(r,g,E){return this.parseArrowExpression(this.startNodeAt(r,g),E)};var Wn=[];ue.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var r=this.startNode(),g=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(f.dot)){r.meta=g;var E=this.containsEsc;return r.property=this.parseIdent(!0),(r.property.name!=="target"||E)&&this.raiseRecoverable(r.property.start,"The only valid meta property for new is new.target"),this.inNonArrowFunction()||this.raiseRecoverable(r.start,"new.target can only be used in functions"),this.finishNode(r,"MetaProperty")}var F=this.start,L=this.startLoc,B=this.type===f._import;return r.callee=this.parseSubscripts(this.parseExprAtom(),F,L,!0),B&&r.callee.type==="ImportExpression"&&this.raise(F,"Cannot use new with import()"),this.eat(f.parenL)?r.arguments=this.parseExprList(f.parenR,this.options.ecmaVersion>=8,!1):r.arguments=Wn,this.finishNode(r,"NewExpression")},ue.parseTemplateElement=function(r){var g=r.isTagged,E=this.startNode();return this.type===f.invalidTemplate?(g||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),E.value={raw:this.value,cooked:null}):E.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,`
`),cooked:this.value},this.next(),E.tail=this.type===f.backQuote,this.finishNode(E,"TemplateElement")},ue.parseTemplate=function(r){r===void 0&&(r={});var g=r.isTagged;g===void 0&&(g=!1);var E=this.startNode();this.next(),E.expressions=[];var F=this.parseTemplateElement({isTagged:g});for(E.quasis=[F];!F.tail;)this.type===f.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(f.dollarBraceL),E.expressions.push(this.parseExpression()),this.expect(f.braceR),E.quasis.push(F=this.parseTemplateElement({isTagged:g}));return this.next(),this.finishNode(E,"TemplateLiteral")},ue.isAsyncProp=function(r){return!r.computed&&r.key.type==="Identifier"&&r.key.name==="async"&&(this.type===f.name||this.type===f.num||this.type===f.string||this.type===f.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===f.star)&&!R.test(this.input.slice(this.lastTokEnd,this.start))},ue.parseObj=function(r,g){var E=this.startNode(),F=!0,L={};for(E.properties=[],this.next();!this.eat(f.braceR);){if(F)F=!1;else if(this.expect(f.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(f.braceR))break;var B=this.parseProperty(r,g);r||this.checkPropClash(B,L,g),E.properties.push(B)}return this.finishNode(E,r?"ObjectPattern":"ObjectExpression")},ue.parseProperty=function(r,g){var E=this.startNode(),F,L,B,G;if(this.options.ecmaVersion>=9&&this.eat(f.ellipsis))return r?(E.argument=this.parseIdent(!1),this.type===f.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(E,"RestElement")):(this.type===f.parenL&&g&&(g.parenthesizedAssign<0&&(g.parenthesizedAssign=this.start),g.parenthesizedBind<0&&(g.parenthesizedBind=this.start)),E.argument=this.parseMaybeAssign(!1,g),this.type===f.comma&&g&&g.trailingComma<0&&(g.trailingComma=this.start),this.finishNode(E,"SpreadElement"));this.options.ecmaVersion>=6&&(E.method=!1,E.shorthand=!1,(r||g)&&(B=this.start,G=this.startLoc),r||(F=this.eat(f.star)));var W=this.containsEsc;return this.parsePropertyName(E),!r&&!W&&this.options.ecmaVersion>=8&&!F&&this.isAsyncProp(E)?(L=!0,F=this.options.ecmaVersion>=9&&this.eat(f.star),this.parsePropertyName(E,g)):L=!1,this.parsePropertyValue(E,r,F,L,B,G,g,W),this.finishNode(E,"Property")},ue.parsePropertyValue=function(r,g,E,F,L,B,G,W){if((E||F)&&this.type===f.colon&&this.unexpected(),this.eat(f.colon))r.value=g?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,G),r.kind="init";else if(this.options.ecmaVersion>=6&&this.type===f.parenL)g&&this.unexpected(),r.kind="init",r.method=!0,r.value=this.parseMethod(E,F);else if(!g&&!W&&this.options.ecmaVersion>=5&&!r.computed&&r.key.type==="Identifier"&&(r.key.name==="get"||r.key.name==="set")&&this.type!==f.comma&&this.type!==f.braceR){(E||F)&&this.unexpected(),r.kind=r.key.name,this.parsePropertyName(r),r.value=this.parseMethod(!1);var ne=r.kind==="get"?0:1;if(r.value.params.length!==ne){var fe=r.value.start;r.kind==="get"?this.raiseRecoverable(fe,"getter should have no params"):this.raiseRecoverable(fe,"setter should have exactly one param")}else r.kind==="set"&&r.value.params[0].type==="RestElement"&&this.raiseRecoverable(r.value.params[0].start,"Setter cannot use rest params")}else this.options.ecmaVersion>=6&&!r.computed&&r.key.type==="Identifier"?((E||F)&&this.unexpected(),this.checkUnreserved(r.key),r.key.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=L),r.kind="init",g?r.value=this.parseMaybeDefault(L,B,r.key):this.type===f.eq&&G?(G.shorthandAssign<0&&(G.shorthandAssign=this.start),r.value=this.parseMaybeDefault(L,B,r.key)):r.value=r.key,r.shorthand=!0):this.unexpected()},ue.parsePropertyName=function(r){if(this.options.ecmaVersion>=6){if(this.eat(f.bracketL))return r.computed=!0,r.key=this.parseMaybeAssign(),this.expect(f.bracketR),r.key;r.computed=!1}return r.key=this.type===f.num||this.type===f.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never")},ue.initFunction=function(r){r.id=null,this.options.ecmaVersion>=6&&(r.generator=r.expression=!1),this.options.ecmaVersion>=8&&(r.async=!1)},ue.parseMethod=function(r,g,E){var F=this.startNode(),L=this.yieldPos,B=this.awaitPos,G=this.awaitIdentPos;return this.initFunction(F),this.options.ecmaVersion>=6&&(F.generator=r),this.options.ecmaVersion>=8&&(F.async=!!g),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(Fe(g,F.generator)|de|(E?Te:0)),this.expect(f.parenL),F.params=this.parseBindingList(f.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(F,!1,!0),this.yieldPos=L,this.awaitPos=B,this.awaitIdentPos=G,this.finishNode(F,"FunctionExpression")},ue.parseArrowExpression=function(r,g,E){var F=this.yieldPos,L=this.awaitPos,B=this.awaitIdentPos;return this.enterScope(Fe(E,!1)|be),this.initFunction(r),this.options.ecmaVersion>=8&&(r.async=!!E),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,r.params=this.toAssignableList(g,!0),this.parseFunctionBody(r,!0,!1),this.yieldPos=F,this.awaitPos=L,this.awaitIdentPos=B,this.finishNode(r,"ArrowFunctionExpression")},ue.parseFunctionBody=function(r,g,E){var F=g&&this.type!==f.braceL,L=this.strict,B=!1;if(F)r.body=this.parseMaybeAssign(),r.expression=!0,this.checkParams(r,!1);else{var G=this.options.ecmaVersion>=7&&!this.isSimpleParamList(r.params);(!L||G)&&(B=this.strictDirective(this.end),B&&G&&this.raiseRecoverable(r.start,"Illegal 'use strict' directive in function with non-simple parameter list"));var W=this.labels;this.labels=[],B&&(this.strict=!0),this.checkParams(r,!L&&!B&&!g&&!E&&this.isSimpleParamList(r.params)),r.body=this.parseBlock(!1),r.expression=!1,this.adaptDirectivePrologue(r.body.body),this.labels=W}this.exitScope(),this.strict&&r.id&&this.checkLVal(r.id,nn),this.strict=L},ue.isSimpleParamList=function(r){for(var g=0,E=r;g<E.length;g+=1){var F=E[g];if(F.type!=="Identifier")return!1}return!0},ue.checkParams=function(r,g){for(var E={},F=0,L=r.params;F<L.length;F+=1){var B=L[F];this.checkLVal(B,qe,g?null:E)}},ue.parseExprList=function(r,g,E,F){for(var L=[],B=!0;!this.eat(r);){if(B)B=!1;else if(this.expect(f.comma),g&&this.afterTrailingComma(r))break;var G=void 0;E&&this.type===f.comma?G=null:this.type===f.ellipsis?(G=this.parseSpread(F),F&&this.type===f.comma&&F.trailingComma<0&&(F.trailingComma=this.start)):G=this.parseMaybeAssign(!1,F),L.push(G)}return L},ue.checkUnreserved=function(r){var g=r.start,E=r.end,F=r.name;if(this.inGenerator&&F==="yield"&&this.raiseRecoverable(g,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&F==="await"&&this.raiseRecoverable(g,"Cannot use 'await' as identifier inside an async function"),this.keywords.test(F)&&this.raise(g,"Unexpected keyword '"+F+"'"),!(this.options.ecmaVersion<6&&this.input.slice(g,E).indexOf("\\")!==-1)){var L=this.strict?this.reservedWordsStrict:this.reservedWords;L.test(F)&&(!this.inAsync&&F==="await"&&this.raiseRecoverable(g,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(g,"The keyword '"+F+"' is reserved"))}},ue.parseIdent=function(r,g){var E=this.startNode();return this.type===f.name?E.name=this.value:this.type.keyword?(E.name=this.type.keyword,(E.name==="class"||E.name==="function")&&(this.lastTokEnd!==this.lastTokStart+1||this.input.charCodeAt(this.lastTokStart)!==46)&&this.context.pop()):this.unexpected(),this.next(!!r),this.finishNode(E,"Identifier"),r||(this.checkUnreserved(E),E.name==="await"&&!this.awaitIdentPos&&(this.awaitIdentPos=E.start)),E},ue.parseYield=function(r){this.yieldPos||(this.yieldPos=this.start);var g=this.startNode();return this.next(),this.type===f.semi||this.canInsertSemicolon()||this.type!==f.star&&!this.type.startsExpr?(g.delegate=!1,g.argument=null):(g.delegate=this.eat(f.star),g.argument=this.parseMaybeAssign(r)),this.finishNode(g,"YieldExpression")},ue.parseAwait=function(){this.awaitPos||(this.awaitPos=this.start);var r=this.startNode();return this.next(),r.argument=this.parseMaybeUnary(null,!1),this.finishNode(r,"AwaitExpression")};var lt=ye.prototype;lt.raise=function(r,g){var E=Y(this.input,r);g+=" ("+E.line+":"+E.column+")";var F=new SyntaxError(g);throw F.pos=r,F.loc=E,F.raisedAt=this.pos,F},lt.raiseRecoverable=lt.raise,lt.curPosition=function(){if(this.options.locations)return new ee(this.curLine,this.pos-this.lineStart)};var ze=ye.prototype,Hn=function(r){this.flags=r,this.var=[],this.lexical=[],this.functions=[]};ze.enterScope=function(r){this.scopeStack.push(new Hn(r))},ze.exitScope=function(){this.scopeStack.pop()},ze.treatFunctionsAsVarInScope=function(r){return r.flags&Ce||!this.inModule&&r.flags&se},ze.declareName=function(r,g,E){var F=!1;if(g===Oe){var L=this.currentScope();F=L.lexical.indexOf(r)>-1||L.functions.indexOf(r)>-1||L.var.indexOf(r)>-1,L.lexical.push(r),this.inModule&&L.flags&se&&delete this.undefinedExports[r]}else if(g===tn){var B=this.currentScope();B.lexical.push(r)}else if(g===en){var G=this.currentScope();this.treatFunctionsAsVar?F=G.lexical.indexOf(r)>-1:F=G.lexical.indexOf(r)>-1||G.var.indexOf(r)>-1,G.functions.push(r)}else for(var W=this.scopeStack.length-1;W>=0;--W){var ne=this.scopeStack[W];if(ne.lexical.indexOf(r)>-1&&!(ne.flags&ae&&ne.lexical[0]===r)||!this.treatFunctionsAsVarInScope(ne)&&ne.functions.indexOf(r)>-1){F=!0;break}if(ne.var.push(r),this.inModule&&ne.flags&se&&delete this.undefinedExports[r],ne.flags&ie)break}F&&this.raiseRecoverable(E,"Identifier '"+r+"' has already been declared")},ze.checkLocalExport=function(r){this.scopeStack[0].lexical.indexOf(r.name)===-1&&this.scopeStack[0].var.indexOf(r.name)===-1&&(this.undefinedExports[r.name]=r)},ze.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},ze.currentVarScope=function(){for(var r=this.scopeStack.length-1;;r--){var g=this.scopeStack[r];if(g.flags&ie)return g}},ze.currentThisScope=function(){for(var r=this.scopeStack.length-1;;r--){var g=this.scopeStack[r];if(g.flags&ie&&!(g.flags&be))return g}};var ht=function(r,g,E){this.type="",this.start=g,this.end=0,r.options.locations&&(this.loc=new Z(r,E)),r.options.directSourceFile&&(this.sourceFile=r.options.directSourceFile),r.options.ranges&&(this.range=[g,0])},ct=ye.prototype;ct.startNode=function(){return new ht(this,this.start,this.startLoc)},ct.startNodeAt=function(r,g){return new ht(this,r,g)};function sn(r,g,E,F){return r.type=g,r.end=E,this.options.locations&&(r.loc.end=F),this.options.ranges&&(r.range[1]=E),r}ct.finishNode=function(r,g){return sn.call(this,r,g,this.lastTokEnd,this.lastTokEndLoc)},ct.finishNodeAt=function(r,g,E,F){return sn.call(this,r,g,E,F)};var Ie=function(r,g,E,F,L){this.token=r,this.isExpr=!!g,this.preserveSpace=!!E,this.override=F,this.generator=!!L},xe={b_stat:new Ie("{",!1),b_expr:new Ie("{",!0),b_tmpl:new Ie("${",!1),p_stat:new Ie("(",!1),p_expr:new Ie("(",!0),q_tmpl:new Ie("`",!0,!0,function(r){return r.tryReadTemplateToken()}),f_stat:new Ie("function",!1),f_expr:new Ie("function",!0),f_expr_gen:new Ie("function",!0,!1,null,!0),f_gen:new Ie("function",!1,!1,null,!0)},pt=ye.prototype;pt.initialContext=function(){return[xe.b_stat]},pt.braceIsBlock=function(r){var g=this.curContext();return g===xe.f_expr||g===xe.f_stat?!0:r===f.colon&&(g===xe.b_stat||g===xe.b_expr)?!g.isExpr:r===f._return||r===f.name&&this.exprAllowed?R.test(this.input.slice(this.lastTokEnd,this.start)):r===f._else||r===f.semi||r===f.eof||r===f.parenR||r===f.arrow?!0:r===f.braceL?g===xe.b_stat:r===f._var||r===f._const||r===f.name?!1:!this.exprAllowed},pt.inGeneratorContext=function(){for(var r=this.context.length-1;r>=1;r--){var g=this.context[r];if(g.token==="function")return g.generator}return!1},pt.updateContext=function(r){var g,E=this.type;E.keyword&&r===f.dot?this.exprAllowed=!1:(g=E.updateContext)?g.call(this,r):this.exprAllowed=E.beforeExpr},f.parenR.updateContext=f.braceR.updateContext=function(){if(this.context.length===1){this.exprAllowed=!0;return}var r=this.context.pop();r===xe.b_stat&&this.curContext().token==="function"&&(r=this.context.pop()),this.exprAllowed=!r.isExpr},f.braceL.updateContext=function(r){this.context.push(this.braceIsBlock(r)?xe.b_stat:xe.b_expr),this.exprAllowed=!0},f.dollarBraceL.updateContext=function(){this.context.push(xe.b_tmpl),this.exprAllowed=!0},f.parenL.updateContext=function(r){var g=r===f._if||r===f._for||r===f._with||r===f._while;this.context.push(g?xe.p_stat:xe.p_expr),this.exprAllowed=!0},f.incDec.updateContext=function(){},f._function.updateContext=f._class.updateContext=function(r){r.beforeExpr&&r!==f.semi&&r!==f._else&&!(r===f._return&&R.test(this.input.slice(this.lastTokEnd,this.start)))&&!((r===f.colon||r===f.braceL)&&this.curContext()===xe.b_stat)?this.context.push(xe.f_expr):this.context.push(xe.f_stat),this.exprAllowed=!1},f.backQuote.updateContext=function(){this.curContext()===xe.q_tmpl?this.context.pop():this.context.push(xe.q_tmpl),this.exprAllowed=!1},f.star.updateContext=function(r){if(r===f._function){var g=this.context.length-1;this.context[g]===xe.f_expr?this.context[g]=xe.f_expr_gen:this.context[g]=xe.f_gen}this.exprAllowed=!0},f.name.updateContext=function(r){var g=!1;this.options.ecmaVersion>=6&&r!==f.dot&&(this.value==="of"&&!this.exprAllowed||this.value==="yield"&&this.inGeneratorContext())&&(g=!0),this.exprAllowed=g};var an="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",on=an+" Extended_Pictographic",qn=on,Xn={9:an,10:on,11:qn},un="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",ln="Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",hn=ln+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",Yn=hn+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",Jn={9:ln,10:hn,11:Yn},cn={};function Vt(r){var g=cn[r]={binary:J(Xn[r]+" "+un),nonBinary:{General_Category:J(un),Script:J(Jn[r])}};g.nonBinary.Script_Extensions=g.nonBinary.Script,g.nonBinary.gc=g.nonBinary.General_Category,g.nonBinary.sc=g.nonBinary.Script,g.nonBinary.scx=g.nonBinary.Script_Extensions}Vt(9),Vt(10),Vt(11);var te=ye.prototype,Pe=function(r){this.parser=r,this.validFlags="gim"+(r.options.ecmaVersion>=6?"uy":"")+(r.options.ecmaVersion>=9?"s":""),this.unicodeProperties=cn[r.options.ecmaVersion>=11?11:r.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};Pe.prototype.reset=function(r,g,E){var F=E.indexOf("u")!==-1;this.start=r|0,this.source=g+"",this.flags=E,this.switchU=F&&this.parser.options.ecmaVersion>=6,this.switchN=F&&this.parser.options.ecmaVersion>=9},Pe.prototype.raise=function(r){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+r)},Pe.prototype.at=function(r){var g=this.source,E=g.length;if(r>=E)return-1;var F=g.charCodeAt(r);if(!this.switchU||F<=55295||F>=57344||r+1>=E)return F;var L=g.charCodeAt(r+1);return L>=56320&&L<=57343?(F<<10)+L-56613888:F},Pe.prototype.nextIndex=function(r){var g=this.source,E=g.length;if(r>=E)return E;var F=g.charCodeAt(r),L;return!this.switchU||F<=55295||F>=57344||r+1>=E||(L=g.charCodeAt(r+1))<56320||L>57343?r+1:r+2},Pe.prototype.current=function(){return this.at(this.pos)},Pe.prototype.lookahead=function(){return this.at(this.nextIndex(this.pos))},Pe.prototype.advance=function(){this.pos=this.nextIndex(this.pos)},Pe.prototype.eat=function(r){return this.current()===r?(this.advance(),!0):!1};function dt(r){return r<=65535?String.fromCharCode(r):(r-=65536,String.fromCharCode((r>>10)+55296,(r&1023)+56320))}te.validateRegExpFlags=function(r){for(var g=r.validFlags,E=r.flags,F=0;F<E.length;F++){var L=E.charAt(F);g.indexOf(L)===-1&&this.raise(r.start,"Invalid regular expression flag"),E.indexOf(L,F+1)>-1&&this.raise(r.start,"Duplicate regular expression flag")}},te.validateRegExpPattern=function(r){this.regexp_pattern(r),!r.switchN&&this.options.ecmaVersion>=9&&r.groupNames.length>0&&(r.switchN=!0,this.regexp_pattern(r))},te.regexp_pattern=function(r){r.pos=0,r.lastIntValue=0,r.lastStringValue="",r.lastAssertionIsQuantifiable=!1,r.numCapturingParens=0,r.maxBackReference=0,r.groupNames.length=0,r.backReferenceNames.length=0,this.regexp_disjunction(r),r.pos!==r.source.length&&(r.eat(41)&&r.raise("Unmatched ')'"),(r.eat(93)||r.eat(125))&&r.raise("Lone quantifier brackets")),r.maxBackReference>r.numCapturingParens&&r.raise("Invalid escape");for(var g=0,E=r.backReferenceNames;g<E.length;g+=1){var F=E[g];r.groupNames.indexOf(F)===-1&&r.raise("Invalid named capture referenced")}},te.regexp_disjunction=function(r){for(this.regexp_alternative(r);r.eat(124);)this.regexp_alternative(r);this.regexp_eatQuantifier(r,!0)&&r.raise("Nothing to repeat"),r.eat(123)&&r.raise("Lone quantifier brackets")},te.regexp_alternative=function(r){for(;r.pos<r.source.length&&this.regexp_eatTerm(r););},te.regexp_eatTerm=function(r){return this.regexp_eatAssertion(r)?(r.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(r)&&r.switchU&&r.raise("Invalid quantifier"),!0):(r.switchU?this.regexp_eatAtom(r):this.regexp_eatExtendedAtom(r))?(this.regexp_eatQuantifier(r),!0):!1},te.regexp_eatAssertion=function(r){var g=r.pos;if(r.lastAssertionIsQuantifiable=!1,r.eat(94)||r.eat(36))return!0;if(r.eat(92)){if(r.eat(66)||r.eat(98))return!0;r.pos=g}if(r.eat(40)&&r.eat(63)){var E=!1;if(this.options.ecmaVersion>=9&&(E=r.eat(60)),r.eat(61)||r.eat(33))return this.regexp_disjunction(r),r.eat(41)||r.raise("Unterminated group"),r.lastAssertionIsQuantifiable=!E,!0}return r.pos=g,!1},te.regexp_eatQuantifier=function(r,g){return g===void 0&&(g=!1),this.regexp_eatQuantifierPrefix(r,g)?(r.eat(63),!0):!1},te.regexp_eatQuantifierPrefix=function(r,g){return r.eat(42)||r.eat(43)||r.eat(63)||this.regexp_eatBracedQuantifier(r,g)},te.regexp_eatBracedQuantifier=function(r,g){var E=r.pos;if(r.eat(123)){var F=0,L=-1;if(this.regexp_eatDecimalDigits(r)&&(F=r.lastIntValue,r.eat(44)&&this.regexp_eatDecimalDigits(r)&&(L=r.lastIntValue),r.eat(125)))return L!==-1&&L<F&&!g&&r.raise("numbers out of order in {} quantifier"),!0;r.switchU&&!g&&r.raise("Incomplete quantifier"),r.pos=E}return!1},te.regexp_eatAtom=function(r){return this.regexp_eatPatternCharacters(r)||r.eat(46)||this.regexp_eatReverseSolidusAtomEscape(r)||this.regexp_eatCharacterClass(r)||this.regexp_eatUncapturingGroup(r)||this.regexp_eatCapturingGroup(r)},te.regexp_eatReverseSolidusAtomEscape=function(r){var g=r.pos;if(r.eat(92)){if(this.regexp_eatAtomEscape(r))return!0;r.pos=g}return!1},te.regexp_eatUncapturingGroup=function(r){var g=r.pos;if(r.eat(40)){if(r.eat(63)&&r.eat(58)){if(this.regexp_disjunction(r),r.eat(41))return!0;r.raise("Unterminated group")}r.pos=g}return!1},te.regexp_eatCapturingGroup=function(r){if(r.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(r):r.current()===63&&r.raise("Invalid group"),this.regexp_disjunction(r),r.eat(41))return r.numCapturingParens+=1,!0;r.raise("Unterminated group")}return!1},te.regexp_eatExtendedAtom=function(r){return r.eat(46)||this.regexp_eatReverseSolidusAtomEscape(r)||this.regexp_eatCharacterClass(r)||this.regexp_eatUncapturingGroup(r)||this.regexp_eatCapturingGroup(r)||this.regexp_eatInvalidBracedQuantifier(r)||this.regexp_eatExtendedPatternCharacter(r)},te.regexp_eatInvalidBracedQuantifier=function(r){return this.regexp_eatBracedQuantifier(r,!0)&&r.raise("Nothing to repeat"),!1},te.regexp_eatSyntaxCharacter=function(r){var g=r.current();return pn(g)?(r.lastIntValue=g,r.advance(),!0):!1};function pn(r){return r===36||r>=40&&r<=43||r===46||r===63||r>=91&&r<=94||r>=123&&r<=125}te.regexp_eatPatternCharacters=function(r){for(var g=r.pos,E=0;(E=r.current())!==-1&&!pn(E);)r.advance();return r.pos!==g},te.regexp_eatExtendedPatternCharacter=function(r){var g=r.current();return g!==-1&&g!==36&&!(g>=40&&g<=43)&&g!==46&&g!==63&&g!==91&&g!==94&&g!==124?(r.advance(),!0):!1},te.regexp_groupSpecifier=function(r){if(r.eat(63)){if(this.regexp_eatGroupName(r)){r.groupNames.indexOf(r.lastStringValue)!==-1&&r.raise("Duplicate capture group name"),r.groupNames.push(r.lastStringValue);return}r.raise("Invalid group")}},te.regexp_eatGroupName=function(r){if(r.lastStringValue="",r.eat(60)){if(this.regexp_eatRegExpIdentifierName(r)&&r.eat(62))return!0;r.raise("Invalid capture group name")}return!1},te.regexp_eatRegExpIdentifierName=function(r){if(r.lastStringValue="",this.regexp_eatRegExpIdentifierStart(r)){for(r.lastStringValue+=dt(r.lastIntValue);this.regexp_eatRegExpIdentifierPart(r);)r.lastStringValue+=dt(r.lastIntValue);return!0}return!1},te.regexp_eatRegExpIdentifierStart=function(r){var g=r.pos,E=r.current();return r.advance(),E===92&&this.regexp_eatRegExpUnicodeEscapeSequence(r)&&(E=r.lastIntValue),Zn(E)?(r.lastIntValue=E,!0):(r.pos=g,!1)};function Zn(r){return D(r,!0)||r===36||r===95}te.regexp_eatRegExpIdentifierPart=function(r){var g=r.pos,E=r.current();return r.advance(),E===92&&this.regexp_eatRegExpUnicodeEscapeSequence(r)&&(E=r.lastIntValue),Qn(E)?(r.lastIntValue=E,!0):(r.pos=g,!1)};function Qn(r){return C(r,!0)||r===36||r===95||r===8204||r===8205}te.regexp_eatAtomEscape=function(r){return this.regexp_eatBackReference(r)||this.regexp_eatCharacterClassEscape(r)||this.regexp_eatCharacterEscape(r)||r.switchN&&this.regexp_eatKGroupName(r)?!0:(r.switchU&&(r.current()===99&&r.raise("Invalid unicode escape"),r.raise("Invalid escape")),!1)},te.regexp_eatBackReference=function(r){var g=r.pos;if(this.regexp_eatDecimalEscape(r)){var E=r.lastIntValue;if(r.switchU)return E>r.maxBackReference&&(r.maxBackReference=E),!0;if(E<=r.numCapturingParens)return!0;r.pos=g}return!1},te.regexp_eatKGroupName=function(r){if(r.eat(107)){if(this.regexp_eatGroupName(r))return r.backReferenceNames.push(r.lastStringValue),!0;r.raise("Invalid named reference")}return!1},te.regexp_eatCharacterEscape=function(r){return this.regexp_eatControlEscape(r)||this.regexp_eatCControlLetter(r)||this.regexp_eatZero(r)||this.regexp_eatHexEscapeSequence(r)||this.regexp_eatRegExpUnicodeEscapeSequence(r)||!r.switchU&&this.regexp_eatLegacyOctalEscapeSequence(r)||this.regexp_eatIdentityEscape(r)},te.regexp_eatCControlLetter=function(r){var g=r.pos;if(r.eat(99)){if(this.regexp_eatControlLetter(r))return!0;r.pos=g}return!1},te.regexp_eatZero=function(r){return r.current()===48&&!ft(r.lookahead())?(r.lastIntValue=0,r.advance(),!0):!1},te.regexp_eatControlEscape=function(r){var g=r.current();return g===116?(r.lastIntValue=9,r.advance(),!0):g===110?(r.lastIntValue=10,r.advance(),!0):g===118?(r.lastIntValue=11,r.advance(),!0):g===102?(r.lastIntValue=12,r.advance(),!0):g===114?(r.lastIntValue=13,r.advance(),!0):!1},te.regexp_eatControlLetter=function(r){var g=r.current();return dn(g)?(r.lastIntValue=g%32,r.advance(),!0):!1};function dn(r){return r>=65&&r<=90||r>=97&&r<=122}te.regexp_eatRegExpUnicodeEscapeSequence=function(r){var g=r.pos;if(r.eat(117)){if(this.regexp_eatFixedHexDigits(r,4)){var E=r.lastIntValue;if(r.switchU&&E>=55296&&E<=56319){var F=r.pos;if(r.eat(92)&&r.eat(117)&&this.regexp_eatFixedHexDigits(r,4)){var L=r.lastIntValue;if(L>=56320&&L<=57343)return r.lastIntValue=(E-55296)*1024+(L-56320)+65536,!0}r.pos=F,r.lastIntValue=E}return!0}if(r.switchU&&r.eat(123)&&this.regexp_eatHexDigits(r)&&r.eat(125)&&er(r.lastIntValue))return!0;r.switchU&&r.raise("Invalid unicode escape"),r.pos=g}return!1};function er(r){return r>=0&&r<=1114111}te.regexp_eatIdentityEscape=function(r){if(r.switchU)return this.regexp_eatSyntaxCharacter(r)?!0:r.eat(47)?(r.lastIntValue=47,!0):!1;var g=r.current();return g!==99&&(!r.switchN||g!==107)?(r.lastIntValue=g,r.advance(),!0):!1},te.regexp_eatDecimalEscape=function(r){r.lastIntValue=0;var g=r.current();if(g>=49&&g<=57){do r.lastIntValue=10*r.lastIntValue+(g-48),r.advance();while((g=r.current())>=48&&g<=57);return!0}return!1},te.regexp_eatCharacterClassEscape=function(r){var g=r.current();if(tr(g))return r.lastIntValue=-1,r.advance(),!0;if(r.switchU&&this.options.ecmaVersion>=9&&(g===80||g===112)){if(r.lastIntValue=-1,r.advance(),r.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(r)&&r.eat(125))return!0;r.raise("Invalid property name")}return!1};function tr(r){return r===100||r===68||r===115||r===83||r===119||r===87}te.regexp_eatUnicodePropertyValueExpression=function(r){var g=r.pos;if(this.regexp_eatUnicodePropertyName(r)&&r.eat(61)){var E=r.lastStringValue;if(this.regexp_eatUnicodePropertyValue(r)){var F=r.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(r,E,F),!0}}if(r.pos=g,this.regexp_eatLoneUnicodePropertyNameOrValue(r)){var L=r.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(r,L),!0}return!1},te.regexp_validateUnicodePropertyNameAndValue=function(r,g,E){H(r.unicodeProperties.nonBinary,g)||r.raise("Invalid property name"),r.unicodeProperties.nonBinary[g].test(E)||r.raise("Invalid property value")},te.regexp_validateUnicodePropertyNameOrValue=function(r,g){r.unicodeProperties.binary.test(g)||r.raise("Invalid property name")},te.regexp_eatUnicodePropertyName=function(r){var g=0;for(r.lastStringValue="";fn(g=r.current());)r.lastStringValue+=dt(g),r.advance();return r.lastStringValue!==""};function fn(r){return dn(r)||r===95}te.regexp_eatUnicodePropertyValue=function(r){var g=0;for(r.lastStringValue="";nr(g=r.current());)r.lastStringValue+=dt(g),r.advance();return r.lastStringValue!==""};function nr(r){return fn(r)||ft(r)}te.regexp_eatLoneUnicodePropertyNameOrValue=function(r){return this.regexp_eatUnicodePropertyValue(r)},te.regexp_eatCharacterClass=function(r){if(r.eat(91)){if(r.eat(94),this.regexp_classRanges(r),r.eat(93))return!0;r.raise("Unterminated character class")}return!1},te.regexp_classRanges=function(r){for(;this.regexp_eatClassAtom(r);){var g=r.lastIntValue;if(r.eat(45)&&this.regexp_eatClassAtom(r)){var E=r.lastIntValue;r.switchU&&(g===-1||E===-1)&&r.raise("Invalid character class"),g!==-1&&E!==-1&&g>E&&r.raise("Range out of order in character class")}}},te.regexp_eatClassAtom=function(r){var g=r.pos;if(r.eat(92)){if(this.regexp_eatClassEscape(r))return!0;if(r.switchU){var E=r.current();(E===99||yn(E))&&r.raise("Invalid class escape"),r.raise("Invalid escape")}r.pos=g}var F=r.current();return F!==93?(r.lastIntValue=F,r.advance(),!0):!1},te.regexp_eatClassEscape=function(r){var g=r.pos;if(r.eat(98))return r.lastIntValue=8,!0;if(r.switchU&&r.eat(45))return r.lastIntValue=45,!0;if(!r.switchU&&r.eat(99)){if(this.regexp_eatClassControlLetter(r))return!0;r.pos=g}return this.regexp_eatCharacterClassEscape(r)||this.regexp_eatCharacterEscape(r)},te.regexp_eatClassControlLetter=function(r){var g=r.current();return ft(g)||g===95?(r.lastIntValue=g%32,r.advance(),!0):!1},te.regexp_eatHexEscapeSequence=function(r){var g=r.pos;if(r.eat(120)){if(this.regexp_eatFixedHexDigits(r,2))return!0;r.switchU&&r.raise("Invalid escape"),r.pos=g}return!1},te.regexp_eatDecimalDigits=function(r){var g=r.pos,E=0;for(r.lastIntValue=0;ft(E=r.current());)r.lastIntValue=10*r.lastIntValue+(E-48),r.advance();return r.pos!==g};function ft(r){return r>=48&&r<=57}te.regexp_eatHexDigits=function(r){var g=r.pos,E=0;for(r.lastIntValue=0;gn(E=r.current());)r.lastIntValue=16*r.lastIntValue+mn(E),r.advance();return r.pos!==g};function gn(r){return r>=48&&r<=57||r>=65&&r<=70||r>=97&&r<=102}function mn(r){return r>=65&&r<=70?10+(r-65):r>=97&&r<=102?10+(r-97):r-48}te.regexp_eatLegacyOctalEscapeSequence=function(r){if(this.regexp_eatOctalDigit(r)){var g=r.lastIntValue;if(this.regexp_eatOctalDigit(r)){var E=r.lastIntValue;g<=3&&this.regexp_eatOctalDigit(r)?r.lastIntValue=g*64+E*8+r.lastIntValue:r.lastIntValue=g*8+E}else r.lastIntValue=g;return!0}return!1},te.regexp_eatOctalDigit=function(r){var g=r.current();return yn(g)?(r.lastIntValue=g-48,r.advance(),!0):(r.lastIntValue=0,!1)};function yn(r){return r>=48&&r<=55}te.regexp_eatFixedHexDigits=function(r,g){var E=r.pos;r.lastIntValue=0;for(var F=0;F<g;++F){var L=r.current();if(!gn(L))return r.pos=E,!1;r.lastIntValue=16*r.lastIntValue+mn(L),r.advance()}return!0};var gt=function(r){this.type=r.type,this.value=r.value,this.start=r.start,this.end=r.end,r.options.locations&&(this.loc=new Z(r,r.startLoc,r.endLoc)),r.options.ranges&&(this.range=[r.start,r.end])},le=ye.prototype;le.next=function(r){!r&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new gt(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},le.getToken=function(){return this.next(),new gt(this)},typeof Symbol<"u"&&(le[Symbol.iterator]=function(){var r=this;return{next:function(){var g=r.getToken();return{done:g.type===f.eof,value:g}}}}),le.curContext=function(){return this.context[this.context.length-1]},le.nextToken=function(){var r=this.curContext();if((!r||!r.preserveSpace)&&this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length)return this.finishToken(f.eof);if(r.override)return r.override(this);this.readToken(this.fullCharCodeAtPos())},le.readToken=function(r){return D(r,this.options.ecmaVersion>=6)||r===92?this.readWord():this.getTokenFromCode(r)},le.fullCharCodeAtPos=function(){var r=this.input.charCodeAt(this.pos);if(r<=55295||r>=57344)return r;var g=this.input.charCodeAt(this.pos+1);return(r<<10)+g-56613888},le.skipBlockComment=function(){var r=this.options.onComment&&this.curPosition(),g=this.pos,E=this.input.indexOf("*/",this.pos+=2);if(E===-1&&this.raise(this.pos-2,"Unterminated comment"),this.pos=E+2,this.options.locations){N.lastIndex=g;for(var F;(F=N.exec(this.input))&&F.index<this.pos;)++this.curLine,this.lineStart=F.index+F[0].length}this.options.onComment&&this.options.onComment(!0,this.input.slice(g+2,E),g,this.pos,r,this.curPosition())},le.skipLineComment=function(r){for(var g=this.pos,E=this.options.onComment&&this.curPosition(),F=this.input.charCodeAt(this.pos+=r);this.pos<this.input.length&&!K(F);)F=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(g+r,this.pos),g,this.pos,E,this.curPosition())},le.skipSpace=function(){e:for(;this.pos<this.input.length;){var r=this.input.charCodeAt(this.pos);switch(r){case 32:case 160:++this.pos;break;case 13:this.input.charCodeAt(this.pos+1)===10&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(r>8&&r<14||r>=5760&&O.test(String.fromCharCode(r)))++this.pos;else break e}}},le.finishToken=function(r,g){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var E=this.type;this.type=r,this.value=g,this.updateContext(E)},le.readToken_dot=function(){var r=this.input.charCodeAt(this.pos+1);if(r>=48&&r<=57)return this.readNumber(!0);var g=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&r===46&&g===46?(this.pos+=3,this.finishToken(f.ellipsis)):(++this.pos,this.finishToken(f.dot))},le.readToken_slash=function(){var r=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):r===61?this.finishOp(f.assign,2):this.finishOp(f.slash,1)},le.readToken_mult_modulo_exp=function(r){var g=this.input.charCodeAt(this.pos+1),E=1,F=r===42?f.star:f.modulo;return this.options.ecmaVersion>=7&&r===42&&g===42&&(++E,F=f.starstar,g=this.input.charCodeAt(this.pos+2)),g===61?this.finishOp(f.assign,E+1):this.finishOp(F,E)},le.readToken_pipe_amp=function(r){var g=this.input.charCodeAt(this.pos+1);return g===r?this.finishOp(r===124?f.logicalOR:f.logicalAND,2):g===61?this.finishOp(f.assign,2):this.finishOp(r===124?f.bitwiseOR:f.bitwiseAND,1)},le.readToken_caret=function(){var r=this.input.charCodeAt(this.pos+1);return r===61?this.finishOp(f.assign,2):this.finishOp(f.bitwiseXOR,1)},le.readToken_plus_min=function(r){var g=this.input.charCodeAt(this.pos+1);return g===r?g===45&&!this.inModule&&this.input.charCodeAt(this.pos+2)===62&&(this.lastTokEnd===0||R.test(this.input.slice(this.lastTokEnd,this.pos)))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(f.incDec,2):g===61?this.finishOp(f.assign,2):this.finishOp(f.plusMin,1)},le.readToken_lt_gt=function(r){var g=this.input.charCodeAt(this.pos+1),E=1;return g===r?(E=r===62&&this.input.charCodeAt(this.pos+2)===62?3:2,this.input.charCodeAt(this.pos+E)===61?this.finishOp(f.assign,E+1):this.finishOp(f.bitShift,E)):g===33&&r===60&&!this.inModule&&this.input.charCodeAt(this.pos+2)===45&&this.input.charCodeAt(this.pos+3)===45?(this.skipLineComment(4),this.skipSpace(),this.nextToken()):(g===61&&(E=2),this.finishOp(f.relational,E))},le.readToken_eq_excl=function(r){var g=this.input.charCodeAt(this.pos+1);return g===61?this.finishOp(f.equality,this.input.charCodeAt(this.pos+2)===61?3:2):r===61&&g===62&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(f.arrow)):this.finishOp(r===61?f.eq:f.prefix,1)},le.getTokenFromCode=function(r){switch(r){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(f.parenL);case 41:return++this.pos,this.finishToken(f.parenR);case 59:return++this.pos,this.finishToken(f.semi);case 44:return++this.pos,this.finishToken(f.comma);case 91:return++this.pos,this.finishToken(f.bracketL);case 93:return++this.pos,this.finishToken(f.bracketR);case 123:return++this.pos,this.finishToken(f.braceL);case 125:return++this.pos,this.finishToken(f.braceR);case 58:return++this.pos,this.finishToken(f.colon);case 63:return++this.pos,this.finishToken(f.question);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(f.backQuote);case 48:var g=this.input.charCodeAt(this.pos+1);if(g===120||g===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(g===111||g===79)return this.readRadixNumber(8);if(g===98||g===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(r);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(r);case 124:case 38:return this.readToken_pipe_amp(r);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(r);case 60:case 62:return this.readToken_lt_gt(r);case 61:case 33:return this.readToken_eq_excl(r);case 126:return this.finishOp(f.prefix,1)}this.raise(this.pos,"Unexpected character '"+Pt(r)+"'")},le.finishOp=function(r,g){var E=this.input.slice(this.pos,this.pos+g);return this.pos+=g,this.finishToken(r,E)},le.readRegexp=function(){for(var r,g,E=this.pos;;){this.pos>=this.input.length&&this.raise(E,"Unterminated regular expression");var F=this.input.charAt(this.pos);if(R.test(F)&&this.raise(E,"Unterminated regular expression"),r)r=!1;else{if(F==="[")g=!0;else if(F==="]"&&g)g=!1;else if(F==="/"&&!g)break;r=F==="\\"}++this.pos}var L=this.input.slice(E,this.pos);++this.pos;var B=this.pos,G=this.readWord1();this.containsEsc&&this.unexpected(B);var W=this.regexpState||(this.regexpState=new Pe(this));W.reset(E,L,G),this.validateRegExpFlags(W),this.validateRegExpPattern(W);var ne=null;try{ne=new RegExp(L,G)}catch{}return this.finishToken(f.regexp,{pattern:L,flags:G,value:ne})},le.readInt=function(r,g){for(var E=this.pos,F=0,L=0,B=g??1/0;L<B;++L){var G=this.input.charCodeAt(this.pos),W=void 0;if(G>=97?W=G-97+10:G>=65?W=G-65+10:G>=48&&G<=57?W=G-48:W=1/0,W>=r)break;++this.pos,F=F*r+W}return this.pos===E||g!=null&&this.pos-E!==g?null:F},le.readRadixNumber=function(r){var g=this.pos;this.pos+=2;var E=this.readInt(r);return E==null&&this.raise(this.start+2,"Expected number in radix "+r),this.options.ecmaVersion>=11&&this.input.charCodeAt(this.pos)===110?(E=typeof BigInt<"u"?BigInt(this.input.slice(g,this.pos)):null,++this.pos):D(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(f.num,E)},le.readNumber=function(r){var g=this.pos;!r&&this.readInt(10)===null&&this.raise(g,"Invalid number");var E=this.pos-g>=2&&this.input.charCodeAt(g)===48;E&&this.strict&&this.raise(g,"Invalid number");var F=this.input.charCodeAt(this.pos);if(!E&&!r&&this.options.ecmaVersion>=11&&F===110){var L=this.input.slice(g,this.pos),B=typeof BigInt<"u"?BigInt(L):null;return++this.pos,D(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(f.num,B)}E&&/[89]/.test(this.input.slice(g,this.pos))&&(E=!1),F===46&&!E&&(++this.pos,this.readInt(10),F=this.input.charCodeAt(this.pos)),(F===69||F===101)&&!E&&(F=this.input.charCodeAt(++this.pos),(F===43||F===45)&&++this.pos,this.readInt(10)===null&&this.raise(g,"Invalid number")),D(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var G=this.input.slice(g,this.pos),W=E?parseInt(G,8):parseFloat(G);return this.finishToken(f.num,W)},le.readCodePoint=function(){var r=this.input.charCodeAt(this.pos),g;if(r===123){this.options.ecmaVersion<6&&this.unexpected();var E=++this.pos;g=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,g>1114111&&this.invalidStringToken(E,"Code point out of bounds")}else g=this.readHexChar(4);return g};function Pt(r){return r<=65535?String.fromCharCode(r):(r-=65536,String.fromCharCode((r>>10)+55296,(r&1023)+56320))}le.readString=function(r){for(var g="",E=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var F=this.input.charCodeAt(this.pos);if(F===r)break;F===92?(g+=this.input.slice(E,this.pos),g+=this.readEscapedChar(!1),E=this.pos):(K(F,this.options.ecmaVersion>=10)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return g+=this.input.slice(E,this.pos++),this.finishToken(f.string,g)};var xn={};le.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(r){if(r===xn)this.readInvalidTemplateToken();else throw r}this.inTemplateElement=!1},le.invalidStringToken=function(r,g){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw xn;this.raise(r,g)},le.readTmplToken=function(){for(var r="",g=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var E=this.input.charCodeAt(this.pos);if(E===96||E===36&&this.input.charCodeAt(this.pos+1)===123)return this.pos===this.start&&(this.type===f.template||this.type===f.invalidTemplate)?E===36?(this.pos+=2,this.finishToken(f.dollarBraceL)):(++this.pos,this.finishToken(f.backQuote)):(r+=this.input.slice(g,this.pos),this.finishToken(f.template,r));if(E===92)r+=this.input.slice(g,this.pos),r+=this.readEscapedChar(!0),g=this.pos;else if(K(E)){switch(r+=this.input.slice(g,this.pos),++this.pos,E){case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:r+=`
`;break;default:r+=String.fromCharCode(E);break}this.options.locations&&(++this.curLine,this.lineStart=this.pos),g=this.pos}else++this.pos}},le.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if(this.input[this.pos+1]!=="{")break;case"`":return this.finishToken(f.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},le.readEscapedChar=function(r){var g=this.input.charCodeAt(++this.pos);switch(++this.pos,g){case 110:return`
`;case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return Pt(this.readCodePoint());case 116:return"	";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(r){var E=this.pos-1;return this.invalidStringToken(E,"Invalid escape sequence in template string"),null}default:if(g>=48&&g<=55){var F=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],L=parseInt(F,8);return L>255&&(F=F.slice(0,-1),L=parseInt(F,8)),this.pos+=F.length-1,g=this.input.charCodeAt(this.pos),(F!=="0"||g===56||g===57)&&(this.strict||r)&&this.invalidStringToken(this.pos-1-F.length,r?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(L)}return K(g)?"":String.fromCharCode(g)}},le.readHexChar=function(r){var g=this.pos,E=this.readInt(16,r);return E===null&&this.invalidStringToken(g,"Bad character escape sequence"),E},le.readWord1=function(){this.containsEsc=!1;for(var r="",g=!0,E=this.pos,F=this.options.ecmaVersion>=6;this.pos<this.input.length;){var L=this.fullCharCodeAtPos();if(C(L,F))this.pos+=L<=65535?1:2;else if(L===92){this.containsEsc=!0,r+=this.input.slice(E,this.pos);var B=this.pos;this.input.charCodeAt(++this.pos)!==117&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var G=this.readCodePoint();(g?D:C)(G,F)||this.invalidStringToken(B,"Invalid Unicode escape"),r+=Pt(G),E=this.pos}else break;g=!1}return r+this.input.slice(E,this.pos)},le.readWord=function(){var r=this.readWord1(),g=f.name;return this.keywords.test(r)&&(g=P[r]),this.finishToken(g,r)};var bn="7.1.0";ye.acorn={Parser:ye,version:bn,defaultOptions:X,Position:ee,SourceLocation:Z,getLineInfo:Y,Node:ht,TokenType:T,tokTypes:f,keywordTypes:P,TokContext:Ie,tokContexts:xe,isIdentifierChar:C,isIdentifierStart:D,Token:gt,isNewLine:K,lineBreak:R,lineBreakG:N,nonASCIIwhitespace:O};function rr(r,g){return ye.parse(r,g)}function ir(r,g,E){return ye.parseExpressionAt(r,g,E)}function sr(r,g){return ye.tokenizer(r,g)}p.Node=ht,p.Parser=ye,p.Position=ee,p.SourceLocation=Z,p.TokContext=Ie,p.Token=gt,p.TokenType=T,p.defaultOptions=X,p.getLineInfo=Y,p.isIdentifierChar=C,p.isIdentifierStart=D,p.isNewLine=K,p.keywordTypes=P,p.lineBreak=R,p.lineBreakG=N,p.nonASCIIwhitespace=O,p.parse=rr,p.parseExpressionAt=ir,p.tokContexts=xe,p.tokTypes=f,p.tokenizer=sr,p.version=bn,Object.defineProperty(p,"__esModule",{value:!0})})},{}],2:[function(i,c,d){},{}],3:[function(i,c,d){function p(h,a={}){let{contextName:o="gl",throwGetError:b,useTrackablePrimitives:w,readPixelsFile:I,recording:S=[],variables:D={},onReadPixels:C,onUnrecognizedArgumentLookup:T}=a,_=new Proxy(h,{get:R}),k=[],M={},P=0,A="",f;return _;function R(Y,X){switch(X){case"addComment":return H;case"checkThrowError":return U;case"getReadPixelsVariableName":return f;case"insertVariable":return O;case"reset":return K;case"setIndent":return j;case"toString":return N;case"getContextVariableName":return Z}return typeof h[X]=="function"?function(){switch(X){case"getError":return b?S.push(`${A}if (${o}.getError() !== ${o}.NONE) throw new Error('error');`):S.push(`${A}${o}.getError();`),h.getError();case"getExtension":{let ie=`${o}Variables${k.length}`;S.push(`${A}const ${ie} = ${o}.getExtension('${arguments[0]}');`);let me=h.getExtension(arguments[0]);if(me&&typeof me=="object"){let ve=y(me,{getEntity:V,useTrackablePrimitives:w,recording:S,contextName:ie,contextVariables:k,variables:D,indent:A,onUnrecognizedArgumentLookup:T});return k.push(ve),ve}else k.push(null);return me}case"readPixels":let re=k.indexOf(arguments[6]),se;if(re===-1){let ie=ee(arguments[6]);ie?(se=ie,S.push(`${A}${ie}`)):(se=`${o}Variable${k.length}`,k.push(arguments[6]),S.push(`${A}const ${se} = new ${arguments[6].constructor.name}(${arguments[6].length});`))}else se=`${o}Variable${re}`;f=se;let Ce=[arguments[0],arguments[1],arguments[2],arguments[3],V(arguments[4]),V(arguments[5]),se];return S.push(`${A}${o}.readPixels(${Ce.join(", ")});`),I&&q(arguments[2],arguments[3]),C&&C(se,Ce),h.readPixels.apply(h,arguments);case"drawBuffers":return S.push(`${A}${o}.drawBuffers([${v(arguments[0],{contextName:o,contextVariables:k,getEntity:V,addVariable:z,variables:D,onUnrecognizedArgumentLookup:T})}]);`),h.drawBuffers(arguments[0])}let ge=h[X].apply(h,arguments);switch(typeof ge){case"undefined":S.push(`${A}${J(X,arguments)};`);return;case"number":case"boolean":if(w&&k.indexOf(l(ge))===-1){S.push(`${A}const ${o}Variable${k.length} = ${J(X,arguments)};`),k.push(ge=l(ge));break}default:ge===null?S.push(`${J(X,arguments)};`):S.push(`${A}const ${o}Variable${k.length} = ${J(X,arguments)};`),k.push(ge)}return ge}:(M[h[X]]=X,h[X])}function N(){return S.join(`
`)}function K(){for(;S.length>0;)S.pop()}function O(Y,X){D[Y]=X}function V(Y){let X=M[Y];return X?o+"."+X:Y}function j(Y){A=" ".repeat(Y)}function z(Y,X){let ge=`${o}Variable${k.length}`;return S.push(`${A}const ${ge} = ${X};`),k.push(Y),ge}function q(Y,X){let ge=`${o}Variable${k.length}`,re=`imageDatum${P}`;S.push(`${A}let ${re} = ["P3\\n# ${I}.ppm\\n", ${Y}, ' ', ${X}, "\\n255\\n"].join("");`),S.push(`${A}for (let i = 0; i < ${re}.length; i += 4) {`),S.push(`${A}  ${re} += ${ge}[i] + ' ' + ${ge}[i + 1] + ' ' + ${ge}[i + 2] + ' ';`),S.push(`${A}}`),S.push(`${A}if (typeof require !== "undefined") {`),S.push(`${A}  require('fs').writeFileSync('./${I}.ppm', ${re});`),S.push(`${A}}`),P++}function H(Y){S.push(`${A}// ${Y}`)}function U(){S.push(`${A}(() => {
      ${A}const error = ${o}.getError();
      ${A}if (error !== ${o}.NONE) {
      ${A}  const names = Object.getOwnPropertyNames(gl);
      ${A}  for (let i = 0; i < names.length; i++) {
      ${A}    const name = names[i];
      ${A}    if (${o}[name] === error) {
      ${A}      throw new Error('${o} threw ' + name);
      ${A}    }
      ${A}  }
      ${A}}
      ${A}})();`)}function J(Y,X){return`${o}.${Y}(${v(X,{contextName:o,contextVariables:k,getEntity:V,addVariable:z,variables:D,onUnrecognizedArgumentLookup:T})})`}function ee(Y){if(D){for(let X in D)if(D[X]===Y)return X}return null}function Z(Y){let X=k.indexOf(Y);return X!==-1?`${o}Variable${X}`:null}}function y(h,a){let o=new Proxy(h,{get:M}),b={},{contextName:w,contextVariables:I,getEntity:S,useTrackablePrimitives:D,recording:C,variables:T,indent:_,onUnrecognizedArgumentLookup:k}=a;return o;function M(R,N){return typeof R[N]=="function"?function(){switch(N){case"drawBuffersWEBGL":return C.push(`${_}${w}.drawBuffersWEBGL([${v(arguments[0],{contextName:w,contextVariables:I,getEntity:P,addVariable:f,variables:T,onUnrecognizedArgumentLookup:k})}]);`),h.drawBuffersWEBGL(arguments[0])}let K=h[N].apply(h,arguments);switch(typeof K){case"undefined":C.push(`${_}${A(N,arguments)};`);return;case"number":case"boolean":D&&I.indexOf(l(K))===-1?(C.push(`${_}const ${w}Variable${I.length} = ${A(N,arguments)};`),I.push(K=l(K))):(C.push(`${_}const ${w}Variable${I.length} = ${A(N,arguments)};`),I.push(K));break;default:K===null?C.push(`${A(N,arguments)};`):C.push(`${_}const ${w}Variable${I.length} = ${A(N,arguments)};`),I.push(K)}return K}:(b[h[N]]=N,h[N])}function P(R){return b.hasOwnProperty(R)?`${w}.${b[R]}`:S(R)}function A(R,N){return`${w}.${R}(${v(N,{contextName:w,contextVariables:I,getEntity:P,addVariable:f,variables:T,onUnrecognizedArgumentLookup:k})})`}function f(R,N){let K=`${w}Variable${I.length}`;return I.push(R),C.push(`${_}const ${K} = ${N};`),K}}function v(h,a){let{variables:o,onUnrecognizedArgumentLookup:b}=a;return Array.from(h).map(I=>w(I)||m(I,a)).join(", ");function w(I){if(o){for(let S in o)if(!!o.hasOwnProperty(S)&&o[S]===I)return S}return b?b(I):null}}function m(h,a){let{contextName:o,contextVariables:b,getEntity:w,addVariable:I,onUnrecognizedArgumentLookup:S}=a;if(typeof h>"u")return"undefined";if(h===null)return"null";let D=b.indexOf(h);if(D>-1)return`${o}Variable${D}`;switch(h.constructor.name){case"String":let C=/\n/.test(h),T=/'/.test(h),_=/"/.test(h);return C?"`"+h+"`":T&&!_?'"'+h+'"':"'"+h+"'";case"Number":return w(h);case"Boolean":return w(h);case"Array":return I(h,`new ${h.constructor.name}([${Array.from(h).join(",")}])`);case"Float32Array":case"Uint8Array":case"Uint16Array":case"Int32Array":return I(h,`new ${h.constructor.name}(${JSON.stringify(Array.from(h))})`);default:if(S){let k=S(h);if(k)return k}throw new Error(`unrecognized argument type ${h.constructor.name}`)}}function l(h){return new h.constructor(h)}typeof c<"u"&&(c.exports={glWiretap:p,glExtensionWiretap:y}),typeof window<"u"&&(p.glExtensionWiretap=y,window.glWiretap=p)},{}],4:[function(i,c,d){function p(I){let S=new Array(I.length);for(let D=0;D<I.length;D++){let C=I[D];C.toArray?S[D]=C.toArray():S[D]=C}return S}function y(){let I=p(arguments),S=new Float32Array(this.output.x);for(let D=0;D<this.output.x;D++)this.thread.x=D,this.thread.y=0,this.thread.z=0,S[D]=this._fn.apply(this,I);return S}function v(){let I=p(arguments),S=new Array(this.output.y);for(let D=0;D<this.output.y;D++){let C=new Float32Array(this.output.x);for(let T=0;T<this.output.x;T++)this.thread.x=T,this.thread.y=D,this.thread.z=0,C[T]=this._fn.apply(this,I);S[D]=C}return S}function m(){let I=p(arguments);for(let S=0;S<this.output.y;S++)for(let D=0;D<this.output.x;D++)this.thread.x=D,this.thread.y=S,this.thread.z=0,this._fn.apply(this,I)}function l(){let I=p(arguments),S=new Array(this.output.z);for(let D=0;D<this.output.z;D++){let C=new Array(this.output.y);for(let T=0;T<this.output.y;T++){let _=new Float32Array(this.output.x);for(let k=0;k<this.output.x;k++)this.thread.x=k,this.thread.y=T,this.thread.z=D,_[k]=this._fn.apply(this,I);C[T]=_}S[D]=C}return S}function h(I){I.setOutput=C=>{I.output=o(C),I.graphical&&a(I)},I.toJSON=()=>{throw new Error("Not usable with gpuMock")},I.setConstants=C=>(I.constants=C,I),I.setGraphical=C=>(I.graphical=C,I),I.setCanvas=C=>(I.canvas=C,I),I.setContext=C=>(I.context=C,I),I.destroy=()=>{},I.validateSettings=()=>{},I.graphical&&I.output&&a(I),I.exec=function(){return new Promise((C,T)=>{try{C(I.apply(I,arguments))}catch(_){T(_)}})},I.getPixels=C=>{let{x:T,y:_}=I.output;return C?w(I._imageData.data,T,_):I._imageData.data.slice(0)},I.color=function(C,T,_,k){typeof k>"u"&&(k=1),C=Math.floor(C*255),T=Math.floor(T*255),_=Math.floor(_*255),k=Math.floor(k*255);let M=I.output.x,P=I.output.y,A=I.thread.x,f=P-I.thread.y-1,R=A+f*M;I._colorData[R*4+0]=C,I._colorData[R*4+1]=T,I._colorData[R*4+2]=_,I._colorData[R*4+3]=k};let S=()=>I,D=["setWarnVarUsage","setArgumentTypes","setTactic","setOptimizeFloatMemory","setDebug","setLoopMaxIterations","setConstantTypes","setFunctions","setNativeFunctions","setInjectedNative","setPipeline","setPrecision","setOutputToTexture","setImmutable","setStrictIntegers","setDynamicOutput","setHardcodeConstants","setDynamicArguments","setUseLegacyEncoder","setWarnVarUsage","addSubKernel"];for(let C=0;C<D.length;C++)I[D[C]]=S;return I}function a(I){let{x:S,y:D}=I.output;if(I.context&&I.context.createImageData){let C=new Uint8ClampedArray(S*D*4);I._imageData=I.context.createImageData(S,D),I._colorData=C}else{let C=new Uint8ClampedArray(S*D*4);I._imageData={data:C},I._colorData=C}}function o(I){let S=null;if(I.length)if(I.length===3){let[D,C,T]=I;S={x:D,y:C,z:T}}else if(I.length===2){let[D,C]=I;S={x:D,y:C}}else{let[D]=I;S={x:D}}else S=I;return S}function b(I,S={}){let D=S.output?o(S.output):null;function C(){return C.output.z?l.apply(C,arguments):C.output.y?C.graphical?m.apply(C,arguments):v.apply(C,arguments):y.apply(C,arguments)}return C._fn=I,C.constants=S.constants||null,C.context=S.context||null,C.canvas=S.canvas||null,C.graphical=S.graphical||!1,C._imageData=null,C._colorData=null,C.output=D,C.thread={x:0,y:0,z:0},h(C)}function w(I,S,D){let C=D/2|0,T=S*4,_=new Uint8ClampedArray(S*4),k=I.slice(0);for(let M=0;M<C;++M){let P=M*T,A=(D-M-1)*T;_.set(k.subarray(P,P+T)),k.copyWithin(P,A,A+T),k.set(_,A)}return k}c.exports={gpuMock:b}},{}],5:[function(i,c,d){let{utils:p}=i("./utils");function y(v,m){let l=m.toString();return new Function(`return function ${v} (${p.getArgumentNamesFromString(l).join(", ")}) {
        ${p.getFunctionBodyFromString(l)}
      }`)()}c.exports={alias:y}},{"./utils":114}],6:[function(i,c,d){let{FunctionNode:p}=i("../function-node");class y extends p{astFunction(m,l){if(!this.isRootKernel){l.push("function"),l.push(" "),l.push(this.name),l.push("(");for(let h=0;h<this.argumentNames.length;++h){let a=this.argumentNames[h];h>0&&l.push(", "),l.push("user_"),l.push(a)}l.push(`) {
`)}for(let h=0;h<m.body.body.length;++h)this.astGeneric(m.body.body[h],l),l.push(`
`);return this.isRootKernel||l.push(`}
`),l}astReturnStatement(m,l){let h=this.returnType||this.getType(m.argument);return this.returnType||(this.returnType=h),this.isRootKernel?(l.push(this.leadingReturnStatement),this.astGeneric(m.argument,l),l.push(`;
`),l.push(this.followingReturnStatement),l.push(`continue;
`)):this.isSubKernel?(l.push(`subKernelResult_${this.name} = `),this.astGeneric(m.argument,l),l.push(";"),l.push(`return subKernelResult_${this.name};`)):(l.push("return "),this.astGeneric(m.argument,l),l.push(";")),l}astLiteral(m,l){if(isNaN(m.value))throw this.astErrorOutput("Non-numeric literal not supported : "+m.value,m);return l.push(m.value),l}astBinaryExpression(m,l){return l.push("("),this.astGeneric(m.left,l),l.push(m.operator),this.astGeneric(m.right,l),l.push(")"),l}astIdentifierExpression(m,l){if(m.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",m);switch(m.name){case"Infinity":l.push("Infinity");break;default:this.constants&&this.constants.hasOwnProperty(m.name)?l.push("constants_"+m.name):l.push("user_"+m.name)}return l}astForStatement(m,l){if(m.type!=="ForStatement")throw this.astErrorOutput("Invalid for statement",m);let h=[],a=[],o=[],b=[],w=null;if(m.init){this.pushState("in-for-loop-init"),this.astGeneric(m.init,h);for(let I=0;I<h.length;I++)h[I].includes&&h[I].includes(",")&&(w=!1);this.popState("in-for-loop-init")}else w=!1;if(m.test?this.astGeneric(m.test,a):w=!1,m.update?this.astGeneric(m.update,o):w=!1,m.body&&(this.pushState("loop-body"),this.astGeneric(m.body,b),this.popState("loop-body")),w===null&&(w=this.isSafe(m.init)&&this.isSafe(m.test)),w)l.push(`for (${h.join("")};${a.join("")};${o.join("")}){
`),l.push(b.join("")),l.push(`}
`);else{let I=this.getInternalVariableName("safeI");h.length>0&&l.push(h.join(""),`;
`),l.push(`for (let ${I}=0;${I}<LOOP_MAX;${I}++){
`),a.length>0&&l.push(`if (!${a.join("")}) break;
`),l.push(b.join("")),l.push(`
${o.join("")};`),l.push(`}
`)}return l}astWhileStatement(m,l){if(m.type!=="WhileStatement")throw this.astErrorOutput("Invalid while statement",m);return l.push("for (let i = 0; i < LOOP_MAX; i++) {"),l.push("if ("),this.astGeneric(m.test,l),l.push(`) {
`),this.astGeneric(m.body,l),l.push(`} else {
`),l.push(`break;
`),l.push(`}
`),l.push(`}
`),l}astDoWhileStatement(m,l){if(m.type!=="DoWhileStatement")throw this.astErrorOutput("Invalid while statement",m);return l.push("for (let i = 0; i < LOOP_MAX; i++) {"),this.astGeneric(m.body,l),l.push("if (!"),this.astGeneric(m.test,l),l.push(`) {
`),l.push(`break;
`),l.push(`}
`),l.push(`}
`),l}astAssignmentExpression(m,l){let h=this.getDeclaration(m.left);if(h&&!h.assignable)throw this.astErrorOutput(`Variable ${m.left.name} is not assignable here`,m);return this.astGeneric(m.left,l),l.push(m.operator),this.astGeneric(m.right,l),l}astBlockStatement(m,l){if(this.isState("loop-body")){this.pushState("block-body");for(let h=0;h<m.body.length;h++)this.astGeneric(m.body[h],l);this.popState("block-body")}else{l.push(`{
`);for(let h=0;h<m.body.length;h++)this.astGeneric(m.body[h],l);l.push(`}
`)}return l}astVariableDeclaration(m,l){l.push(`${m.kind} `);let{declarations:h}=m;for(let a=0;a<h.length;a++){a>0&&l.push(",");let o=h[a],b=this.getDeclaration(o.id);b.valueType||(b.valueType=this.getType(o.init)),this.astGeneric(o,l)}return this.isState("in-for-loop-init")||l.push(";"),l}astIfStatement(m,l){return l.push("if ("),this.astGeneric(m.test,l),l.push(")"),m.consequent.type==="BlockStatement"?this.astGeneric(m.consequent,l):(l.push(` {
`),this.astGeneric(m.consequent,l),l.push(`
}
`)),m.alternate&&(l.push("else "),m.alternate.type==="BlockStatement"||m.alternate.type==="IfStatement"?this.astGeneric(m.alternate,l):(l.push(` {
`),this.astGeneric(m.alternate,l),l.push(`
}
`))),l}astSwitchStatement(m,l){let{discriminant:h,cases:a}=m;l.push("switch ("),this.astGeneric(h,l),l.push(`) {
`);for(let o=0;o<a.length;o++){if(a[o].test===null){l.push(`default:
`),this.astGeneric(a[o].consequent,l),a[o].consequent&&a[o].consequent.length>0&&l.push(`break;
`);continue}l.push("case "),this.astGeneric(a[o].test,l),l.push(`:
`),a[o].consequent&&a[o].consequent.length>0&&(this.astGeneric(a[o].consequent,l),l.push(`break;
`))}l.push(`
}`)}astThisExpression(m,l){return l.push("_this"),l}astMemberExpression(m,l){let{signature:h,type:a,property:o,xProperty:b,yProperty:w,zProperty:I,name:S,origin:D}=this.getMemberExpressionDetails(m);switch(h){case"this.thread.value":return l.push(`_this.thread.${S}`),l;case"this.output.value":switch(S){case"x":l.push("outputX");break;case"y":l.push("outputY");break;case"z":l.push("outputZ");break;default:throw this.astErrorOutput("Unexpected expression",m)}return l;case"value":throw this.astErrorOutput("Unexpected expression",m);case"value[]":case"value[][]":case"value[][][]":case"value.value":if(D==="Math")return l.push(Math[S]),l;switch(o){case"r":return l.push(`user_${S}[0]`),l;case"g":return l.push(`user_${S}[1]`),l;case"b":return l.push(`user_${S}[2]`),l;case"a":return l.push(`user_${S}[3]`),l}break;case"this.constants.value":case"this.constants.value[]":case"this.constants.value[][]":case"this.constants.value[][][]":break;case"fn()[]":return this.astGeneric(m.object,l),l.push("["),this.astGeneric(m.property,l),l.push("]"),l;case"fn()[][]":return this.astGeneric(m.object.object,l),l.push("["),this.astGeneric(m.object.property,l),l.push("]"),l.push("["),this.astGeneric(m.property,l),l.push("]"),l;default:throw this.astErrorOutput("Unexpected expression",m)}if(!m.computed)switch(a){case"Number":case"Integer":case"Float":case"Boolean":return l.push(`${D}_${S}`),l}let C=`${D}_${S}`;switch(a){case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":case"HTMLImageArray":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"HTMLImage":default:let T,_;if(D==="constants"){let k=this.constants[S];_=this.constantTypes[S]==="Input",T=_?k.size:null}else _=this.isInput(S),T=_?this.argumentSizes[this.argumentNames.indexOf(S)]:null;l.push(`${C}`),I&&w?_?(l.push("[("),this.astGeneric(I,l),l.push(`*${this.dynamicArguments?"(outputY * outputX)":T[1]*T[0]})+(`),this.astGeneric(w,l),l.push(`*${this.dynamicArguments?"outputX":T[0]})+`),this.astGeneric(b,l),l.push("]")):(l.push("["),this.astGeneric(I,l),l.push("]"),l.push("["),this.astGeneric(w,l),l.push("]"),l.push("["),this.astGeneric(b,l),l.push("]")):w?_?(l.push("[("),this.astGeneric(w,l),l.push(`*${this.dynamicArguments?"outputX":T[0]})+`),this.astGeneric(b,l),l.push("]")):(l.push("["),this.astGeneric(w,l),l.push("]"),l.push("["),this.astGeneric(b,l),l.push("]")):typeof b<"u"&&(l.push("["),this.astGeneric(b,l),l.push("]"))}return l}astCallExpression(m,l){if(m.type!=="CallExpression")throw this.astErrorOutput("Unknown CallExpression",m);let h=this.astMemberExpressionUnroll(m.callee);this.calledFunctions.indexOf(h)<0&&this.calledFunctions.push(h);let a=this.isAstMathFunction(m);this.onFunctionCall&&this.onFunctionCall(this.name,h,m.arguments),l.push(h),l.push("(");let o=this.lookupFunctionArgumentTypes(h)||[];for(let b=0;b<m.arguments.length;++b){let w=m.arguments[b],I=this.getType(w);o[b]||this.triggerImplyArgumentType(h,b,I,this),b>0&&l.push(", "),this.astGeneric(w,l)}return l.push(")"),l}astArrayExpression(m,l){let h=this.getType(m),a=m.elements.length,o=[];for(let b=0;b<a;++b){let w=[];this.astGeneric(m.elements[b],w),o.push(w.join(""))}switch(h){case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":l.push(`[${o.join(", ")}]`);break;default:l.push(`new Float32Array([${o.join(", ")}])`)}return l}astDebuggerStatement(m,l){return l.push("debugger;"),l}}c.exports={CPUFunctionNode:y}},{"../function-node":10}],7:[function(i,c,d){let{utils:p}=i("../../utils");function y(m,l){let h=[];for(let a in l){if(!l.hasOwnProperty(a))continue;let o=l[a],b=m[a];switch(o){case"Number":case"Integer":case"Float":case"Boolean":h.push(`${a}:${b}`);break;case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":h.push(`${a}:new ${b.constructor.name}(${JSON.stringify(Array.from(b))})`);break}}return`{ ${h.join()} }`}function v(m,l){let h=[],a=[],o=[],b=!/^function/.test(m.color.toString());if(h.push("  const { context, canvas, constants: incomingConstants } = settings;",`  const output = new Int32Array(${JSON.stringify(Array.from(m.output))});`,`  const _constantTypes = ${JSON.stringify(m.constantTypes)};`,`  const _constants = ${y(m.constants,m.constantTypes)};`),a.push("    constants: _constants,","    context,","    output,","    thread: {x: 0, y: 0, z: 0},"),m.graphical){h.push(`  const _imageData = context.createImageData(${m.output[0]}, ${m.output[1]});`),h.push(`  const _colorData = new Uint8ClampedArray(${m.output[0]} * ${m.output[1]} * 4);`);let S=p.flattenFunctionToString((b?"function ":"")+m.color.toString(),{thisLookup:C=>{switch(C){case"_colorData":return"_colorData";case"_imageData":return"_imageData";case"output":return"output";case"thread":return"this.thread"}return JSON.stringify(m[C])},findDependency:(C,T)=>null}),D=p.flattenFunctionToString((b?"function ":"")+m.getPixels.toString(),{thisLookup:C=>{switch(C){case"_colorData":return"_colorData";case"_imageData":return"_imageData";case"output":return"output";case"thread":return"this.thread"}return JSON.stringify(m[C])},findDependency:()=>null});a.push("    _imageData,","    _colorData,",`    color: ${S},`),o.push(`  kernel.getPixels = ${D};`)}let w=[],I=Object.keys(m.constantTypes);for(let S=0;S<I.length;S++)w.push(m.constantTypes[I]);if(m.argumentTypes.indexOf("HTMLImageArray")!==-1||w.indexOf("HTMLImageArray")!==-1){let S=p.flattenFunctionToString((b?"function ":"")+m._imageTo3DArray.toString(),{doNotDefine:["canvas"],findDependency:(D,C)=>D==="this"?(b?"function ":"")+m[C].toString():null,thisLookup:D=>{switch(D){case"canvas":return;case"context":return"context"}}});o.push(S),a.push("    _mediaTo2DArray,"),a.push("    _imageTo3DArray,")}else if(m.argumentTypes.indexOf("HTMLImage")!==-1||w.indexOf("HTMLImage")!==-1){let S=p.flattenFunctionToString((b?"function ":"")+m._mediaTo2DArray.toString(),{findDependency:(D,C)=>null,thisLookup:D=>{switch(D){case"canvas":return"settings.canvas";case"context":return"settings.context"}throw new Error("unhandled thisLookup")}});o.push(S),a.push("    _mediaTo2DArray,")}return`function(settings) {
      ${h.join(`
`)}
        for (const p in _constantTypes) {
          if (!_constantTypes.hasOwnProperty(p)) continue;
          const type = _constantTypes[p];
          switch (type) {
            case 'Number':
            case 'Integer':
            case 'Float':
            case 'Boolean':
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
              if (incomingConstants.hasOwnProperty(p)) {
                console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
              }
              continue;
          }
          if (!incomingConstants.hasOwnProperty(p)) {
            throw new Error('constant ' + p + ' not found');
          }
          _constants[p] = incomingConstants[p];
        }
        const kernel = (function() {
      ${m._kernelString}
        })
          .apply({ ${a.join(`
`)} });
        ${o.join(`
`)}
        return kernel;
      }`}c.exports={cpuKernelString:v}},{"../../utils":114}],8:[function(i,c,d){let{Kernel:p}=i("../kernel"),{FunctionBuilder:y}=i("../function-builder"),{CPUFunctionNode:v}=i("./function-node"),{utils:m}=i("../../utils"),{cpuKernelString:l}=i("./kernel-string");class h extends p{static getFeatures(){return this.features}static get features(){return Object.freeze({kernelMap:!0,isIntegerDivisionAccurate:!0})}static get isSupported(){return!0}static isContextMatch(o){return!1}static get mode(){return"cpu"}static nativeFunctionArguments(){return null}static nativeFunctionReturnType(){throw new Error(`Looking up native function return type not supported on ${this.name}`)}static combineKernels(o){return o}static getSignature(o,b){return"cpu"+(b.length>0?":"+b.join(","):"")}constructor(o,b){super(o,b),this.mergeSettings(o.settings||b),this._imageData=null,this._colorData=null,this._kernelString=null,this._prependedString=[],this.thread={x:0,y:0,z:0},this.translatedSources=null}initCanvas(){if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0)}initContext(){return this.canvas?this.canvas.getContext("2d"):null}initPlugins(o){return[]}validateSettings(o){if(!this.output||this.output.length===0){if(o.length!==1)throw new Error("Auto output only supported for kernels with only one input");let b=m.getVariableType(o[0],this.strictIntegers);if(b==="Array")this.output=m.getDimensions(b);else if(b==="NumberTexture"||b==="ArrayTexture(4)")this.output=o[0].output;else throw new Error("Auto output not supported for input type: "+b)}if(this.graphical&&this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.checkOutput()}translateSource(){if(this.leadingReturnStatement=this.output.length>1?"resultX[x] = ":"result[x] = ",this.subKernels){let b=[];for(let w=0;w<this.subKernels.length;w++){let{name:I}=this.subKernels[w];b.push(this.output.length>1?`resultX_${I}[x] = subKernelResult_${I};
`:`result_${I}[x] = subKernelResult_${I};
`)}this.followingReturnStatement=b.join("")}let o=y.fromKernel(this,v);this.translatedSources=o.getPrototypes("kernel"),!this.graphical&&!this.returnType&&(this.returnType=o.getKernelResultType())}build(){if(this.built)return;if(this.setupConstants(),this.setupArguments(arguments),this.validateSettings(arguments),this.translateSource(),this.graphical){let{canvas:b,output:w}=this;if(!b)throw new Error("no canvas available for using graphical output");let I=w[0],S=w[1]||1;b.width=I,b.height=S,this._imageData=this.context.createImageData(I,S),this._colorData=new Uint8ClampedArray(I*S*4)}let o=this.getKernelString();this.kernelString=o,this.debug&&(console.log("Function output:"),console.log(o));try{this.run=new Function([],o).bind(this)()}catch(b){console.error("An error occurred compiling the javascript: ",b)}this.buildSignature(arguments),this.built=!0}color(o,b,w,I){typeof I>"u"&&(I=1),o=Math.floor(o*255),b=Math.floor(b*255),w=Math.floor(w*255),I=Math.floor(I*255);let S=this.output[0],D=this.output[1],C=this.thread.x,T=D-this.thread.y-1,_=C+T*S;this._colorData[_*4+0]=o,this._colorData[_*4+1]=b,this._colorData[_*4+2]=w,this._colorData[_*4+3]=I}getKernelString(){if(this._kernelString!==null)return this._kernelString;let o=null,{translatedSources:b}=this;return b.length>1?b=b.filter(w=>/^function/.test(w)?w:(o=w,!1)):o=b.shift(),this._kernelString=`  const LOOP_MAX = ${this._getLoopMaxString()};
        ${this.injectedNative||""}
        const _this = this;
        ${this._resultKernelHeader()}
        ${this._processConstants()}
        return (${this.argumentNames.map(w=>"user_"+w).join(", ")}) => {
          ${this._prependedString.join("")}
          ${this._earlyThrows()}
          ${this._processArguments()}
          ${this.graphical?this._graphicalKernelBody(o):this._resultKernelBody(o)}
          ${b.length>0?b.join(`
`):""}
        };`}toString(){return l(this)}_getLoopMaxString(){return this.loopMaxIterations?` ${parseInt(this.loopMaxIterations)};`:" 1000;"}_processConstants(){if(!this.constants)return"";let o=[];for(let b in this.constants)switch(this.constantTypes[b]){case"HTMLCanvas":case"HTMLImage":case"HTMLVideo":o.push(`    const constants_${b} = this._mediaTo2DArray(this.constants.${b});
`);break;case"HTMLImageArray":o.push(`    const constants_${b} = this._imageTo3DArray(this.constants.${b});
`);break;case"Input":o.push(`    const constants_${b} = this.constants.${b}.value;
`);break;default:o.push(`    const constants_${b} = this.constants.${b};
`)}return o.join("")}_earlyThrows(){if(this.graphical||this.immutable||!this.pipeline)return"";let o=[];for(let w=0;w<this.argumentTypes.length;w++)this.argumentTypes[w]==="Array"&&o.push(this.argumentNames[w]);if(o.length===0)return"";let b=[];for(let w=0;w<o.length;w++){let I=o[w],S=this._mapSubKernels(D=>`user_${I} === result_${D.name}`).join(" || ");b.push(`user_${I} === result${S?` || ${S}`:""}`)}return`if (${b.join(" || ")}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`}_processArguments(){let o=[];for(let b=0;b<this.argumentTypes.length;b++){let w=`user_${this.argumentNames[b]}`;switch(this.argumentTypes[b]){case"HTMLCanvas":case"HTMLImage":case"HTMLVideo":o.push(`    ${w} = this._mediaTo2DArray(${w});
`);break;case"HTMLImageArray":o.push(`    ${w} = this._imageTo3DArray(${w});
`);break;case"Input":o.push(`    ${w} = ${w}.value;
`);break;case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"NumberTexture":case"MemoryOptimizedNumberTexture":o.push(`
          if (${w}.toArray) {
            if (!_this.textureCache) {
              _this.textureCache = [];
              _this.arrayCache = [];
            }
            const textureIndex = _this.textureCache.indexOf(${w});
            if (textureIndex !== -1) {
              ${w} = _this.arrayCache[textureIndex];
            } else {
              _this.textureCache.push(${w});
              ${w} = ${w}.toArray();
              _this.arrayCache.push(${w});
            }
          }`);break}}return o.join("")}_mediaTo2DArray(o){let b=this.canvas,w=o.width>0?o.width:o.videoWidth,I=o.height>0?o.height:o.videoHeight;b.width<w&&(b.width=w),b.height<I&&(b.height=I);let S=this.context;S.drawImage(o,0,0,w,I);let D=S.getImageData(0,0,w,I).data,C=new Array(I),T=0;for(let _=I-1;_>=0;_--){let k=C[_]=new Array(w);for(let M=0;M<w;M++){let P=new Float32Array(4);P[0]=D[T++]/255,P[1]=D[T++]/255,P[2]=D[T++]/255,P[3]=D[T++]/255,k[M]=P}}return C}getPixels(o){let[b,w]=this.output;return o?m.flipPixels(this._imageData.data,b,w):this._imageData.data.slice(0)}_imageTo3DArray(o){let b=new Array(o.length);for(let w=0;w<o.length;w++)b[w]=this._mediaTo2DArray(o[w]);return b}_resultKernelHeader(){if(this.graphical||this.immutable||!this.pipeline)return"";switch(this.output.length){case 1:return this._mutableKernel1DResults();case 2:return this._mutableKernel2DResults();case 3:return this._mutableKernel3DResults()}}_resultKernelBody(o){switch(this.output.length){case 1:return(!this.immutable&&this.pipeline?this._resultMutableKernel1DLoop(o):this._resultImmutableKernel1DLoop(o))+this._kernelOutput();case 2:return(!this.immutable&&this.pipeline?this._resultMutableKernel2DLoop(o):this._resultImmutableKernel2DLoop(o))+this._kernelOutput();case 3:return(!this.immutable&&this.pipeline?this._resultMutableKernel3DLoop(o):this._resultImmutableKernel3DLoop(o))+this._kernelOutput();default:throw new Error("unsupported size kernel")}}_graphicalKernelBody(o){switch(this.output.length){case 2:return this._graphicalKernel2DLoop(o)+this._graphicalOutput();default:throw new Error("unsupported size kernel")}}_graphicalOutput(){return`
          this._imageData.data.set(this._colorData);
          this.context.putImageData(this._imageData, 0, 0);
          return;`}_getKernelResultTypeConstructorString(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return"Float32Array";case"Array(2)":case"Array(3)":case"Array(4)":return"Array";default:if(this.graphical)return"Float32Array";throw new Error(`unhandled returnType ${this.returnType}`)}}_resultImmutableKernel1DLoop(o){let b=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const result = new ${b}(outputX);
          ${this._mapSubKernels(w=>`const result_${w.name} = new ${b}(outputX);
`).join("    ")}
          ${this._mapSubKernels(w=>`let subKernelResult_${w.name};
`).join("    ")}
          for (let x = 0; x < outputX; x++) {
            this.thread.x = x;
            this.thread.y = 0;
            this.thread.z = 0;
            ${o}
          }`}_mutableKernel1DResults(){let o=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const result = new ${o}(outputX);
          ${this._mapSubKernels(b=>`const result_${b.name} = new ${o}(outputX);
`).join("    ")}
          ${this._mapSubKernels(b=>`let subKernelResult_${b.name};
`).join("    ")}`}_resultMutableKernel1DLoop(o){return`  const outputX = _this.output[0];
          for (let x = 0; x < outputX; x++) {
            this.thread.x = x;
            this.thread.y = 0;
            this.thread.z = 0;
            ${o}
          }`}_resultImmutableKernel2DLoop(o){let b=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const result = new Array(outputY);
          ${this._mapSubKernels(w=>`const result_${w.name} = new Array(outputY);
`).join("    ")}
          ${this._mapSubKernels(w=>`let subKernelResult_${w.name};
`).join("    ")}
          for (let y = 0; y < outputY; y++) {
            this.thread.z = 0;
            this.thread.y = y;
            const resultX = result[y] = new ${b}(outputX);
            ${this._mapSubKernels(w=>`const resultX_${w.name} = result_${w.name}[y] = new ${b}(outputX);
`).join("")}
            for (let x = 0; x < outputX; x++) {
              this.thread.x = x;
              ${o}
            }
          }`}_mutableKernel2DResults(){let o=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const result = new Array(outputY);
          ${this._mapSubKernels(b=>`const result_${b.name} = new Array(outputY);
`).join("    ")}
          ${this._mapSubKernels(b=>`let subKernelResult_${b.name};
`).join("    ")}
          for (let y = 0; y < outputY; y++) {
            const resultX = result[y] = new ${o}(outputX);
            ${this._mapSubKernels(b=>`const resultX_${b.name} = result_${b.name}[y] = new ${o}(outputX);
`).join("")}
          }`}_resultMutableKernel2DLoop(o){let b=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          for (let y = 0; y < outputY; y++) {
            this.thread.z = 0;
            this.thread.y = y;
            const resultX = result[y];
            ${this._mapSubKernels(w=>`const resultX_${w.name} = result_${w.name}[y] = new ${b}(outputX);
`).join("")}
            for (let x = 0; x < outputX; x++) {
              this.thread.x = x;
              ${o}
            }
          }`}_graphicalKernel2DLoop(o){return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          for (let y = 0; y < outputY; y++) {
            this.thread.z = 0;
            this.thread.y = y;
            for (let x = 0; x < outputX; x++) {
              this.thread.x = x;
              ${o}
            }
          }`}_resultImmutableKernel3DLoop(o){let b=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const outputZ = _this.output[2];
          const result = new Array(outputZ);
          ${this._mapSubKernels(w=>`const result_${w.name} = new Array(outputZ);
`).join("    ")}
          ${this._mapSubKernels(w=>`let subKernelResult_${w.name};
`).join("    ")}
          for (let z = 0; z < outputZ; z++) {
            this.thread.z = z;
            const resultY = result[z] = new Array(outputY);
            ${this._mapSubKernels(w=>`const resultY_${w.name} = result_${w.name}[z] = new Array(outputY);
`).join("      ")}
            for (let y = 0; y < outputY; y++) {
              this.thread.y = y;
              const resultX = resultY[y] = new ${b}(outputX);
              ${this._mapSubKernels(w=>`const resultX_${w.name} = resultY_${w.name}[y] = new ${b}(outputX);
`).join("        ")}
              for (let x = 0; x < outputX; x++) {
                this.thread.x = x;
                ${o}
              }
            }
          }`}_mutableKernel3DResults(){let o=this._getKernelResultTypeConstructorString();return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const outputZ = _this.output[2];
          const result = new Array(outputZ);
          ${this._mapSubKernels(b=>`const result_${b.name} = new Array(outputZ);
`).join("    ")}
          ${this._mapSubKernels(b=>`let subKernelResult_${b.name};
`).join("    ")}
          for (let z = 0; z < outputZ; z++) {
            const resultY = result[z] = new Array(outputY);
            ${this._mapSubKernels(b=>`const resultY_${b.name} = result_${b.name}[z] = new Array(outputY);
`).join("      ")}
            for (let y = 0; y < outputY; y++) {
              const resultX = resultY[y] = new ${o}(outputX);
              ${this._mapSubKernels(b=>`const resultX_${b.name} = resultY_${b.name}[y] = new ${o}(outputX);
`).join("        ")}
            }
          }`}_resultMutableKernel3DLoop(o){return`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const outputZ = _this.output[2];
          for (let z = 0; z < outputZ; z++) {
            this.thread.z = z;
            const resultY = result[z];
            for (let y = 0; y < outputY; y++) {
              this.thread.y = y;
              const resultX = resultY[y];
              for (let x = 0; x < outputX; x++) {
                this.thread.x = x;
                ${o}
              }
            }
          }`}_kernelOutput(){return this.subKernels?`
    return {
            result: result,
            ${this.subKernels.map(o=>`${o.property}: result_${o.name}`).join(`,
      `)}
          };`:`
    return result;`}_mapSubKernels(o){return this.subKernels===null?[""]:this.subKernels.map(o)}destroy(o){o&&delete this.canvas}static destroyContext(o){}toJSON(){let o=super.toJSON();return o.functionNodes=y.fromKernel(this,v).toJSON(),o}setOutput(o){super.setOutput(o);let[b,w]=this.output;this.graphical&&(this._imageData=this.context.createImageData(b,w),this._colorData=new Uint8ClampedArray(b*w*4))}prependString(o){if(this._kernelString)throw new Error("Kernel already built");this._prependedString.push(o)}hasPrependString(o){return this._prependedString.indexOf(o)>-1}}c.exports={CPUKernel:h}},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(i,c,d){class p{static fromKernel(v,m,l){let{kernelArguments:h,kernelConstants:a,argumentNames:o,argumentSizes:b,argumentBitRatios:w,constants:I,constantBitRatios:S,debug:D,loopMaxIterations:C,nativeFunctions:T,output:_,optimizeFloatMemory:k,precision:M,plugins:P,source:A,subKernels:f,functions:R,leadingReturnStatement:N,followingReturnStatement:K,dynamicArguments:O,dynamicOutput:V}=v,j=new Array(h.length),z={};for(let ae=0;ae<h.length;ae++)j[ae]=h[ae].type;for(let ae=0;ae<a.length;ae++){let de=a[ae];z[de.name]=de.type}let q=(ae,de)=>be.needsArgumentType(ae,de),H=(ae,de,Te)=>{be.assignArgumentType(ae,de,Te)},U=(ae,de,Te)=>be.lookupReturnType(ae,de,Te),J=ae=>be.lookupFunctionArgumentTypes(ae),ee=(ae,de)=>be.lookupFunctionArgumentName(ae,de),Z=(ae,de)=>be.lookupFunctionArgumentBitRatio(ae,de),Y=(ae,de,Te,Fe)=>{be.assignArgumentType(ae,de,Te,Fe)},X=(ae,de,Te,Fe)=>{be.assignArgumentBitRatio(ae,de,Te,Fe)},ge=(ae,de,Te)=>{be.trackFunctionCall(ae,de,Te)},re=(ae,de)=>{let Te=[];for(let $e=0;$e<ae.params.length;$e++)Te.push(ae.params[$e].name);let Fe=new m(de,Object.assign({},se,{returnType:null,ast:ae,name:ae.id.name,argumentNames:Te,lookupReturnType:U,lookupFunctionArgumentTypes:J,lookupFunctionArgumentName:ee,lookupFunctionArgumentBitRatio:Z,needsArgumentType:q,assignArgumentType:H,triggerImplyArgumentType:Y,triggerImplyArgumentBitRatio:X,onFunctionCall:ge}));Fe.traceFunctionAST(ae),be.addFunctionNode(Fe)},se=Object.assign({isRootKernel:!1,onNestedFunction:re,lookupReturnType:U,lookupFunctionArgumentTypes:J,lookupFunctionArgumentName:ee,lookupFunctionArgumentBitRatio:Z,needsArgumentType:q,assignArgumentType:H,triggerImplyArgumentType:Y,triggerImplyArgumentBitRatio:X,onFunctionCall:ge,optimizeFloatMemory:k,precision:M,constants:I,constantTypes:z,constantBitRatios:S,debug:D,loopMaxIterations:C,output:_,plugins:P,dynamicArguments:O,dynamicOutput:V},l||{}),Ce=Object.assign({},se,{isRootKernel:!0,name:"kernel",argumentNames:o,argumentTypes:j,argumentSizes:b,argumentBitRatios:w,leadingReturnStatement:N,followingReturnStatement:K});if(typeof A=="object"&&A.functionNodes)return new p().fromJSON(A.functionNodes,m);let ie=new m(A,Ce),me=null;R&&(me=R.map(ae=>new m(ae.source,{returnType:ae.returnType,argumentTypes:ae.argumentTypes,output:_,plugins:P,constants:I,constantTypes:z,constantBitRatios:S,optimizeFloatMemory:k,precision:M,lookupReturnType:U,lookupFunctionArgumentTypes:J,lookupFunctionArgumentName:ee,lookupFunctionArgumentBitRatio:Z,needsArgumentType:q,assignArgumentType:H,triggerImplyArgumentType:Y,triggerImplyArgumentBitRatio:X,onFunctionCall:ge,onNestedFunction:re})));let ve=null;f&&(ve=f.map(ae=>{let{name:de,source:Te}=ae;return new m(Te,Object.assign({},se,{name:de,isSubKernel:!0,isRootKernel:!1}))}));let be=new p({kernel:v,rootNode:ie,functionNodes:me,nativeFunctions:T,subKernelNodes:ve});return be}constructor(v){if(v=v||{},this.kernel=v.kernel,this.rootNode=v.rootNode,this.functionNodes=v.functionNodes||[],this.subKernelNodes=v.subKernelNodes||[],this.nativeFunctions=v.nativeFunctions||[],this.functionMap={},this.nativeFunctionNames=[],this.lookupChain=[],this.functionNodeDependencies={},this.functionCalls={},this.rootNode&&(this.functionMap.kernel=this.rootNode),this.functionNodes)for(let m=0;m<this.functionNodes.length;m++)this.functionMap[this.functionNodes[m].name]=this.functionNodes[m];if(this.subKernelNodes)for(let m=0;m<this.subKernelNodes.length;m++)this.functionMap[this.subKernelNodes[m].name]=this.subKernelNodes[m];if(this.nativeFunctions)for(let m=0;m<this.nativeFunctions.length;m++){let l=this.nativeFunctions[m];this.nativeFunctionNames.push(l.name)}}addFunctionNode(v){if(!v.name)throw new Error("functionNode.name needs set");this.functionMap[v.name]=v,v.isRootKernel&&(this.rootNode=v)}traceFunctionCalls(v,m){if(v=v||"kernel",m=m||[],this.nativeFunctionNames.indexOf(v)>-1){let h=m.indexOf(v);if(h===-1)m.push(v);else{let a=m.splice(h,1)[0];m.push(a)}return m}let l=this.functionMap[v];if(l){let h=m.indexOf(v);if(h===-1){m.push(v),l.toString();for(let a=0;a<l.calledFunctions.length;++a)this.traceFunctionCalls(l.calledFunctions[a],m)}else{let a=m.splice(h,1)[0];m.push(a)}}return m}getPrototypeString(v){return this.getPrototypes(v).join(`
`)}getPrototypes(v){return this.rootNode&&this.rootNode.toString(),v?this.getPrototypesFromFunctionNames(this.traceFunctionCalls(v,[]).reverse()):this.getPrototypesFromFunctionNames(Object.keys(this.functionMap))}getStringFromFunctionNames(v){let m=[];for(let l=0;l<v.length;++l)this.functionMap[v[l]]&&m.push(this.functionMap[v[l]].toString());return m.join(`
`)}getPrototypesFromFunctionNames(v){let m=[];for(let l=0;l<v.length;++l){let h=v[l],a=this.nativeFunctionNames.indexOf(h);if(a>-1){m.push(this.nativeFunctions[a].source);continue}let o=this.functionMap[h];o&&m.push(o.toString())}return m}toJSON(){return this.traceFunctionCalls(this.rootNode.name).reverse().map(v=>{let m=this.nativeFunctions.indexOf(v);if(m>-1)return{name:v,source:this.nativeFunctions[m].source};if(this.functionMap[v])return this.functionMap[v].toJSON();throw new Error(`function ${v} not found`)})}fromJSON(v,m){this.functionMap={};for(let l=0;l<v.length;l++){let h=v[l];this.functionMap[h.settings.name]=new m(h.ast,h.settings)}return this}getString(v){return v?this.getStringFromFunctionNames(this.traceFunctionCalls(v).reverse()):this.getStringFromFunctionNames(Object.keys(this.functionMap))}lookupReturnType(v,m,l){if(m.type!=="CallExpression")throw new Error(`expected ast type of "CallExpression", but is ${m.type}`);if(this._isNativeFunction(v))return this._lookupNativeFunctionReturnType(v);if(this._isFunction(v)){let h=this._getFunction(v);if(h.returnType)return h.returnType;{for(let o=0;o<this.lookupChain.length;o++)if(this.lookupChain[o].ast===m){if(h.argumentTypes.length===0&&m.arguments.length>0){let b=m.arguments;for(let w=0;w<b.length;w++)this.lookupChain.push({name:l.name,ast:b[o],requestingNode:l}),h.argumentTypes[w]=l.getType(b[w]),this.lookupChain.pop();return h.returnType=h.getType(h.getJsAST())}throw new Error("circlical logic detected!")}this.lookupChain.push({name:l.name,ast:m,requestingNode:l});let a=h.getType(h.getJsAST());return this.lookupChain.pop(),h.returnType=a}}return null}_getFunction(v){return this._isFunction(v)||new Error(`Function ${v} not found`),this.functionMap[v]}_isFunction(v){return Boolean(this.functionMap[v])}_getNativeFunction(v){for(let m=0;m<this.nativeFunctions.length;m++)if(this.nativeFunctions[m].name===v)return this.nativeFunctions[m];return null}_isNativeFunction(v){return Boolean(this._getNativeFunction(v))}_lookupNativeFunctionReturnType(v){let m=this._getNativeFunction(v);if(m)return m.returnType;throw new Error(`Native function ${v} not found`)}lookupFunctionArgumentTypes(v){return this._isNativeFunction(v)?this._getNativeFunction(v).argumentTypes:this._isFunction(v)?this._getFunction(v).argumentTypes:null}lookupFunctionArgumentName(v,m){return this._getFunction(v).argumentNames[m]}lookupFunctionArgumentBitRatio(v,m){if(!this._isFunction(v))throw new Error("function not found");if(this.rootNode.name===v){let o=this.rootNode.argumentNames.indexOf(m);if(o!==-1)return this.rootNode.argumentBitRatios[o]}let l=this._getFunction(v),h=l.argumentNames.indexOf(m);if(h===-1)throw new Error("argument not found");let a=l.argumentBitRatios[h];if(typeof a!="number")throw new Error("argument bit ratio not found");return a}needsArgumentType(v,m){return this._isFunction(v)?!this._getFunction(v).argumentTypes[m]:!1}assignArgumentType(v,m,l,h){if(!this._isFunction(v))return;let a=this._getFunction(v);a.argumentTypes[m]||(a.argumentTypes[m]=l)}assignArgumentBitRatio(v,m,l,h){let a=this._getFunction(v);if(this._isNativeFunction(l))return null;let o=this._getFunction(l),b=a.argumentNames.indexOf(m);if(b===-1)throw new Error(`Argument ${m} not found in arguments from function ${v}`);let w=a.argumentBitRatios[b];if(typeof w!="number")throw new Error(`Bit ratio for argument ${m} not found in function ${v}`);o.argumentBitRatios||(o.argumentBitRatios=new Array(o.argumentNames.length));let I=o.argumentBitRatios[b];if(typeof I=="number"){if(I!==w)throw new Error(`Incompatible bit ratio found at function ${v} at argument ${m}`);return I}return o.argumentBitRatios[b]=w,w}trackFunctionCall(v,m,l){this.functionNodeDependencies[v]||(this.functionNodeDependencies[v]=new Set,this.functionCalls[v]=[]),this.functionNodeDependencies[v].add(m),this.functionCalls[v].push(l)}getKernelResultType(){return this.rootNode.returnType||this.rootNode.getType(this.rootNode.ast)}getSubKernelResultType(v){let m=this.subKernelNodes[v],l=!1;for(let h=0;h<this.rootNode.functionCalls.length;h++)this.rootNode.functionCalls[h].ast.callee.name===m.name&&(l=!0);if(!l)throw new Error(`SubKernel ${m.name} never called by kernel`);return m.returnType||m.getType(m.getJsAST())}getReturnTypes(){let v={[this.rootNode.name]:this.rootNode.getType(this.rootNode.ast)},m=this.traceFunctionCalls(this.rootNode.name);for(let l=0;l<m.length;l++){let h=m[l],a=this.functionMap[h];v[h]=a.getType(a.ast)}return v}}c.exports={FunctionBuilder:p}},{}],10:[function(i,c,d){let p=i("acorn"),{utils:y}=i("../utils"),{FunctionTracer:v}=i("./function-tracer");class m{constructor(a,o){if(!a&&!o.ast)throw new Error("source parameter is missing");if(o=o||{},this.source=a,this.ast=null,this.name=typeof a=="string"?o.isRootKernel?"kernel":o.name||y.getFunctionNameFromString(a):null,this.calledFunctions=[],this.constants={},this.constantTypes={},this.constantBitRatios={},this.isRootKernel=!1,this.isSubKernel=!1,this.debug=null,this.functions=null,this.identifiers=null,this.contexts=null,this.functionCalls=null,this.states=[],this.needsArgumentType=null,this.assignArgumentType=null,this.lookupReturnType=null,this.lookupFunctionArgumentTypes=null,this.lookupFunctionArgumentBitRatio=null,this.triggerImplyArgumentType=null,this.triggerImplyArgumentBitRatio=null,this.onNestedFunction=null,this.onFunctionCall=null,this.optimizeFloatMemory=null,this.precision=null,this.loopMaxIterations=null,this.argumentNames=typeof this.source=="string"?y.getArgumentNamesFromString(this.source):null,this.argumentTypes=[],this.argumentSizes=[],this.argumentBitRatios=null,this.returnType=null,this.output=[],this.plugins=null,this.leadingReturnStatement=null,this.followingReturnStatement=null,this.dynamicOutput=null,this.dynamicArguments=null,this.strictTypingChecking=!1,this.fixIntegerDivisionAccuracy=null,o)for(let b in o)!o.hasOwnProperty(b)||!this.hasOwnProperty(b)||(this[b]=o[b]);this.literalTypes={},this.validate(),this._string=null,this._internalVariableNames={}}validate(){if(typeof this.source!="string"&&!this.ast)throw new Error("this.source not a string");if(!this.ast&&!y.isFunctionString(this.source))throw new Error("this.source not a function string");if(!this.name)throw new Error("this.name could not be set");if(this.argumentTypes.length>0&&this.argumentTypes.length!==this.argumentNames.length)throw new Error(`argumentTypes count of ${this.argumentTypes.length} exceeds ${this.argumentNames.length}`);if(this.output.length<1)throw new Error("this.output is not big enough")}isIdentifierConstant(a){return this.constants?this.constants.hasOwnProperty(a):!1}isInput(a){return this.argumentTypes[this.argumentNames.indexOf(a)]==="Input"}pushState(a){this.states.push(a)}popState(a){if(this.state!==a)throw new Error(`Cannot popState ${a} when in ${this.state}`);this.states.pop()}isState(a){return this.state===a}get state(){return this.states[this.states.length-1]}astMemberExpressionUnroll(a){if(a.type==="Identifier")return a.name;if(a.type==="ThisExpression")return"this";if(a.type==="MemberExpression"&&a.object&&a.property)return a.object.hasOwnProperty("name")&&a.object.name!=="Math"?this.astMemberExpressionUnroll(a.property):this.astMemberExpressionUnroll(a.object)+"."+this.astMemberExpressionUnroll(a.property);if(a.hasOwnProperty("expressions")){let o=a.expressions[0];if(o.type==="Literal"&&o.value===0&&a.expressions.length===2)return this.astMemberExpressionUnroll(a.expressions[1])}throw this.astErrorOutput("Unknown astMemberExpressionUnroll",a)}getJsAST(a){if(this.ast)return this.ast;if(typeof this.source=="object")return this.traceFunctionAST(this.source),this.ast=this.source;if(a=a||p,a===null)throw new Error("Missing JS to AST parser");let o=Object.freeze(a.parse(`const parser_${this.name} = ${this.source};`,{locations:!0})),b=o.body[0].declarations[0].init;if(this.traceFunctionAST(b),!o)throw new Error("Failed to parse JS code");return this.ast=b}traceFunctionAST(a){let{contexts:o,declarations:b,functions:w,identifiers:I,functionCalls:S}=new v(a);this.contexts=o,this.identifiers=I,this.functionCalls=S,this.functions=w;for(let D=0;D<b.length;D++){let C=b[D],{ast:T,inForLoopInit:_,inForLoopTest:k}=C,{init:M}=T,P=this.getDependencies(M),A=null;if(_&&k)A="Integer";else if(M){let f=this.getType(M);switch(f){case"Integer":case"Float":case"Number":M.type==="MemberExpression"?A=f:A="Number";break;case"LiteralInteger":A="Number";break;default:A=f}}C.valueType=A,C.dependencies=P,C.isSafe=this.isSafeDependencies(P)}for(let D=0;D<w.length;D++)this.onNestedFunction(w[D],this.source)}getDeclaration(a){for(let o=0;o<this.identifiers.length;o++){let b=this.identifiers[o];if(a===b.ast)return b.declaration}return null}getVariableType(a){if(a.type!=="Identifier")throw new Error(`ast of ${a.type} not "Identifier"`);let o=null,b=this.argumentNames.indexOf(a.name);if(b===-1){let w=this.getDeclaration(a);if(w)return w.valueType}else{let w=this.argumentTypes[b];w&&(o=w)}if(!o&&this.strictTypingChecking)throw new Error(`Declaration of ${name} not found`);return o}getLookupType(a){if(!l.hasOwnProperty(a))throw new Error(`unknown typeLookupMap ${a}`);return l[a]}getConstantType(a){if(this.constantTypes[a]){let o=this.constantTypes[a];return o==="Float"?"Number":o}throw new Error(`Type for constant "${a}" not declared`)}toString(){return this._string?this._string:this._string=this.astGeneric(this.getJsAST(),[]).join("").trim()}toJSON(){let a={source:this.source,name:this.name,constants:this.constants,constantTypes:this.constantTypes,isRootKernel:this.isRootKernel,isSubKernel:this.isSubKernel,debug:this.debug,output:this.output,loopMaxIterations:this.loopMaxIterations,argumentNames:this.argumentNames,argumentTypes:this.argumentTypes,argumentSizes:this.argumentSizes,returnType:this.returnType,leadingReturnStatement:this.leadingReturnStatement,followingReturnStatement:this.followingReturnStatement};return{ast:this.ast,settings:a}}getType(a){if(Array.isArray(a))return this.getType(a[a.length-1]);switch(a.type){case"BlockStatement":return this.getType(a.body);case"ArrayExpression":switch(this.getType(a.elements[0])){case"Array(2)":case"Array(3)":case"Array(4)":return`Matrix(${a.elements.length})`}return`Array(${a.elements.length})`;case"Literal":let o=this.astKey(a);return this.literalTypes[o]?this.literalTypes[o]:Number.isInteger(a.value)?"LiteralInteger":a.value===!0||a.value===!1?"Boolean":"Number";case"AssignmentExpression":return this.getType(a.left);case"CallExpression":if(this.isAstMathFunction(a))return"Number";if(!a.callee||!a.callee.name){if(a.callee.type==="SequenceExpression"&&a.callee.expressions[a.callee.expressions.length-1].property.name){let D=a.callee.expressions[a.callee.expressions.length-1].property.name;return this.inferArgumentTypesIfNeeded(D,a.arguments),this.lookupReturnType(D,a,this)}if(this.getVariableSignature(a.callee,!0)==="this.color")return null;if(a.callee.type==="MemberExpression"&&a.callee.object&&a.callee.property&&a.callee.property.name&&a.arguments){let D=a.callee.property.name;return this.inferArgumentTypesIfNeeded(D,a.arguments),this.lookupReturnType(D,a,this)}throw this.astErrorOutput("Unknown call expression",a)}if(a.callee&&a.callee.name){let D=a.callee.name;return this.inferArgumentTypesIfNeeded(D,a.arguments),this.lookupReturnType(D,a,this)}throw this.astErrorOutput(`Unhandled getType Type "${a.type}"`,a);case"LogicalExpression":return"Boolean";case"BinaryExpression":switch(a.operator){case"%":case"/":if(this.fixIntegerDivisionAccuracy)return"Number";break;case">":case"<":return"Boolean";case"&":case"|":case"^":case"<<":case">>":case">>>":return"Integer"}let b=this.getType(a.left);if(this.isState("skip-literal-correction"))return b;if(b==="LiteralInteger"){let D=this.getType(a.right);return D==="LiteralInteger"?a.left.value%1===0?"Integer":"Float":D}return l[b]||b;case"UpdateExpression":return this.getType(a.argument);case"UnaryExpression":return a.operator==="~"?"Integer":this.getType(a.argument);case"VariableDeclaration":{let D=a.declarations,C;for(let T=0;T<D.length;T++){let _=D[T];C=this.getType(_)}if(!C)throw this.astErrorOutput("Unable to find type for declaration",a);return C}case"VariableDeclarator":let w=this.getDeclaration(a.id);if(!w)throw this.astErrorOutput("Unable to find declarator",a);if(!w.valueType)throw this.astErrorOutput("Unable to find declarator valueType",a);return w.valueType;case"Identifier":if(a.name==="Infinity")return"Number";if(this.isAstVariable(a)&&this.getVariableSignature(a)==="value")return this.getCheckVariableType(a);let I=this.findIdentifierOrigin(a);return I&&I.init?this.getType(I.init):null;case"ReturnStatement":return this.getType(a.argument);case"MemberExpression":if(this.isAstMathFunction(a)){switch(a.property.name){case"ceil":return"Integer";case"floor":return"Integer";case"round":return"Integer"}return"Number"}if(this.isAstVariable(a)){switch(this.getVariableSignature(a)){case"value[]":return this.getLookupType(this.getCheckVariableType(a.object));case"value[][]":return this.getLookupType(this.getCheckVariableType(a.object.object));case"value[][][]":return this.getLookupType(this.getCheckVariableType(a.object.object.object));case"value[][][][]":return this.getLookupType(this.getCheckVariableType(a.object.object.object.object));case"value.thread.value":case"this.thread.value":return"Integer";case"this.output.value":return this.dynamicOutput?"Integer":"LiteralInteger";case"this.constants.value":return this.getConstantType(a.property.name);case"this.constants.value[]":return this.getLookupType(this.getConstantType(a.object.property.name));case"this.constants.value[][]":return this.getLookupType(this.getConstantType(a.object.object.property.name));case"this.constants.value[][][]":return this.getLookupType(this.getConstantType(a.object.object.object.property.name));case"this.constants.value[][][][]":return this.getLookupType(this.getConstantType(a.object.object.object.object.property.name));case"fn()[]":case"fn()[][]":case"fn()[][][]":return this.getLookupType(this.getType(a.object));case"value.value":if(this.isAstMathVariable(a))return"Number";switch(a.property.name){case"r":case"g":case"b":case"a":return this.getLookupType(this.getCheckVariableType(a.object))}case"[][]":return"Number"}throw this.astErrorOutput("Unhandled getType MemberExpression",a)}throw this.astErrorOutput("Unhandled getType MemberExpression",a);case"ConditionalExpression":return this.getType(a.consequent);case"FunctionDeclaration":case"FunctionExpression":let S=this.findLastReturn(a.body);return S?this.getType(S):null;case"IfStatement":return this.getType(a.consequent);case"SequenceExpression":return this.getType(a.expressions[a.expressions.length-1]);default:throw this.astErrorOutput(`Unhandled getType Type "${a.type}"`,a)}}getCheckVariableType(a){let o=this.getVariableType(a);if(!o)throw this.astErrorOutput(`${a.type} is not defined`,a);return o}inferArgumentTypesIfNeeded(a,o){for(let b=0;b<o.length;b++){if(!this.needsArgumentType(a,b))continue;let w=this.getType(o[b]);if(!w)throw this.astErrorOutput(`Unable to infer argument ${b}`,o[b]);this.assignArgumentType(a,b,w)}}isAstMathVariable(a){let o=["E","PI","SQRT2","SQRT1_2","LN2","LN10","LOG2E","LOG10E"];return a.type==="MemberExpression"&&a.object&&a.object.type==="Identifier"&&a.object.name==="Math"&&a.property&&a.property.type==="Identifier"&&o.indexOf(a.property.name)>-1}isAstMathFunction(a){let o=["abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","expm1","exp","floor","fround","imul","log","log2","log10","log1p","max","min","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc"];return a.type==="CallExpression"&&a.callee&&a.callee.type==="MemberExpression"&&a.callee.object&&a.callee.object.type==="Identifier"&&a.callee.object.name==="Math"&&a.callee.property&&a.callee.property.type==="Identifier"&&o.indexOf(a.callee.property.name)>-1}isAstVariable(a){return a.type==="Identifier"||a.type==="MemberExpression"}isSafe(a){return this.isSafeDependencies(this.getDependencies(a))}isSafeDependencies(a){return a&&a.every?a.every(o=>o.isSafe):!0}getDependencies(a,o,b){if(o||(o=[]),!a)return null;if(Array.isArray(a)){for(let w=0;w<a.length;w++)this.getDependencies(a[w],o,b);return o}switch(a.type){case"AssignmentExpression":return this.getDependencies(a.left,o,b),this.getDependencies(a.right,o,b),o;case"ConditionalExpression":return this.getDependencies(a.test,o,b),this.getDependencies(a.alternate,o,b),this.getDependencies(a.consequent,o,b),o;case"Literal":o.push({origin:"literal",value:a.value,isSafe:b===!0?!1:a.value>-1/0&&a.value<1/0&&!isNaN(a.value)});break;case"VariableDeclarator":return this.getDependencies(a.init,o,b);case"Identifier":let w=this.getDeclaration(a);if(w)o.push({name:a.name,origin:"declaration",isSafe:b?!1:this.isSafeDependencies(w.dependencies)});else if(this.argumentNames.indexOf(a.name)>-1)o.push({name:a.name,origin:"argument",isSafe:!1});else if(this.strictTypingChecking)throw new Error(`Cannot find identifier origin "${a.name}"`);break;case"FunctionDeclaration":return this.getDependencies(a.body.body[a.body.body.length-1],o,b);case"ReturnStatement":return this.getDependencies(a.argument,o);case"BinaryExpression":case"LogicalExpression":return b=a.operator==="/"||a.operator==="*",this.getDependencies(a.left,o,b),this.getDependencies(a.right,o,b),o;case"UnaryExpression":case"UpdateExpression":return this.getDependencies(a.argument,o,b);case"VariableDeclaration":return this.getDependencies(a.declarations,o,b);case"ArrayExpression":return o.push({origin:"declaration",isSafe:!0}),o;case"CallExpression":return o.push({origin:"function",isSafe:!0}),o;case"MemberExpression":let I=this.getMemberExpressionDetails(a);switch(I.signature){case"value[]":this.getDependencies(a.object,o,b);break;case"value[][]":this.getDependencies(a.object.object,o,b);break;case"value[][][]":this.getDependencies(a.object.object.object,o,b);break;case"this.output.value":this.dynamicOutput&&o.push({name:I.name,origin:"output",isSafe:!1});break}if(I)return I.property&&this.getDependencies(I.property,o,b),I.xProperty&&this.getDependencies(I.xProperty,o,b),I.yProperty&&this.getDependencies(I.yProperty,o,b),I.zProperty&&this.getDependencies(I.zProperty,o,b),o;case"SequenceExpression":return this.getDependencies(a.expressions,o,b);default:throw this.astErrorOutput(`Unhandled type ${a.type} in getDependencies`,a)}return o}getVariableSignature(a,o){if(!this.isAstVariable(a))throw new Error(`ast of type "${a.type}" is not a variable signature`);if(a.type==="Identifier")return"value";let b=[];for(;a;)a.computed?b.push("[]"):a.type==="ThisExpression"?b.unshift("this"):a.property&&a.property.name?a.property.name==="x"||a.property.name==="y"||a.property.name==="z"?b.unshift(o?"."+a.property.name:".value"):a.property.name==="constants"||a.property.name==="thread"||a.property.name==="output"?b.unshift("."+a.property.name):b.unshift(o?"."+a.property.name:".value"):a.name?b.unshift(o?a.name:"value"):a.callee&&a.callee.name?b.unshift(o?a.callee.name+"()":"fn()"):a.elements?b.unshift("[]"):b.unshift("unknown"),a=a.object;let w=b.join("");return o||["value","value[]","value[][]","value[][][]","value[][][][]","value.value","value.thread.value","this.thread.value","this.output.value","this.constants.value","this.constants.value[]","this.constants.value[][]","this.constants.value[][][]","this.constants.value[][][][]","fn()[]","fn()[][]","fn()[][][]","[][]"].indexOf(w)>-1?w:null}build(){return this.toString().length>0}astGeneric(a,o){if(a===null)throw this.astErrorOutput("NULL ast",a);if(Array.isArray(a)){for(let b=0;b<a.length;b++)this.astGeneric(a[b],o);return o}switch(a.type){case"FunctionDeclaration":return this.astFunctionDeclaration(a,o);case"FunctionExpression":return this.astFunctionExpression(a,o);case"ReturnStatement":return this.astReturnStatement(a,o);case"Literal":return this.astLiteral(a,o);case"BinaryExpression":return this.astBinaryExpression(a,o);case"Identifier":return this.astIdentifierExpression(a,o);case"AssignmentExpression":return this.astAssignmentExpression(a,o);case"ExpressionStatement":return this.astExpressionStatement(a,o);case"EmptyStatement":return this.astEmptyStatement(a,o);case"BlockStatement":return this.astBlockStatement(a,o);case"IfStatement":return this.astIfStatement(a,o);case"SwitchStatement":return this.astSwitchStatement(a,o);case"BreakStatement":return this.astBreakStatement(a,o);case"ContinueStatement":return this.astContinueStatement(a,o);case"ForStatement":return this.astForStatement(a,o);case"WhileStatement":return this.astWhileStatement(a,o);case"DoWhileStatement":return this.astDoWhileStatement(a,o);case"VariableDeclaration":return this.astVariableDeclaration(a,o);case"VariableDeclarator":return this.astVariableDeclarator(a,o);case"ThisExpression":return this.astThisExpression(a,o);case"SequenceExpression":return this.astSequenceExpression(a,o);case"UnaryExpression":return this.astUnaryExpression(a,o);case"UpdateExpression":return this.astUpdateExpression(a,o);case"LogicalExpression":return this.astLogicalExpression(a,o);case"MemberExpression":return this.astMemberExpression(a,o);case"CallExpression":return this.astCallExpression(a,o);case"ArrayExpression":return this.astArrayExpression(a,o);case"DebuggerStatement":return this.astDebuggerStatement(a,o);case"ConditionalExpression":return this.astConditionalExpression(a,o)}throw this.astErrorOutput("Unknown ast type : "+a.type,a)}astErrorOutput(a,o){if(typeof this.source!="string")return new Error(a);let b=y.getAstString(this.source,o),w=this.source.substr(o.start).split(/\n/),I=w.length>0?w[w.length-1]:0;return new Error(`${a} on line ${w.length}, position ${I.length}:
 ${b}`)}astDebuggerStatement(a,o){return o}astConditionalExpression(a,o){if(a.type!=="ConditionalExpression")throw this.astErrorOutput("Not a conditional expression",a);return o.push("("),this.astGeneric(a.test,o),o.push("?"),this.astGeneric(a.consequent,o),o.push(":"),this.astGeneric(a.alternate,o),o.push(")"),o}astFunction(a,o){throw new Error(`"astFunction" not defined on ${this.constructor.name}`)}astFunctionDeclaration(a,o){return this.isChildFunction(a)?o:this.astFunction(a,o)}astFunctionExpression(a,o){return this.isChildFunction(a)?o:this.astFunction(a,o)}isChildFunction(a){for(let o=0;o<this.functions.length;o++)if(this.functions[o]===a)return!0;return!1}astReturnStatement(a,o){return o}astLiteral(a,o){return this.literalTypes[this.astKey(a)]="Number",o}astBinaryExpression(a,o){return o}astIdentifierExpression(a,o){return o}astAssignmentExpression(a,o){return o}astExpressionStatement(a,o){return this.astGeneric(a.expression,o),o.push(";"),o}astEmptyStatement(a,o){return o}astBlockStatement(a,o){return o}astIfStatement(a,o){return o}astSwitchStatement(a,o){return o}astBreakStatement(a,o){return o.push("break;"),o}astContinueStatement(a,o){return o.push(`continue;
`),o}astForStatement(a,o){return o}astWhileStatement(a,o){return o}astDoWhileStatement(a,o){return o}astVariableDeclarator(a,o){return this.astGeneric(a.id,o),a.init!==null&&(o.push("="),this.astGeneric(a.init,o)),o}astThisExpression(a,o){return o}astSequenceExpression(a,o){let{expressions:b}=a,w=[];for(let I=0;I<b.length;I++){let S=b[I],D=[];this.astGeneric(S,D),w.push(D.join(""))}return w.length>1?o.push("(",w.join(","),")"):o.push(w[0]),o}astUnaryExpression(a,o){return this.checkAndUpconvertBitwiseUnary(a,o)||(a.prefix?(o.push(a.operator),this.astGeneric(a.argument,o)):(this.astGeneric(a.argument,o),o.push(a.operator))),o}checkAndUpconvertBitwiseUnary(a,o){}astUpdateExpression(a,o){return a.prefix?(o.push(a.operator),this.astGeneric(a.argument,o)):(this.astGeneric(a.argument,o),o.push(a.operator)),o}astLogicalExpression(a,o){return o.push("("),this.astGeneric(a.left,o),o.push(a.operator),this.astGeneric(a.right,o),o.push(")"),o}astMemberExpression(a,o){return o}astCallExpression(a,o){return o}astArrayExpression(a,o){return o}getMemberExpressionDetails(a){if(a.type!=="MemberExpression")throw this.astErrorOutput(`Expression ${a.type} not a MemberExpression`,a);let o=null,b=null,w=this.getVariableSignature(a);switch(w){case"value":return null;case"value.thread.value":case"this.thread.value":case"this.output.value":return{signature:w,type:"Integer",name:a.property.name};case"value[]":if(typeof a.object.name!="string")throw this.astErrorOutput("Unexpected expression",a);return o=a.object.name,{name:o,origin:"user",signature:w,type:this.getVariableType(a.object),xProperty:a.property};case"value[][]":if(typeof a.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",a);return o=a.object.object.name,{name:o,origin:"user",signature:w,type:this.getVariableType(a.object.object),yProperty:a.object.property,xProperty:a.property};case"value[][][]":if(typeof a.object.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",a);return o=a.object.object.object.name,{name:o,origin:"user",signature:w,type:this.getVariableType(a.object.object.object),zProperty:a.object.object.property,yProperty:a.object.property,xProperty:a.property};case"value[][][][]":if(typeof a.object.object.object.object.name!="string")throw this.astErrorOutput("Unexpected expression",a);return o=a.object.object.object.object.name,{name:o,origin:"user",signature:w,type:this.getVariableType(a.object.object.object.object),zProperty:a.object.object.property,yProperty:a.object.property,xProperty:a.property};case"value.value":if(typeof a.property.name!="string")throw this.astErrorOutput("Unexpected expression",a);if(this.isAstMathVariable(a))return o=a.property.name,{name:o,origin:"Math",type:"Number",signature:w};switch(a.property.name){case"r":case"g":case"b":case"a":return o=a.object.name,{name:o,property:a.property.name,origin:"user",signature:w,type:"Number"};default:throw this.astErrorOutput("Unexpected expression",a)}case"this.constants.value":if(typeof a.property.name!="string")throw this.astErrorOutput("Unexpected expression",a);if(o=a.property.name,b=this.getConstantType(o),!b)throw this.astErrorOutput("Constant has no type",a);return{name:o,type:b,origin:"constants",signature:w};case"this.constants.value[]":if(typeof a.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",a);if(o=a.object.property.name,b=this.getConstantType(o),!b)throw this.astErrorOutput("Constant has no type",a);return{name:o,type:b,origin:"constants",signature:w,xProperty:a.property};case"this.constants.value[][]":{if(typeof a.object.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",a);if(o=a.object.object.property.name,b=this.getConstantType(o),!b)throw this.astErrorOutput("Constant has no type",a);return{name:o,type:b,origin:"constants",signature:w,yProperty:a.object.property,xProperty:a.property}}case"this.constants.value[][][]":{if(typeof a.object.object.object.property.name!="string")throw this.astErrorOutput("Unexpected expression",a);if(o=a.object.object.object.property.name,b=this.getConstantType(o),!b)throw this.astErrorOutput("Constant has no type",a);return{name:o,type:b,origin:"constants",signature:w,zProperty:a.object.object.property,yProperty:a.object.property,xProperty:a.property}}case"fn()[]":case"fn()[][]":case"[][]":return{signature:w,property:a.property};default:throw this.astErrorOutput("Unexpected expression",a)}}findIdentifierOrigin(a){let o=[this.ast];for(;o.length>0;){let b=o[0];if(b.type==="VariableDeclarator"&&b.id&&b.id.name&&b.id.name===a.name)return b;if(o.shift(),b.argument)o.push(b.argument);else if(b.body)o.push(b.body);else if(b.declarations)o.push(b.declarations);else if(Array.isArray(b))for(let w=0;w<b.length;w++)o.push(b[w])}return null}findLastReturn(a){let o=[a||this.ast];for(;o.length>0;){let b=o.pop();if(b.type==="ReturnStatement")return b;if(b.type!=="FunctionDeclaration")if(b.argument)o.push(b.argument);else if(b.body)o.push(b.body);else if(b.declarations)o.push(b.declarations);else if(Array.isArray(b))for(let w=0;w<b.length;w++)o.push(b[w]);else b.consequent?o.push(b.consequent):b.cases&&o.push(b.cases)}return null}getInternalVariableName(a){return this._internalVariableNames.hasOwnProperty(a)||(this._internalVariableNames[a]=0),this._internalVariableNames[a]++,this._internalVariableNames[a]===1?a:a+this._internalVariableNames[a]}astKey(a,o=","){if(!a.start||!a.end)throw new Error("AST start and end needed");return`${a.start}${o}${a.end}`}}let l={Number:"Number",Float:"Float",Integer:"Integer",Array:"Number","Array(2)":"Number","Array(3)":"Number","Array(4)":"Number","Matrix(2)":"Number","Matrix(3)":"Number","Matrix(4)":"Number",Array2D:"Number",Array3D:"Number",Input:"Number",HTMLCanvas:"Array(4)",HTMLImage:"Array(4)",HTMLVideo:"Array(4)",HTMLImageArray:"Array(4)",NumberTexture:"Number",MemoryOptimizedNumberTexture:"Number","Array1D(2)":"Array(2)","Array1D(3)":"Array(3)","Array1D(4)":"Array(4)","Array2D(2)":"Array(2)","Array2D(3)":"Array(3)","Array2D(4)":"Array(4)","Array3D(2)":"Array(2)","Array3D(3)":"Array(3)","Array3D(4)":"Array(4)","ArrayTexture(1)":"Number","ArrayTexture(2)":"Array(2)","ArrayTexture(3)":"Array(3)","ArrayTexture(4)":"Array(4)"};c.exports={FunctionNode:m}},{"../utils":114,"./function-tracer":11,acorn:1}],11:[function(i,c,d){let{utils:p}=i("../utils");function y(l){return l.length>0?l[l.length-1]:null}let v={trackIdentifiers:"trackIdentifiers",memberExpression:"memberExpression",inForLoopInit:"inForLoopInit"};class m{constructor(h){this.runningContexts=[],this.functionContexts=[],this.contexts=[],this.functionCalls=[],this.declarations=[],this.identifiers=[],this.functions=[],this.returnStatements=[],this.trackedIdentifiers=null,this.states=[],this.newFunctionContext(),this.scan(h)}isState(h){return this.states[this.states.length-1]===h}hasState(h){return this.states.indexOf(h)>-1}pushState(h){this.states.push(h)}popState(h){if(this.isState(h))this.states.pop();else throw new Error(`Cannot pop the non-active state "${h}"`)}get currentFunctionContext(){return y(this.functionContexts)}get currentContext(){return y(this.runningContexts)}newFunctionContext(){let h={"@contextType":"function"};this.contexts.push(h),this.functionContexts.push(h)}newContext(h){let a=Object.assign({"@contextType":"const/let"},this.currentContext);this.contexts.push(a),this.runningContexts.push(a),h();let{currentFunctionContext:o}=this;for(let b in o)!o.hasOwnProperty(b)||a.hasOwnProperty(b)||(a[b]=o[b]);return this.runningContexts.pop(),a}useFunctionContext(h){let a=y(this.functionContexts);this.runningContexts.push(a),h(),this.runningContexts.pop()}getIdentifiers(h){let a=this.trackedIdentifiers=[];return this.pushState(v.trackIdentifiers),h(),this.trackedIdentifiers=null,this.popState(v.trackIdentifiers),a}getDeclaration(h){let{currentContext:a,currentFunctionContext:o,runningContexts:b}=this,w=a[h]||o[h]||null;if(!w&&a===o&&b.length>0){let I=b[b.length-2];if(I[h])return I[h]}return w}scan(h){if(h){if(Array.isArray(h)){for(let a=0;a<h.length;a++)this.scan(h[a]);return}switch(h.type){case"Program":this.useFunctionContext(()=>{this.scan(h.body)});break;case"BlockStatement":this.newContext(()=>{this.scan(h.body)});break;case"AssignmentExpression":case"LogicalExpression":this.scan(h.left),this.scan(h.right);break;case"BinaryExpression":this.scan(h.left),this.scan(h.right);break;case"UpdateExpression":if(h.operator==="++"){let a=this.getDeclaration(h.argument.name);a&&(a.suggestedType="Integer")}this.scan(h.argument);break;case"UnaryExpression":this.scan(h.argument);break;case"VariableDeclaration":h.kind==="var"?this.useFunctionContext(()=>{h.declarations=p.normalizeDeclarations(h),this.scan(h.declarations)}):(h.declarations=p.normalizeDeclarations(h),this.scan(h.declarations));break;case"VariableDeclarator":{let{currentContext:a}=this,o=this.hasState(v.inForLoopInit),b={ast:h,context:a,name:h.id.name,origin:"declaration",inForLoopInit:o,inForLoopTest:null,assignable:a===this.currentFunctionContext||!o&&!a.hasOwnProperty(h.id.name),suggestedType:null,valueType:null,dependencies:null,isSafe:null};a[h.id.name]||(a[h.id.name]=b),this.declarations.push(b),this.scan(h.id),this.scan(h.init);break}case"FunctionExpression":case"FunctionDeclaration":this.runningContexts.length===0?this.scan(h.body):this.functions.push(h);break;case"IfStatement":this.scan(h.test),this.scan(h.consequent),h.alternate&&this.scan(h.alternate);break;case"ForStatement":{let a,o=this.newContext(()=>{this.pushState(v.inForLoopInit),this.scan(h.init),this.popState(v.inForLoopInit),a=this.getIdentifiers(()=>{this.scan(h.test)}),this.scan(h.update),this.newContext(()=>{this.scan(h.body)})});if(a)for(let b in o)b!=="@contextType"&&a.indexOf(b)>-1&&(o[b].inForLoopTest=!0);break}case"DoWhileStatement":case"WhileStatement":this.newContext(()=>{this.scan(h.body),this.scan(h.test)});break;case"Identifier":{this.isState(v.trackIdentifiers)&&this.trackedIdentifiers.push(h.name),this.identifiers.push({context:this.currentContext,declaration:this.getDeclaration(h.name),ast:h});break}case"ReturnStatement":this.returnStatements.push(h),this.scan(h.argument);break;case"MemberExpression":this.pushState(v.memberExpression),this.scan(h.object),this.scan(h.property),this.popState(v.memberExpression);break;case"ExpressionStatement":this.scan(h.expression);break;case"SequenceExpression":this.scan(h.expressions);break;case"CallExpression":this.functionCalls.push({context:this.currentContext,ast:h}),this.scan(h.arguments);break;case"ArrayExpression":this.scan(h.elements);break;case"ConditionalExpression":this.scan(h.test),this.scan(h.alternate),this.scan(h.consequent);break;case"SwitchStatement":this.scan(h.discriminant),this.scan(h.cases);break;case"SwitchCase":this.scan(h.test),this.scan(h.consequent);break;case"ThisExpression":case"Literal":case"DebuggerStatement":case"EmptyStatement":case"BreakStatement":case"ContinueStatement":break;default:throw new Error(`unhandled type "${h.type}"`)}}}}c.exports={FunctionTracer:m}},{"../utils":114}],12:[function(i,c,d){let{glWiretap:p}=i("gl-wiretap"),{utils:y}=i("../../utils");function v(b){return b.toString().replace("=>","").replace(/^function /,"").replace(/utils[.]/g,"/*utils.*/")}function m(b,w,I,S,D){I.built||I.build.apply(I,w),w=w?Array.from(w).map(ie=>{switch(typeof ie){case"boolean":return new Boolean(ie);case"number":return new Number(ie);default:return ie}}):null;let C=[],T=[],_=p(I.context,{useTrackablePrimitives:!0,onReadPixels:ie=>{if(re.subKernels){if(!k)T.push(`    const result = { result: ${l(ie,re)} };`),k=!0;else{let me=re.subKernels[M++].property;T.push(`    result${isNaN(me)?"."+me:`[${me}]`} = ${l(ie,re)};`)}M===re.subKernels.length&&T.push("    return result;");return}ie?T.push(`    return ${l(ie,re)};`):T.push("    return null;")},onUnrecognizedArgumentLookup:ie=>{let me=o(ie,re.kernelArguments,[],_,C);return me||o(ie,re.kernelConstants,O?Object.keys(O).map(be=>O[be]):[],_,C)||null}}),k=!1,M=0,{source:P,canvas:A,output:f,pipeline:R,graphical:N,loopMaxIterations:K,constants:O,optimizeFloatMemory:V,precision:j,fixIntegerDivisionAccuracy:z,functions:q,nativeFunctions:H,subKernels:U,immutable:J,argumentTypes:ee,constantTypes:Z,kernelArguments:Y,kernelConstants:X,tactic:ge}=I,re=new b(P,{canvas:A,context:_,checkContext:!1,output:f,pipeline:R,graphical:N,loopMaxIterations:K,constants:O,optimizeFloatMemory:V,precision:j,fixIntegerDivisionAccuracy:z,functions:q,nativeFunctions:H,subKernels:U,immutable:J,argumentTypes:ee,constantTypes:Z,tactic:ge}),se=[];if(_.setIndent(2),re.build.apply(re,w),se.push(_.toString()),_.reset(),re.kernelArguments.forEach((ie,me)=>{switch(ie.type){case"Integer":case"Boolean":case"Number":case"Float":case"Array":case"Array(2)":case"Array(3)":case"Array(4)":case"HTMLCanvas":case"HTMLImage":case"HTMLVideo":_.insertVariable(`uploadValue_${ie.name}`,ie.uploadValue);break;case"HTMLImageArray":for(let ve=0;ve<w[me].length;ve++){let be=w[me];_.insertVariable(`uploadValue_${ie.name}[${ve}]`,be[ve])}break;case"Input":_.insertVariable(`uploadValue_${ie.name}`,ie.uploadValue);break;case"MemoryOptimizedNumberTexture":case"NumberTexture":case"Array1D(2)":case"Array1D(3)":case"Array1D(4)":case"Array2D(2)":case"Array2D(3)":case"Array2D(4)":case"Array3D(2)":case"Array3D(3)":case"Array3D(4)":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":_.insertVariable(`uploadValue_${ie.name}`,w[me].texture);break;default:throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${ie.type}`)}}),se.push("/** start of injected functions **/"),se.push(`function ${v(y.flattenTo)}`),se.push(`function ${v(y.flatten2dArrayTo)}`),se.push(`function ${v(y.flatten3dArrayTo)}`),se.push(`function ${v(y.flatten4dArrayTo)}`),se.push(`function ${v(y.isArray)}`),re.renderOutput!==re.renderTexture&&re.formatValues&&se.push(`  const renderOutput = function ${v(re.formatValues)};`),se.push("/** end of injected functions **/"),se.push(`  const innerKernel = function (${re.kernelArguments.map(ie=>ie.varName).join(", ")}) {`),_.setIndent(4),re.run.apply(re,w),re.renderKernels?re.renderKernels():re.renderOutput&&re.renderOutput(),se.push("    /** start setup uploads for kernel values **/"),re.kernelArguments.forEach(ie=>{se.push("    "+ie.getStringValueHandler().split(`
`).join(`
    `))}),se.push("    /** end setup uploads for kernel values **/"),se.push(_.toString()),re.renderOutput===re.renderTexture){_.reset();let ie=_.getContextVariableName(re.framebuffer);if(re.renderKernels){let me=re.renderKernels(),ve=_.getContextVariableName(re.texture.texture);se.push(`    return {
            result: {
              texture: ${ve},
              type: '${me.result.type}',
              toArray: ${a(me.result,ve,ie)}
            },`);let{subKernels:be,mappedTextures:ae}=re;for(let de=0;de<be.length;de++){let Te=ae[de],Fe=be[de],$e=me[Fe.property],qe=_.getContextVariableName(Te.texture);se.push(`
            ${Fe.property}: {
              texture: ${qe},
              type: '${$e.type}',
              toArray: ${a($e,qe,ie)}
            },`)}se.push("    };")}else{let me=re.renderOutput(),ve=_.getContextVariableName(re.texture.texture);se.push(`    return {
              texture: ${ve},
              type: '${me.type}',
              toArray: ${a(me,ve,ie)}
            };`)}}se.push(`    ${D?`
`+D+"    ":""}`),se.push(T.join(`
`)),se.push("  };"),re.graphical&&(se.push(h(re)),se.push("  innerKernel.getPixels = getPixels;")),se.push("  return innerKernel;");let Ce=[];return X.forEach(ie=>{Ce.push(`${ie.getStringValueHandler()}`)}),`function kernel(settings) {
        const { context, constants } = settings;
        ${Ce.join("")}
        ${S||""}
      ${se.join(`
`)}
      }`}function l(b,w){let I=w.precision==="single"?b:`new Float32Array(${b}.buffer)`;return w.output[2]?`renderOutput(${I}, ${w.output[0]}, ${w.output[1]}, ${w.output[2]})`:w.output[1]?`renderOutput(${I}, ${w.output[0]}, ${w.output[1]})`:`renderOutput(${I}, ${w.output[0]})`}function h(b){let w=b.getPixels.toString(),I=!/^function/.test(w);return y.flattenFunctionToString(`${I?"function ":""}${w}`,{findDependency:(S,D)=>S==="utils"?`const ${D} = ${y[D].toString()};`:null,thisLookup:S=>{if(S==="context")return null;if(b.hasOwnProperty(S))return JSON.stringify(b[S]);throw new Error(`unhandled thisLookup ${S}`)}})}function a(b,w,I){let S=b.toArray.toString(),D=!/^function/.test(S),C=y.flattenFunctionToString(`${D?"function ":""}${S}`,{findDependency:(T,_)=>{if(T==="utils")return`const ${_} = ${y[_].toString()};`;if(T==="this")return _==="framebuffer"?"":`${D?"function ":""}${b[_].toString()}`;throw new Error("unhandled fromObject")},thisLookup:(T,_)=>{if(T==="texture")return w;if(T==="context")return _?null:"gl";if(b.hasOwnProperty(T))return JSON.stringify(b[T]);throw new Error(`unhandled thisLookup ${T}`)}});return`() => {
        function framebuffer() { return ${I}; };
        ${C}
        return toArray();
        }`}function o(b,w,I,S,D){if(b===null||w===null)return null;switch(typeof b){case"boolean":case"number":return null}if(typeof HTMLImageElement<"u"&&b instanceof HTMLImageElement)for(let C=0;C<w.length;C++){let T=w[C];if(T.type!=="HTMLImageArray"&&T||T.uploadValue!==b)continue;let _=I[C].indexOf(b);if(_===-1)continue;let k=`uploadValue_${T.name}[${_}]`;return S.insertVariable(k,b),k}for(let C=0;C<w.length;C++){let T=w[C];if(b!==T.uploadValue)continue;let _=`uploadValue_${T.name}`;return S.insertVariable(_,T),_}return null}c.exports={glKernelString:m}},{"../../utils":114,"gl-wiretap":3}],13:[function(i,c,d){let{Kernel:p}=i("../kernel"),{utils:y}=i("../../utils"),{GLTextureArray2Float:v}=i("./texture/array-2-float"),{GLTextureArray2Float2D:m}=i("./texture/array-2-float-2d"),{GLTextureArray2Float3D:l}=i("./texture/array-2-float-3d"),{GLTextureArray3Float:h}=i("./texture/array-3-float"),{GLTextureArray3Float2D:a}=i("./texture/array-3-float-2d"),{GLTextureArray3Float3D:o}=i("./texture/array-3-float-3d"),{GLTextureArray4Float:b}=i("./texture/array-4-float"),{GLTextureArray4Float2D:w}=i("./texture/array-4-float-2d"),{GLTextureArray4Float3D:I}=i("./texture/array-4-float-3d"),{GLTextureFloat:S}=i("./texture/float"),{GLTextureFloat2D:D}=i("./texture/float-2d"),{GLTextureFloat3D:C}=i("./texture/float-3d"),{GLTextureMemoryOptimized:T}=i("./texture/memory-optimized"),{GLTextureMemoryOptimized2D:_}=i("./texture/memory-optimized-2d"),{GLTextureMemoryOptimized3D:k}=i("./texture/memory-optimized-3d"),{GLTextureUnsigned:M}=i("./texture/unsigned"),{GLTextureUnsigned2D:P}=i("./texture/unsigned-2d"),{GLTextureUnsigned3D:A}=i("./texture/unsigned-3d"),{GLTextureGraphical:f}=i("./texture/graphical");class R extends p{static get mode(){return"gpu"}static getIsFloatRead(){let O=`function kernelFunction() {
            return 1;
          }`,V=new this(O,{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[1],precision:"single",returnType:"Number",tactic:"speed"});V.build(),V.run();let j=V.renderOutput();return V.destroy(!0),j[0]===1}static getIsIntegerDivisionAccurate(){function O(q,H){return q[this.thread.x]/H[this.thread.x]}let V=new this(O.toString(),{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[2],returnType:"Number",precision:"unsigned",tactic:"speed"}),j=[[6,6030401],[3,3991]];V.build.apply(V,j),V.run.apply(V,j);let z=V.renderOutput();return V.destroy(!0),z[0]===2&&z[1]===1511}static getIsSpeedTacticSupported(){function O(q){return q[this.thread.x]}let V=new this(O.toString(),{context:this.testContext,canvas:this.testCanvas,validate:!1,output:[4],returnType:"Number",precision:"unsigned",tactic:"speed"}),j=[[0,1,2,3]];V.build.apply(V,j),V.run.apply(V,j);let z=V.renderOutput();return V.destroy(!0),Math.round(z[0])===0&&Math.round(z[1])===1&&Math.round(z[2])===2&&Math.round(z[3])===3}static get testCanvas(){throw new Error(`"testCanvas" not defined on ${this.name}`)}static get testContext(){throw new Error(`"testContext" not defined on ${this.name}`)}static getFeatures(){let O=this.testContext,V=this.getIsDrawBuffers();return Object.freeze({isFloatRead:this.getIsFloatRead(),isIntegerDivisionAccurate:this.getIsIntegerDivisionAccurate(),isSpeedTacticSupported:this.getIsSpeedTacticSupported(),isTextureFloat:this.getIsTextureFloat(),isDrawBuffers:V,kernelMap:V,channelCount:this.getChannelCount(),maxTextureSize:this.getMaxTextureSize(),lowIntPrecision:O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.LOW_INT),lowFloatPrecision:O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.LOW_FLOAT),mediumIntPrecision:O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.MEDIUM_INT),mediumFloatPrecision:O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.MEDIUM_FLOAT),highIntPrecision:O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.HIGH_INT),highFloatPrecision:O.getShaderPrecisionFormat(O.FRAGMENT_SHADER,O.HIGH_FLOAT)})}static setupFeatureChecks(){throw new Error(`"setupFeatureChecks" not defined on ${this.name}`)}static getSignature(O,V){return O.getVariablePrecisionString()+(V.length>0?":"+V.join(","):"")}setFixIntegerDivisionAccuracy(O){return this.fixIntegerDivisionAccuracy=O,this}setPrecision(O){return this.precision=O,this}setFloatTextures(O){return y.warnDeprecated("method","setFloatTextures","setOptimizeFloatMemory"),this.floatTextures=O,this}static nativeFunctionArguments(O){let V=[],j=[],z=[],q=/^[a-zA-Z_]/,H=/[a-zA-Z_0-9]/,U=0,J=null,ee=null;for(;U<O.length;){let Z=O[U],Y=O[U+1],X=z.length>0?z[z.length-1]:null;if(X==="FUNCTION_ARGUMENTS"&&Z==="/"&&Y==="*"){z.push("MULTI_LINE_COMMENT"),U+=2;continue}else if(X==="MULTI_LINE_COMMENT"&&Z==="*"&&Y==="/"){z.pop(),U+=2;continue}else if(X==="FUNCTION_ARGUMENTS"&&Z==="/"&&Y==="/"){z.push("COMMENT"),U+=2;continue}else if(X==="COMMENT"&&Z===`
`){z.pop(),U++;continue}else if(X===null&&Z==="("){z.push("FUNCTION_ARGUMENTS"),U++;continue}else if(X==="FUNCTION_ARGUMENTS"){if(Z===")"){z.pop();break}if(Z==="f"&&Y==="l"&&O[U+2]==="o"&&O[U+3]==="a"&&O[U+4]==="t"&&O[U+5]===" "){z.push("DECLARE_VARIABLE"),ee="float",J="",U+=6;continue}else if(Z==="i"&&Y==="n"&&O[U+2]==="t"&&O[U+3]===" "){z.push("DECLARE_VARIABLE"),ee="int",J="",U+=4;continue}else if(Z==="v"&&Y==="e"&&O[U+2]==="c"&&O[U+3]==="2"&&O[U+4]===" "){z.push("DECLARE_VARIABLE"),ee="vec2",J="",U+=5;continue}else if(Z==="v"&&Y==="e"&&O[U+2]==="c"&&O[U+3]==="3"&&O[U+4]===" "){z.push("DECLARE_VARIABLE"),ee="vec3",J="",U+=5;continue}else if(Z==="v"&&Y==="e"&&O[U+2]==="c"&&O[U+3]==="4"&&O[U+4]===" "){z.push("DECLARE_VARIABLE"),ee="vec4",J="",U+=5;continue}}else if(X==="DECLARE_VARIABLE"){if(J===""){if(Z===" "){U++;continue}if(!q.test(Z))throw new Error("variable name is not expected string")}J+=Z,H.test(Y)||(z.pop(),j.push(J),V.push(N[ee]))}U++}if(z.length>0)throw new Error("GLSL function was not parsable");return{argumentNames:j,argumentTypes:V}}static nativeFunctionReturnType(O){return N[O.match(/int|float|vec[2-4]/)[0]]}static combineKernels(O,V){O.apply(null,arguments);let{texSize:j,context:z,threadDim:q}=V.texSize,H;if(V.precision==="single"){let U=j[0],J=Math.ceil(j[1]/4);H=new Float32Array(U*J*4*4),z.readPixels(0,0,U,J*4,z.RGBA,z.FLOAT,H)}else{let U=new Uint8Array(j[0]*j[1]*4);z.readPixels(0,0,j[0],j[1],z.RGBA,z.UNSIGNED_BYTE,U),H=new Float32Array(U.buffer)}if(H=H.subarray(0,q[0]*q[1]*q[2]),V.output.length===1)return H;if(V.output.length===2)return y.splitArray(H,V.output[0]);if(V.output.length===3)return y.splitArray(H,V.output[0]*V.output[1]).map(function(U){return y.splitArray(U,V.output[0])})}constructor(O,V){super(O,V),this.transferValues=null,this.formatValues=null,this.TextureConstructor=null,this.renderOutput=null,this.renderRawOutput=null,this.texSize=null,this.translatedSource=null,this.compiledFragmentShader=null,this.compiledVertexShader=null,this.switchingKernels=null,this._textureSwitched=null,this._mappedTextureSwitched=null}checkTextureSize(){let{features:O}=this.constructor;if(this.texSize[0]>O.maxTextureSize||this.texSize[1]>O.maxTextureSize)throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${O.maxTextureSize},${O.maxTextureSize}]`)}translateSource(){throw new Error(`"translateSource" not defined on ${this.constructor.name}`)}pickRenderStrategy(O){if(this.graphical)return this.renderRawOutput=this.readPackedPixelsToUint8Array,this.transferValues=V=>V,this.TextureConstructor=f,null;if(this.precision==="unsigned")if(this.renderRawOutput=this.readPackedPixelsToUint8Array,this.transferValues=this.readPackedPixelsToFloat32Array,this.pipeline)switch(this.renderOutput=this.renderTexture,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToTextures),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=A,null):this.output[1]>0?(this.TextureConstructor=P,null):(this.TextureConstructor=M,null);case"Array(2)":case"Array(3)":case"Array(4)":return this.requestFallback(O)}else switch(this.subKernels!==null&&(this.renderKernels=this.renderKernelsToArrays),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.renderOutput=this.renderValues,this.output[2]>0?(this.TextureConstructor=A,this.formatValues=y.erect3DPackedFloat,null):this.output[1]>0?(this.TextureConstructor=P,this.formatValues=y.erect2DPackedFloat,null):(this.TextureConstructor=M,this.formatValues=y.erectPackedFloat,null);case"Array(2)":case"Array(3)":case"Array(4)":return this.requestFallback(O)}else if(this.precision==="single"){if(this.renderRawOutput=this.readFloatPixelsToFloat32Array,this.transferValues=this.readFloatPixelsToFloat32Array,this.pipeline)switch(this.renderOutput=this.renderTexture,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToTextures),this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.optimizeFloatMemory?this.output[2]>0?(this.TextureConstructor=k,null):this.output[1]>0?(this.TextureConstructor=_,null):(this.TextureConstructor=T,null):this.output[2]>0?(this.TextureConstructor=C,null):this.output[1]>0?(this.TextureConstructor=D,null):(this.TextureConstructor=S,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=l,null):this.output[1]>0?(this.TextureConstructor=m,null):(this.TextureConstructor=v,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=o,null):this.output[1]>0?(this.TextureConstructor=a,null):(this.TextureConstructor=h,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=I,null):this.output[1]>0?(this.TextureConstructor=w,null):(this.TextureConstructor=b,null)}if(this.renderOutput=this.renderValues,this.subKernels!==null&&(this.renderKernels=this.renderKernelsToArrays),this.optimizeFloatMemory)switch(this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=k,this.formatValues=y.erectMemoryOptimized3DFloat,null):this.output[1]>0?(this.TextureConstructor=_,this.formatValues=y.erectMemoryOptimized2DFloat,null):(this.TextureConstructor=T,this.formatValues=y.erectMemoryOptimizedFloat,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=l,this.formatValues=y.erect3DArray2,null):this.output[1]>0?(this.TextureConstructor=m,this.formatValues=y.erect2DArray2,null):(this.TextureConstructor=v,this.formatValues=y.erectArray2,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=o,this.formatValues=y.erect3DArray3,null):this.output[1]>0?(this.TextureConstructor=a,this.formatValues=y.erect2DArray3,null):(this.TextureConstructor=h,this.formatValues=y.erectArray3,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=I,this.formatValues=y.erect3DArray4,null):this.output[1]>0?(this.TextureConstructor=w,this.formatValues=y.erect2DArray4,null):(this.TextureConstructor=b,this.formatValues=y.erectArray4,null)}else switch(this.returnType){case"LiteralInteger":case"Float":case"Number":case"Integer":return this.output[2]>0?(this.TextureConstructor=C,this.formatValues=y.erect3DFloat,null):this.output[1]>0?(this.TextureConstructor=D,this.formatValues=y.erect2DFloat,null):(this.TextureConstructor=S,this.formatValues=y.erectFloat,null);case"Array(2)":return this.output[2]>0?(this.TextureConstructor=l,this.formatValues=y.erect3DArray2,null):this.output[1]>0?(this.TextureConstructor=m,this.formatValues=y.erect2DArray2,null):(this.TextureConstructor=v,this.formatValues=y.erectArray2,null);case"Array(3)":return this.output[2]>0?(this.TextureConstructor=o,this.formatValues=y.erect3DArray3,null):this.output[1]>0?(this.TextureConstructor=a,this.formatValues=y.erect2DArray3,null):(this.TextureConstructor=h,this.formatValues=y.erectArray3,null);case"Array(4)":return this.output[2]>0?(this.TextureConstructor=I,this.formatValues=y.erect3DArray4,null):this.output[1]>0?(this.TextureConstructor=w,this.formatValues=y.erect2DArray4,null):(this.TextureConstructor=b,this.formatValues=y.erectArray4,null)}}else throw new Error(`unhandled precision of "${this.precision}"`);throw new Error(`unhandled return type "${this.returnType}"`)}getKernelString(){throw new Error("abstract method call")}getMainResultTexture(){switch(this.returnType){case"LiteralInteger":case"Float":case"Integer":case"Number":return this.getMainResultNumberTexture();case"Array(2)":return this.getMainResultArray2Texture();case"Array(3)":return this.getMainResultArray3Texture();case"Array(4)":return this.getMainResultArray4Texture();default:throw new Error(`unhandled returnType type ${this.returnType}`)}}getMainResultKernelNumberTexture(){throw new Error("abstract method call")}getMainResultSubKernelNumberTexture(){throw new Error("abstract method call")}getMainResultKernelArray2Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray2Texture(){throw new Error("abstract method call")}getMainResultKernelArray3Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray3Texture(){throw new Error("abstract method call")}getMainResultKernelArray4Texture(){throw new Error("abstract method call")}getMainResultSubKernelArray4Texture(){throw new Error("abstract method call")}getMainResultGraphical(){throw new Error("abstract method call")}getMainResultMemoryOptimizedFloats(){throw new Error("abstract method call")}getMainResultPackedPixels(){throw new Error("abstract method call")}getMainResultString(){return this.graphical?this.getMainResultGraphical():this.precision==="single"?this.optimizeFloatMemory?this.getMainResultMemoryOptimizedFloats():this.getMainResultTexture():this.getMainResultPackedPixels()}getMainResultNumberTexture(){return y.linesToString(this.getMainResultKernelNumberTexture())+y.linesToString(this.getMainResultSubKernelNumberTexture())}getMainResultArray2Texture(){return y.linesToString(this.getMainResultKernelArray2Texture())+y.linesToString(this.getMainResultSubKernelArray2Texture())}getMainResultArray3Texture(){return y.linesToString(this.getMainResultKernelArray3Texture())+y.linesToString(this.getMainResultSubKernelArray3Texture())}getMainResultArray4Texture(){return y.linesToString(this.getMainResultKernelArray4Texture())+y.linesToString(this.getMainResultSubKernelArray4Texture())}getFloatTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} float;
`}getIntTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic,!0)} int;
`}getSampler2DTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2D;
`}getSampler2DArrayTacticDeclaration(){return`precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2DArray;
`}renderTexture(){return this.immutable?this.texture.clone():this.texture}readPackedPixelsToUint8Array(){if(this.precision!=="unsigned")throw new Error('Requires this.precision to be "unsigned"');let{texSize:O,context:V}=this,j=new Uint8Array(O[0]*O[1]*4);return V.readPixels(0,0,O[0],O[1],V.RGBA,V.UNSIGNED_BYTE,j),j}readPackedPixelsToFloat32Array(){return new Float32Array(this.readPackedPixelsToUint8Array().buffer)}readFloatPixelsToFloat32Array(){if(this.precision!=="single")throw new Error('Requires this.precision to be "single"');let{texSize:O,context:V}=this,j=O[0],z=O[1],q=new Float32Array(j*z*4);return V.readPixels(0,0,j,z,V.RGBA,V.FLOAT,q),q}getPixels(O){let{context:V,output:j}=this,[z,q]=j,H=new Uint8Array(z*q*4);return V.readPixels(0,0,z,q,V.RGBA,V.UNSIGNED_BYTE,H),new Uint8ClampedArray((O?H:y.flipPixels(H,z,q)).buffer)}renderKernelsToArrays(){let O={result:this.renderOutput()};for(let V=0;V<this.subKernels.length;V++)O[this.subKernels[V].property]=this.mappedTextures[V].toArray();return O}renderKernelsToTextures(){let O={result:this.renderOutput()};if(this.immutable)for(let V=0;V<this.subKernels.length;V++)O[this.subKernels[V].property]=this.mappedTextures[V].clone();else for(let V=0;V<this.subKernels.length;V++)O[this.subKernels[V].property]=this.mappedTextures[V];return O}resetSwitchingKernels(){let O=this.switchingKernels;return this.switchingKernels=null,O}setOutput(O){let V=this.toKernelOutput(O);if(this.program){if(!this.dynamicOutput)throw new Error("Resizing a kernel with dynamicOutput: false is not possible");let j=[V[0],V[1]||1,V[2]||1],z=y.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},j),q=this.texSize;if(q){let U=this.getVariablePrecisionString(q,this.tactic),J=this.getVariablePrecisionString(z,this.tactic);if(U!==J){this.debug&&console.warn("Precision requirement changed, asking GPU instance to recompile"),this.switchKernels({type:"outputPrecisionMismatch",precision:J,needed:O});return}}this.output=V,this.threadDim=j,this.texSize=z;let{context:H}=this;if(H.bindFramebuffer(H.FRAMEBUFFER,this.framebuffer),this.updateMaxTexSize(),this.framebuffer.width=this.texSize[0],this.framebuffer.height=this.texSize[1],H.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),this.canvas.width=this.maxTexSize[0],this.canvas.height=this.maxTexSize[1],this.texture&&this.texture.delete(),this.texture=null,this._setupOutputTexture(),this.mappedTextures&&this.mappedTextures.length>0){for(let U=0;U<this.mappedTextures.length;U++)this.mappedTextures[U].delete();this.mappedTextures=null,this._setupSubOutputTextures()}}else this.output=V;return this}renderValues(){return this.formatValues(this.transferValues(),this.output[0],this.output[1],this.output[2])}switchKernels(O){this.switchingKernels?this.switchingKernels.push(O):this.switchingKernels=[O]}getVariablePrecisionString(O=this.texSize,V=this.tactic,j=!1){if(!V){if(!this.constructor.features.isSpeedTacticSupported)return"highp";let z=this.constructor.features[j?"lowIntPrecision":"lowFloatPrecision"],q=this.constructor.features[j?"mediumIntPrecision":"mediumFloatPrecision"],H=this.constructor.features[j?"highIntPrecision":"highFloatPrecision"],U=Math.log2(O[0]*O[1]);if(U<=z.rangeMax)return"lowp";if(U<=q.rangeMax)return"mediump";if(U<=H.rangeMax)return"highp";throw new Error("The required size exceeds that of the ability of your system")}switch(V){case"speed":return"lowp";case"balanced":return"mediump";case"precision":return"highp";default:throw new Error(`Unknown tactic "${V}" use "speed", "balanced", "precision", or empty for auto`)}}updateTextureArgumentRefs(O,V){if(this.immutable){if(this.texture.texture===V.texture){let{prevArg:j}=O;j&&(j.texture._refs===1&&(this.texture.delete(),this.texture=j.clone(),this._textureSwitched=!0),j.delete()),O.prevArg=V.clone()}else if(this.mappedTextures&&this.mappedTextures.length>0){let{mappedTextures:j}=this;for(let z=0;z<j.length;z++){let q=j[z];if(q.texture===V.texture){let{prevArg:H}=O;H&&(H.texture._refs===1&&(q.delete(),j[z]=H.clone(),this._mappedTextureSwitched[z]=!0),H.delete()),O.prevArg=V.clone();return}}}}}onActivate(O){if(this._textureSwitched=!0,this.texture=O.texture,this.mappedTextures){for(let V=0;V<this.mappedTextures.length;V++)this._mappedTextureSwitched[V]=!0;this.mappedTextures=O.mappedTextures}}initCanvas(){}}let N={int:"Integer",float:"Number",vec2:"Array(2)",vec3:"Array(3)",vec4:"Array(4)"};c.exports={GLKernel:R}},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(2)"}toArray(){return p.erect2DArray2(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureArray2Float2D:v}},{"../../../utils":114,"./float":25}],15:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(2)"}toArray(){return p.erect3DArray2(this.renderValues(),this.output[0],this.output[1],this.output[2])}}c.exports={GLTextureArray2Float3D:v}},{"../../../utils":114,"./float":25}],16:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(2)"}toArray(){return p.erectArray2(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureArray2Float:v}},{"../../../utils":114,"./float":25}],17:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(3)"}toArray(){return p.erect2DArray3(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureArray3Float2D:v}},{"../../../utils":114,"./float":25}],18:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(3)"}toArray(){return p.erect3DArray3(this.renderValues(),this.output[0],this.output[1],this.output[2])}}c.exports={GLTextureArray3Float3D:v}},{"../../../utils":114,"./float":25}],19:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(3)"}toArray(){return p.erectArray3(this.renderValues(),this.output[0])}}c.exports={GLTextureArray3Float:v}},{"../../../utils":114,"./float":25}],20:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return p.erect2DArray4(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureArray4Float2D:v}},{"../../../utils":114,"./float":25}],21:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return p.erect3DArray4(this.renderValues(),this.output[0],this.output[1],this.output[2])}}c.exports={GLTextureArray4Float3D:v}},{"../../../utils":114,"./float":25}],22:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(4)"}toArray(){return p.erectArray4(this.renderValues(),this.output[0])}}c.exports={GLTextureArray4Float:v}},{"../../../utils":114,"./float":25}],23:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(1)"}toArray(){return p.erect2DFloat(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureFloat2D:v}},{"../../../utils":114,"./float":25}],24:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="ArrayTexture(1)"}toArray(){return p.erect3DFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}c.exports={GLTextureFloat3D:v}},{"../../../utils":114,"./float":25}],25:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTexture:y}=i("./index");class v extends y{get textureType(){return this.context.FLOAT}constructor(l){super(l),this.type="ArrayTexture(1)"}renderRawOutput(){let l=this.context,h=this.size;l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,this.texture,0);let a=new Float32Array(h[0]*h[1]*4);return l.readPixels(0,0,h[0],h[1],l.RGBA,l.FLOAT,a),a}renderValues(){return this._deleted?null:this.renderRawOutput()}toArray(){return p.erectFloat(this.renderValues(),this.output[0])}}c.exports={GLTextureFloat:v}},{"../../../utils":114,"./index":27}],26:[function(i,c,d){let{GLTextureUnsigned:p}=i("./unsigned");class y extends p{constructor(m){super(m),this.type="ArrayTexture(4)"}toArray(){return this.renderValues()}}c.exports={GLTextureGraphical:y}},{"./unsigned":33}],27:[function(i,c,d){let{Texture:p}=i("../../../texture");class y extends p{get textureType(){throw new Error(`"textureType" not implemented on ${this.name}`)}clone(){return new this.constructor(this)}beforeMutate(){return this.texture._refs>1?(this.newTexture(),!0):!1}cloneTexture(){this.texture._refs--;let{context:l,size:h,texture:a,kernel:o}=this;o.debug&&console.warn("cloning internal texture"),l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),v(l,a),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,a,0);let b=l.createTexture();v(l,b),l.texImage2D(l.TEXTURE_2D,0,this.internalFormat,h[0],h[1],0,this.textureFormat,this.textureType,null),l.copyTexSubImage2D(l.TEXTURE_2D,0,0,0,0,0,h[0],h[1]),b._refs=1,this.texture=b}newTexture(){this.texture._refs--;let l=this.context,h=this.size;this.kernel.debug&&console.warn("new internal texture");let a=l.createTexture();v(l,a),l.texImage2D(l.TEXTURE_2D,0,this.internalFormat,h[0],h[1],0,this.textureFormat,this.textureType,null),a._refs=1,this.texture=a}clear(){if(this.texture._refs){this.texture._refs--;let a=this.context,o=this.texture=a.createTexture();v(a,o);let b=this.size;o._refs=1,a.texImage2D(a.TEXTURE_2D,0,this.internalFormat,b[0],b[1],0,this.textureFormat,this.textureType,null)}let{context:l,texture:h}=this;l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),l.bindTexture(l.TEXTURE_2D,h),v(l,h),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,h,0),l.clearColor(0,0,0,0),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT)}delete(){this._deleted||(this._deleted=!0,!(this.texture._refs&&(this.texture._refs--,this.texture._refs))&&this.context.deleteTexture(this.texture))}framebuffer(){return this._framebuffer||(this._framebuffer=this.kernel.getRawValueFramebuffer(this.size[0],this.size[1])),this._framebuffer}}function v(m,l){m.activeTexture(m.TEXTURE15),m.bindTexture(m.TEXTURE_2D,l),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.NEAREST),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST)}c.exports={GLTexture:y}},{"../../../texture":113}],28:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="MemoryOptimizedNumberTexture"}toArray(){return p.erectMemoryOptimized2DFloat(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureMemoryOptimized2D:v}},{"../../../utils":114,"./float":25}],29:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="MemoryOptimizedNumberTexture"}toArray(){return p.erectMemoryOptimized3DFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}c.exports={GLTextureMemoryOptimized3D:v}},{"../../../utils":114,"./float":25}],30:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureFloat:y}=i("./float");class v extends y{constructor(l){super(l),this.type="MemoryOptimizedNumberTexture"}toArray(){return p.erectMemoryOptimizedFloat(this.renderValues(),this.output[0])}}c.exports={GLTextureMemoryOptimized:v}},{"../../../utils":114,"./float":25}],31:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureUnsigned:y}=i("./unsigned");class v extends y{constructor(l){super(l),this.type="NumberTexture"}toArray(){return p.erect2DPackedFloat(this.renderValues(),this.output[0],this.output[1])}}c.exports={GLTextureUnsigned2D:v}},{"../../../utils":114,"./unsigned":33}],32:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTextureUnsigned:y}=i("./unsigned");class v extends y{constructor(l){super(l),this.type="NumberTexture"}toArray(){return p.erect3DPackedFloat(this.renderValues(),this.output[0],this.output[1],this.output[2])}}c.exports={GLTextureUnsigned3D:v}},{"../../../utils":114,"./unsigned":33}],33:[function(i,c,d){let{utils:p}=i("../../../utils"),{GLTexture:y}=i("./index");class v extends y{get textureType(){return this.context.UNSIGNED_BYTE}constructor(l){super(l),this.type="NumberTexture"}renderRawOutput(){let{context:l}=this;l.bindFramebuffer(l.FRAMEBUFFER,this.framebuffer()),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,this.texture,0);let h=new Uint8Array(this.size[0]*this.size[1]*4);return l.readPixels(0,0,this.size[0],this.size[1],l.RGBA,l.UNSIGNED_BYTE,h),h}renderValues(){return this._deleted?null:new Float32Array(this.renderRawOutput().buffer)}toArray(){return p.erectPackedFloat(this.renderValues(),this.output[0])}}c.exports={GLTextureUnsigned:v}},{"../../../utils":114,"./index":27}],34:[function(i,c,d){let p=i("gl"),{WebGLKernel:y}=i("../web-gl/kernel"),{glKernelString:v}=i("../gl/kernel-string"),m=null,l=null,h=null,a=null,o=null;class b extends y{static get isSupported(){return m!==null||(this.setupFeatureChecks(),m=h!==null),m}static setupFeatureChecks(){if(l=null,a=null,typeof p=="function")try{if(h=p(2,2,{preserveDrawingBuffer:!0}),!h||!h.getExtension)return;a={STACKGL_resize_drawingbuffer:h.getExtension("STACKGL_resize_drawingbuffer"),STACKGL_destroy_context:h.getExtension("STACKGL_destroy_context"),OES_texture_float:h.getExtension("OES_texture_float"),OES_texture_float_linear:h.getExtension("OES_texture_float_linear"),OES_element_index_uint:h.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:h.getExtension("WEBGL_draw_buffers"),WEBGL_color_buffer_float:h.getExtension("WEBGL_color_buffer_float")},o=this.getFeatures()}catch(I){console.warn(I)}}static isContextMatch(I){try{return I.getParameter(I.RENDERER)==="ANGLE"}catch{return!1}}static getIsTextureFloat(){return Boolean(a.OES_texture_float)}static getIsDrawBuffers(){return Boolean(a.WEBGL_draw_buffers)}static getChannelCount(){return a.WEBGL_draw_buffers?h.getParameter(a.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL):1}static getMaxTextureSize(){return h.getParameter(h.MAX_TEXTURE_SIZE)}static get testCanvas(){return l}static get testContext(){return h}static get features(){return o}initCanvas(){return{}}initContext(){return p(2,2,{preserveDrawingBuffer:!0})}initExtensions(){this.extensions={STACKGL_resize_drawingbuffer:this.context.getExtension("STACKGL_resize_drawingbuffer"),STACKGL_destroy_context:this.context.getExtension("STACKGL_destroy_context"),OES_texture_float:this.context.getExtension("OES_texture_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear"),OES_element_index_uint:this.context.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:this.context.getExtension("WEBGL_draw_buffers")}}build(){super.build.apply(this,arguments),this.fallbackRequested||this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0],this.maxTexSize[1])}destroyExtensions(){this.extensions.STACKGL_resize_drawingbuffer=null,this.extensions.STACKGL_destroy_context=null,this.extensions.OES_texture_float=null,this.extensions.OES_texture_float_linear=null,this.extensions.OES_element_index_uint=null,this.extensions.WEBGL_draw_buffers=null}static destroyContext(I){let S=I.getExtension("STACKGL_destroy_context");S&&S.destroy&&S.destroy()}toString(){let I=`const gl = context || require('gl')(1, 1);
`,S=`    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }
`;return v(this.constructor,arguments,this,I,S)}setOutput(I){return super.setOutput(I),this.graphical&&this.extensions.STACKGL_resize_drawingbuffer&&this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0],this.maxTexSize[1]),this}}c.exports={HeadlessGLKernel:b}},{"../gl/kernel-string":12,"../web-gl/kernel":70,gl:2}],35:[function(i,c,d){class p{constructor(v,m){let{name:l,kernel:h,context:a,checkContext:o,onRequestContextHandle:b,onUpdateValueMismatch:w,origin:I,strictIntegers:S,type:D,tactic:C}=m;if(!l)throw new Error("name not set");if(!D)throw new Error("type not set");if(!I)throw new Error("origin not set");if(I!=="user"&&I!=="constants")throw new Error(`origin must be "user" or "constants" value is "${I}"`);if(!b)throw new Error("onRequestContextHandle is not set");this.name=l,this.origin=I,this.tactic=C,this.varName=I==="constants"?`constants.${l}`:l,this.kernel=h,this.strictIntegers=S,this.type=v.type||D,this.size=v.size||null,this.index=null,this.context=a,this.checkContext=o??!0,this.contextHandle=null,this.onRequestContextHandle=b,this.onUpdateValueMismatch=w,this.forceUploadEachRun=null}get id(){return`${this.origin}_${name}`}getSource(){throw new Error(`"getSource" not defined on ${this.constructor.name}`)}updateValue(v){throw new Error(`"updateValue" not defined on ${this.constructor.name}`)}}c.exports={KernelValue:p}},{}],36:[function(i,c,d){let{utils:p}=i("../utils"),{Input:y}=i("../input");class v{static get isSupported(){throw new Error(`"isSupported" not implemented on ${this.name}`)}static isContextMatch(h){throw new Error(`"isContextMatch" not implemented on ${this.name}`)}static getFeatures(){throw new Error(`"getFeatures" not implemented on ${this.name}`)}static destroyContext(h){throw new Error(`"destroyContext" called on ${this.name}`)}static nativeFunctionArguments(){throw new Error(`"nativeFunctionArguments" called on ${this.name}`)}static nativeFunctionReturnType(){throw new Error(`"nativeFunctionReturnType" called on ${this.name}`)}static combineKernels(){throw new Error(`"combineKernels" called on ${this.name}`)}constructor(h,a){if(typeof h!="object"){if(typeof h!="string")throw new Error("source not a string");if(!p.isFunctionString(h))throw new Error("source not a function string")}this.useLegacyEncoder=!1,this.fallbackRequested=!1,this.onRequestFallback=null,this.argumentNames=typeof h=="string"?p.getArgumentNamesFromString(h):null,this.argumentTypes=null,this.argumentSizes=null,this.argumentBitRatios=null,this.kernelArguments=null,this.kernelConstants=null,this.forceUploadKernelConstants=null,this.source=h,this.output=null,this.debug=!1,this.graphical=!1,this.loopMaxIterations=0,this.constants=null,this.constantTypes=null,this.constantBitRatios=null,this.dynamicArguments=!1,this.dynamicOutput=!1,this.canvas=null,this.context=null,this.checkContext=null,this.gpu=null,this.functions=null,this.nativeFunctions=null,this.injectedNative=null,this.subKernels=null,this.validate=!0,this.immutable=!1,this.pipeline=!1,this.precision=null,this.tactic=null,this.plugins=null,this.returnType=null,this.leadingReturnStatement=null,this.followingReturnStatement=null,this.optimizeFloatMemory=null,this.strictIntegers=!1,this.fixIntegerDivisionAccuracy=null,this.built=!1,this.signature=null}mergeSettings(h){for(let a in h)if(!(!h.hasOwnProperty(a)||!this.hasOwnProperty(a))){switch(a){case"output":if(!Array.isArray(h.output)){this.setOutput(h.output);continue}break;case"functions":this.functions=[];for(let o=0;o<h.functions.length;o++)this.addFunction(h.functions[o]);continue;case"graphical":h[a]&&!h.hasOwnProperty("precision")&&(this.precision="unsigned"),this[a]=h[a];continue;case"nativeFunctions":if(!h.nativeFunctions)continue;this.nativeFunctions=[];for(let o=0;o<h.nativeFunctions.length;o++){let b=h.nativeFunctions[o],{name:w,source:I}=b;this.addNativeFunction(w,I,b)}continue}this[a]=h[a]}this.canvas||(this.canvas=this.initCanvas()),this.context||(this.context=this.initContext()),this.plugins||(this.plugins=this.initPlugins(h))}build(){throw new Error(`"build" not defined on ${this.constructor.name}`)}run(){throw new Error(`"run" not defined on ${this.constructor.name}`)}initCanvas(){throw new Error(`"initCanvas" not defined on ${this.constructor.name}`)}initContext(){throw new Error(`"initContext" not defined on ${this.constructor.name}`)}initPlugins(h){throw new Error(`"initPlugins" not defined on ${this.constructor.name}`)}addFunction(h,a={}){if(h.name&&h.source&&h.argumentTypes&&"returnType"in h)this.functions.push(h);else if("settings"in h&&"source"in h)this.functions.push(this.functionToIGPUFunction(h.source,h.settings));else if(typeof h=="string"||typeof h=="function")this.functions.push(this.functionToIGPUFunction(h,a));else throw new Error("function not properly defined");return this}addNativeFunction(h,a,o={}){let{argumentTypes:b,argumentNames:w}=o.argumentTypes?m(o.argumentTypes):this.constructor.nativeFunctionArguments(a)||{};return this.nativeFunctions.push({name:h,source:a,settings:o,argumentTypes:b,argumentNames:w,returnType:o.returnType||this.constructor.nativeFunctionReturnType(a)}),this}setupArguments(h){if(this.kernelArguments=[],this.argumentTypes)for(let a=0;a<this.argumentTypes.length;a++)this.kernelArguments.push({type:this.argumentTypes[a]});else if(!this.argumentTypes){this.argumentTypes=[];for(let a=0;a<h.length;a++){let o=p.getVariableType(h[a],this.strictIntegers),b=o==="Integer"?"Number":o;this.argumentTypes.push(b),this.kernelArguments.push({type:b})}}this.argumentSizes=new Array(h.length),this.argumentBitRatios=new Int32Array(h.length);for(let a=0;a<h.length;a++){let o=h[a];this.argumentSizes[a]=o.constructor===y?o.size:null,this.argumentBitRatios[a]=this.getBitRatio(o)}if(this.argumentNames.length!==h.length)throw new Error("arguments are miss-aligned")}setupConstants(){this.kernelConstants=[];let h=this.constantTypes===null;if(h&&(this.constantTypes={}),this.constantBitRatios={},this.constants)for(let a in this.constants){if(h){let o=p.getVariableType(this.constants[a],this.strictIntegers);this.constantTypes[a]=o,this.kernelConstants.push({name:a,type:o})}else this.kernelConstants.push({name:a,type:this.constantTypes[a]});this.constantBitRatios[a]=this.getBitRatio(this.constants[a])}}setOptimizeFloatMemory(h){return this.optimizeFloatMemory=h,this}toKernelOutput(h){return h.hasOwnProperty("x")?h.hasOwnProperty("y")?h.hasOwnProperty("z")?[h.x,h.y,h.z]:[h.x,h.y]:[h.x]:h}setOutput(h){return this.output=this.toKernelOutput(h),this}setDebug(h){return this.debug=h,this}setGraphical(h){return this.graphical=h,this.precision="unsigned",this}setLoopMaxIterations(h){return this.loopMaxIterations=h,this}setConstants(h){return this.constants=h,this}setConstantTypes(h){return this.constantTypes=h,this}setFunctions(h){for(let a=0;a<h.length;a++)this.addFunction(h[a]);return this}setNativeFunctions(h){for(let a=0;a<h.length;a++){let o=h[a],{name:b,source:w}=o;this.addNativeFunction(b,w,o)}return this}setInjectedNative(h){return this.injectedNative=h,this}setPipeline(h){return this.pipeline=h,this}setPrecision(h){return this.precision=h,this}setDimensions(h){return p.warnDeprecated("method","setDimensions","setOutput"),this.output=h,this}setOutputToTexture(h){return p.warnDeprecated("method","setOutputToTexture","setPipeline"),this.pipeline=h,this}setImmutable(h){return this.immutable=h,this}setCanvas(h){return this.canvas=h,this}setStrictIntegers(h){return this.strictIntegers=h,this}setDynamicOutput(h){return this.dynamicOutput=h,this}setHardcodeConstants(h){return p.warnDeprecated("method","setHardcodeConstants"),this.setDynamicOutput(h),this.setDynamicArguments(h),this}setDynamicArguments(h){return this.dynamicArguments=h,this}setUseLegacyEncoder(h){return this.useLegacyEncoder=h,this}setWarnVarUsage(h){return p.warnDeprecated("method","setWarnVarUsage"),this}getCanvas(){return p.warnDeprecated("method","getCanvas"),this.canvas}getWebGl(){return p.warnDeprecated("method","getWebGl"),this.context}setContext(h){return this.context=h,this}setArgumentTypes(h){if(Array.isArray(h))this.argumentTypes=h;else{this.argumentTypes=[];for(let a in h){if(!h.hasOwnProperty(a))continue;let o=this.argumentNames.indexOf(a);if(o===-1)throw new Error(`unable to find argument ${a}`);this.argumentTypes[o]=h[a]}}return this}setTactic(h){return this.tactic=h,this}requestFallback(h){if(!this.onRequestFallback)throw new Error(`"onRequestFallback" not defined on ${this.constructor.name}`);return this.fallbackRequested=!0,this.onRequestFallback(h)}validateSettings(){throw new Error(`"validateSettings" not defined on ${this.constructor.name}`)}addSubKernel(h){if(this.subKernels===null&&(this.subKernels=[]),!h.source)throw new Error('subKernel missing "source" property');if(!h.property&&isNaN(h.property))throw new Error('subKernel missing "property" property');if(!h.name)throw new Error('subKernel missing "name" property');return this.subKernels.push(h),this}destroy(h){throw new Error(`"destroy" called on ${this.constructor.name}`)}getBitRatio(h){if(this.precision==="single")return 4;if(Array.isArray(h[0]))return this.getBitRatio(h[0]);if(h.constructor===y)return this.getBitRatio(h.value);switch(h.constructor){case Uint8ClampedArray:case Uint8Array:case Int8Array:return 1;case Uint16Array:case Int16Array:return 2;case Float32Array:case Int32Array:default:return 4}}getPixels(h){throw new Error(`"getPixels" called on ${this.constructor.name}`)}checkOutput(){if(!this.output||!p.isArray(this.output))throw new Error("kernel.output not an array");if(this.output.length<1)throw new Error("kernel.output is empty, needs at least 1 value");for(let h=0;h<this.output.length;h++)if(isNaN(this.output[h])||this.output[h]<1)throw new Error(`${this.constructor.name}.output[${h}] incorrectly defined as \`${this.output[h]}\`, needs to be numeric, and greater than 0`)}prependString(h){throw new Error(`"prependString" called on ${this.constructor.name}`)}hasPrependString(h){throw new Error(`"hasPrependString" called on ${this.constructor.name}`)}toJSON(){return{settings:{output:this.output,pipeline:this.pipeline,argumentNames:this.argumentNames,argumentsTypes:this.argumentTypes,constants:this.constants,pluginNames:this.plugins?this.plugins.map(h=>h.name):null,returnType:this.returnType}}}buildSignature(h){let a=this.constructor;this.signature=a.getSignature(this,a.getArgumentTypes(this,h))}static getArgumentTypes(h,a){let o=new Array(a.length);for(let b=0;b<a.length;b++){let w=a[b],I=h.argumentTypes[b];if(w.type)o[b]=w.type;else switch(I){case"Number":case"Integer":case"Float":case"ArrayTexture(1)":o[b]=p.getVariableType(w);break;default:o[b]=I}}return o}static getSignature(h,a){throw new Error(`"getSignature" not implemented on ${this.name}`)}functionToIGPUFunction(h,a={}){if(typeof h!="string"&&typeof h!="function")throw new Error("source not a string or function");let o=typeof h=="string"?h:h.toString(),b=[];return Array.isArray(a.argumentTypes)?b=a.argumentTypes:typeof a.argumentTypes=="object"?b=p.getArgumentNamesFromString(o).map(w=>a.argumentTypes[w])||[]:b=a.argumentTypes||[],{name:p.getFunctionNameFromString(o)||null,source:o,argumentTypes:b,returnType:a.returnType||null}}onActivate(h){}}function m(l){let h=Object.keys(l),a=[];for(let o=0;o<h.length;o++){let b=h[o];a.push(l[b])}return{argumentTypes:a,argumentNames:h}}c.exports={Kernel:v}},{"../input":110,"../utils":114}],37:[function(i,c,d){let p=`__HEADER__;
      __FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      
      const int LOOP_MAX = __LOOP_MAX__;
      
      __PLUGINS__;
      __CONSTANTS__;
      
      varying vec2 vTexCoord;
      
      float acosh(float x) {
        return log(x + sqrt(x * x - 1.0));
      }
      
      float sinh(float x) {
        return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
      }
      
      float asinh(float x) {
        return log(x + sqrt(x * x + 1.0));
      }
      
      float atan2(float v1, float v2) {
        if (v1 == 0.0 || v2 == 0.0) return 0.0;
        return atan(v1 / v2);
      }
      
      float atanh(float x) {
        x = (x + 1.0) / (x - 1.0);
        if (x < 0.0) {
          return 0.5 * log(-x);
        }
        return 0.5 * log(x);
      }
      
      float cbrt(float x) {
        if (x >= 0.0) {
          return pow(x, 1.0 / 3.0);
        } else {
          return -pow(x, 1.0 / 3.0);
        }
      }
      
      float cosh(float x) {
        return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
      }
      
      float expm1(float x) {
        return pow(${Math.E}, x) - 1.0; 
      }
      
      float fround(highp float x) {
        return x;
      }
      
      float imul(float v1, float v2) {
        return float(int(v1) * int(v2));
      }
      
      float log10(float x) {
        return log2(x) * (1.0 / log2(10.0));
      }
      
      float log1p(float x) {
        return log(1.0 + x);
      }
      
      float _pow(float v1, float v2) {
        if (v2 == 0.0) return 1.0;
        return pow(v1, v2);
      }
      
      float tanh(float x) {
        float e = exp(2.0 * x);
        return (e - 1.0) / (e + 1.0);
      }
      
      float trunc(float x) {
        if (x >= 0.0) {
          return floor(x); 
        } else {
          return ceil(x);
        }
      }
      
      vec4 _round(vec4 x) {
        return floor(x + 0.5);
      }
      
      float _round(float x) {
        return floor(x + 0.5);
      }
      
      const int BIT_COUNT = 32;
      int modi(int x, int y) {
        return x - y * (x / y);
      }
      
      int bitwiseOr(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseXOR(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseAnd(int a, int b) {
        int result = 0;
        int n = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 && b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseNot(int a) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if (modi(a, 2) == 0) {
            result += n;    
          }
          a = a / 2;
          n = n * 2;
        }
        return result;
      }
      int bitwiseZeroFillLeftShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n *= 2;
        }
      
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      int bitwiseSignedRightShift(int num, int shifts) {
        return int(floor(float(num) / pow(2.0, float(shifts))));
      }
      
      int bitwiseZeroFillRightShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n /= 2;
        }
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      vec2 integerMod(vec2 x, float y) {
        vec2 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec3 integerMod(vec3 x, float y) {
        vec3 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec4 integerMod(vec4 x, vec4 y) {
        vec4 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      float integerMod(float x, float y) {
        float res = floor(mod(x, y));
        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
      }
      
      int integerMod(int x, int y) {
        return x - (y * int(x / y));
      }
      
      __DIVIDE_WITH_INTEGER_CHECK__;
      
      // Here be dragons!
      // DO NOT OPTIMIZE THIS CODE
      // YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
      const vec2 MAGIC_VEC = vec2(1.0, -256.0);
      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
      float decode32(vec4 texel) {
        __DECODE32_ENDIANNESS__;
        texel *= 255.0;
        vec2 gte128;
        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
        float res = exp2(_round(exponent));
        texel.b = texel.b - 128.0 * gte128.x;
        res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
        res *= gte128.y * -2.0 + 1.0;
        return res;
      }
      
      float decode16(vec4 texel, int index) {
        int channel = integerMod(index, 2);
        if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
        if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
        return 0.0;
      }
      
      float decode8(vec4 texel, int index) {
        int channel = integerMod(index, 4);
        if (channel == 0) return texel.r * 255.0;
        if (channel == 1) return texel.g * 255.0;
        if (channel == 2) return texel.b * 255.0;
        if (channel == 3) return texel.a * 255.0;
        return 0.0;
      }
      
      vec4 legacyEncode32(float f) {
        float F = abs(f);
        float sign = f < 0.0 ? 1.0 : 0.0;
        float exponent = floor(log2(F));
        float mantissa = (exp2(-exponent) * F);
        // exponent += floor(log2(mantissa));
        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
        texel.rg = integerMod(texel.rg, 256.0);
        texel.b = integerMod(texel.b, 128.0);
        texel.a = exponent*0.5 + 63.5;
        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
        texel = floor(texel);
        texel *= 0.003921569; // 1/255
        __ENCODE32_ENDIANNESS__;
        return texel;
      }
      
      // https://github.com/gpujs/gpu.js/wiki/Encoder-details
      vec4 encode32(float value) {
        if (value == 0.0) return vec4(0, 0, 0, 0);
      
        float exponent;
        float mantissa;
        vec4  result;
        float sgn;
      
        sgn = step(0.0, -value);
        value = abs(value);
      
        exponent = floor(log2(value));
      
        mantissa = value*pow(2.0, -exponent)-1.0;
        exponent = exponent+127.0;
        result   = vec4(0,0,0,0);
      
        result.a = floor(exponent/2.0);
        exponent = exponent - result.a*2.0;
        result.a = result.a + 128.0*sgn;
      
        result.b = floor(mantissa * 128.0);
        mantissa = mantissa - result.b / 128.0;
        result.b = result.b + exponent*128.0;
      
        result.g = floor(mantissa*32768.0);
        mantissa = mantissa - result.g/32768.0;
      
        result.r = floor(mantissa*8388608.0);
        return result/255.0;
      }
      // Dragons end here
      
      int index;
      ivec3 threadId;
      
      ivec3 indexTo3D(int idx, ivec3 texDim) {
        int z = int(idx / (texDim.x * texDim.y));
        idx -= z * int(texDim.x * texDim.y);
        int y = int(idx / texDim.x);
        int x = int(integerMod(idx, texDim.x));
        return ivec3(x, y, z);
      }
      
      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        return decode32(texel);
      }
      
      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x * 2;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
        return decode16(texel, index);
      }
      
      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x * 4;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
        return decode8(texel, index);
      }
      
      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 4);
        index = index / 4;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        if (channel == 0) return texel.r;
        if (channel == 1) return texel.g;
        if (channel == 2) return texel.b;
        if (channel == 3) return texel.a;
        return 0.0;
      }
      
      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        return texture2D(tex, st / vec2(texSize));
      }
      
      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return result[0];
      }
      
      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec2(result[0], result[1]);
      }
      
      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int channel = integerMod(index, 2);
        index = index / 2;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        if (channel == 0) return vec2(texel.r, texel.g);
        if (channel == 1) return vec2(texel.b, texel.a);
        return vec2(0.0, 0.0);
      }
      
      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec3(result[0], result[1], result[2]);
      }
      
      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
        int vectorIndex = fieldIndex / 4;
        int vectorOffset = fieldIndex - vectorIndex * 4;
        int readY = vectorIndex / texSize.x;
        int readX = vectorIndex - readY * texSize.x;
        vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
        
        if (vectorOffset == 0) {
          return tex1.xyz;
        } else if (vectorOffset == 1) {
          return tex1.yzw;
        } else {
          readX++;
          if (readX >= texSize.x) {
            readX = 0;
            readY++;
          }
          vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
          if (vectorOffset == 2) {
            return vec3(tex1.z, tex1.w, tex2.x);
          } else {
            return vec3(tex1.w, tex2.x, tex2.y);
          }
        }
      }
      
      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        return getImage2D(tex, texSize, texDim, z, y, x);
      }
      
      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 2);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        return vec4(texel.r, texel.g, texel.b, texel.a);
      }
      
      vec4 actualColor;
      void color(float r, float g, float b, float a) {
        actualColor = vec4(r,g,b,a);
      }
      
      void color(float r, float g, float b) {
        color(r,g,b,1.0);
      }
      
      void color(sampler2D image) {
        actualColor = texture2D(image, vTexCoord);
      }
      
      float modulo(float number, float divisor) {
        if (number < 0.0) {
          number = abs(number);
          if (divisor < 0.0) {
            divisor = abs(divisor);
          }
          return -mod(number, divisor);
        }
        if (divisor < 0.0) {
          divisor = abs(divisor);
        }
        return mod(number, divisor);
      }
      
      __INJECTED_NATIVE__;
      __MAIN_CONSTANTS__;
      __MAIN_ARGUMENTS__;
      __KERNEL__;
      
      void main(void) {
        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
        __MAIN_RESULT__;
      }`;c.exports={fragmentShader:p}},{}],38:[function(i,c,d){let{utils:p}=i("../../utils"),{FunctionNode:y}=i("../function-node");class v extends y{constructor(a,o){super(a,o),o&&o.hasOwnProperty("fixIntegerDivisionAccuracy")&&(this.fixIntegerDivisionAccuracy=o.fixIntegerDivisionAccuracy)}astConditionalExpression(a,o){if(a.type!=="ConditionalExpression")throw this.astErrorOutput("Not a conditional expression",a);let b=this.getType(a.consequent),w=this.getType(a.alternate);return b===null&&w===null?(o.push("if ("),this.astGeneric(a.test,o),o.push(") {"),this.astGeneric(a.consequent,o),o.push(";"),o.push("} else {"),this.astGeneric(a.alternate,o),o.push(";"),o.push("}"),o):(o.push("("),this.astGeneric(a.test,o),o.push("?"),this.astGeneric(a.consequent,o),o.push(":"),this.astGeneric(a.alternate,o),o.push(")"),o)}astFunction(a,o){if(this.isRootKernel)o.push("void");else{this.returnType||this.findLastReturn()&&(this.returnType=this.getType(a.body),this.returnType==="LiteralInteger"&&(this.returnType="Number"));let{returnType:b}=this;if(!b)o.push("void");else{let w=m[b];if(!w)throw new Error(`unknown type ${b}`);o.push(w)}}if(o.push(" "),o.push(this.name),o.push("("),!this.isRootKernel)for(let b=0;b<this.argumentNames.length;++b){let w=this.argumentNames[b];b>0&&o.push(", ");let I=this.argumentTypes[this.argumentNames.indexOf(w)];if(!I)throw this.astErrorOutput(`Unknown argument ${w} type`,a);I==="LiteralInteger"&&(this.argumentTypes[b]=I="Number");let S=m[I];if(!S)throw this.astErrorOutput("Unexpected expression",a);let D=p.sanitizeName(w);S==="sampler2D"||S==="sampler2DArray"?o.push(`${S} user_${D},ivec2 user_${D}Size,ivec3 user_${D}Dim`):o.push(`${S} user_${D}`)}o.push(`) {
`);for(let b=0;b<a.body.body.length;++b)this.astGeneric(a.body.body[b],o),o.push(`
`);return o.push(`}
`),o}astReturnStatement(a,o){if(!a.argument)throw this.astErrorOutput("Unexpected return statement",a);this.pushState("skip-literal-correction");let b=this.getType(a.argument);this.popState("skip-literal-correction");let w=[];switch(this.returnType||(b==="LiteralInteger"||b==="Integer"?this.returnType="Number":this.returnType=b),this.returnType){case"LiteralInteger":case"Number":case"Float":switch(b){case"Integer":w.push("float("),this.astGeneric(a.argument,w),w.push(")");break;case"LiteralInteger":this.castLiteralToFloat(a.argument,w),this.getType(a)==="Integer"&&(w.unshift("float("),w.push(")"));break;default:this.astGeneric(a.argument,w)}break;case"Integer":switch(b){case"Float":case"Number":this.castValueToInteger(a.argument,w);break;case"LiteralInteger":this.castLiteralToInteger(a.argument,w);break;default:this.astGeneric(a.argument,w)}break;case"Array(4)":case"Array(3)":case"Array(2)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":case"Input":this.astGeneric(a.argument,w);break;default:throw this.astErrorOutput(`unhandled return type ${this.returnType}`,a)}return this.isRootKernel?(o.push(`kernelResult = ${w.join("")};`),o.push("return;")):this.isSubKernel?(o.push(`subKernelResult_${this.name} = ${w.join("")};`),o.push(`return subKernelResult_${this.name};`)):o.push(`return ${w.join("")};`),o}astLiteral(a,o){if(isNaN(a.value))throw this.astErrorOutput("Non-numeric literal not supported : "+a.value,a);let b=this.astKey(a);return Number.isInteger(a.value)?this.isState("casting-to-integer")||this.isState("building-integer")?(this.literalTypes[b]="Integer",o.push(`${a.value}`)):this.isState("casting-to-float")||this.isState("building-float")?(this.literalTypes[b]="Number",o.push(`${a.value}.0`)):(this.literalTypes[b]="Number",o.push(`${a.value}.0`)):this.isState("casting-to-integer")||this.isState("building-integer")?(this.literalTypes[b]="Integer",o.push(Math.round(a.value))):(this.literalTypes[b]="Number",o.push(`${a.value}`)),o}astBinaryExpression(a,o){if(this.checkAndUpconvertOperator(a,o))return o;if(this.fixIntegerDivisionAccuracy&&a.operator==="/"){switch(o.push("divWithIntCheck("),this.pushState("building-float"),this.getType(a.left)){case"Integer":this.castValueToFloat(a.left,o);break;case"LiteralInteger":this.castLiteralToFloat(a.left,o);break;default:this.astGeneric(a.left,o)}switch(o.push(", "),this.getType(a.right)){case"Integer":this.castValueToFloat(a.right,o);break;case"LiteralInteger":this.castLiteralToFloat(a.right,o);break;default:this.astGeneric(a.right,o)}return this.popState("building-float"),o.push(")"),o}o.push("(");let b=this.getType(a.left)||"Number",w=this.getType(a.right)||"Number";if(!b||!w)throw this.astErrorOutput("Unhandled binary expression",a);let I=b+" & "+w;switch(I){case"Integer & Integer":this.pushState("building-integer"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.astGeneric(a.right,o),this.popState("building-integer");break;case"Number & Float":case"Float & Number":case"Float & Float":case"Number & Number":this.pushState("building-float"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.astGeneric(a.right,o),this.popState("building-float");break;case"LiteralInteger & LiteralInteger":this.isState("casting-to-integer")||this.isState("building-integer")?(this.pushState("building-integer"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.astGeneric(a.right,o),this.popState("building-integer")):(this.pushState("building-float"),this.castLiteralToFloat(a.left,o),o.push(l[a.operator]||a.operator),this.castLiteralToFloat(a.right,o),this.popState("building-float"));break;case"Integer & Float":case"Integer & Number":if((a.operator===">"||a.operator==="<"&&a.right.type==="Literal")&&!Number.isInteger(a.right.value)){this.pushState("building-float"),this.castValueToFloat(a.left,o),o.push(l[a.operator]||a.operator),this.astGeneric(a.right,o),this.popState("building-float");break}if(this.pushState("building-integer"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.pushState("casting-to-integer"),a.right.type==="Literal"){let S=[];if(this.astGeneric(a.right,S),this.getType(a.right)==="Integer")o.push(S.join(""));else throw this.astErrorOutput("Unhandled binary expression with literal",a)}else o.push("int("),this.astGeneric(a.right,o),o.push(")");this.popState("casting-to-integer"),this.popState("building-integer");break;case"Integer & LiteralInteger":this.pushState("building-integer"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.castLiteralToInteger(a.right,o),this.popState("building-integer");break;case"Number & Integer":this.pushState("building-float"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.castValueToFloat(a.right,o),this.popState("building-float");break;case"Float & LiteralInteger":case"Number & LiteralInteger":this.pushState("building-float"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.castLiteralToFloat(a.right,o),this.popState("building-float");break;case"LiteralInteger & Float":case"LiteralInteger & Number":this.isState("casting-to-integer")?(this.pushState("building-integer"),this.castLiteralToInteger(a.left,o),o.push(l[a.operator]||a.operator),this.castValueToInteger(a.right,o),this.popState("building-integer")):(this.pushState("building-float"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.pushState("casting-to-float"),this.astGeneric(a.right,o),this.popState("casting-to-float"),this.popState("building-float"));break;case"LiteralInteger & Integer":this.pushState("building-integer"),this.castLiteralToInteger(a.left,o),o.push(l[a.operator]||a.operator),this.astGeneric(a.right,o),this.popState("building-integer");break;case"Boolean & Boolean":this.pushState("building-boolean"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.astGeneric(a.right,o),this.popState("building-boolean");break;case"Float & Integer":this.pushState("building-float"),this.astGeneric(a.left,o),o.push(l[a.operator]||a.operator),this.castValueToFloat(a.right,o),this.popState("building-float");break;default:throw this.astErrorOutput(`Unhandled binary expression between ${I}`,a)}return o.push(")"),o}checkAndUpconvertOperator(a,o){let b=this.checkAndUpconvertBitwiseOperators(a,o);if(b)return b;let w={"%":this.fixIntegerDivisionAccuracy?"integerCorrectionModulo":"modulo","**":"pow"}[a.operator];if(!w)return null;switch(o.push(w),o.push("("),this.getType(a.left)){case"Integer":this.castValueToFloat(a.left,o);break;case"LiteralInteger":this.castLiteralToFloat(a.left,o);break;default:this.astGeneric(a.left,o)}switch(o.push(","),this.getType(a.right)){case"Integer":this.castValueToFloat(a.right,o);break;case"LiteralInteger":this.castLiteralToFloat(a.right,o);break;default:this.astGeneric(a.right,o)}return o.push(")"),o}checkAndUpconvertBitwiseOperators(a,o){let b={"&":"bitwiseAnd","|":"bitwiseOr","^":"bitwiseXOR","<<":"bitwiseZeroFillLeftShift",">>":"bitwiseSignedRightShift",">>>":"bitwiseZeroFillRightShift"}[a.operator];if(!b)return null;switch(o.push(b),o.push("("),this.getType(a.left)){case"Number":case"Float":this.castValueToInteger(a.left,o);break;case"LiteralInteger":this.castLiteralToInteger(a.left,o);break;default:this.astGeneric(a.left,o)}switch(o.push(","),this.getType(a.right)){case"Number":case"Float":this.castValueToInteger(a.right,o);break;case"LiteralInteger":this.castLiteralToInteger(a.right,o);break;default:this.astGeneric(a.right,o)}return o.push(")"),o}checkAndUpconvertBitwiseUnary(a,o){let b={"~":"bitwiseNot"}[a.operator];if(!b)return null;switch(o.push(b),o.push("("),this.getType(a.argument)){case"Number":case"Float":this.castValueToInteger(a.argument,o);break;case"LiteralInteger":this.castLiteralToInteger(a.argument,o);break;default:this.astGeneric(a.argument,o)}return o.push(")"),o}castLiteralToInteger(a,o){return this.pushState("casting-to-integer"),this.astGeneric(a,o),this.popState("casting-to-integer"),o}castLiteralToFloat(a,o){return this.pushState("casting-to-float"),this.astGeneric(a,o),this.popState("casting-to-float"),o}castValueToInteger(a,o){return this.pushState("casting-to-integer"),o.push("int("),this.astGeneric(a,o),o.push(")"),this.popState("casting-to-integer"),o}castValueToFloat(a,o){return this.pushState("casting-to-float"),o.push("float("),this.astGeneric(a,o),o.push(")"),this.popState("casting-to-float"),o}astIdentifierExpression(a,o){if(a.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",a);let b=this.getType(a),w=p.sanitizeName(a.name);return a.name==="Infinity"?o.push("3.402823466e+38"):b==="Boolean"?this.argumentNames.indexOf(w)>-1?o.push(`bool(user_${w})`):o.push(`user_${w}`):o.push(`user_${w}`),o}astForStatement(a,o){if(a.type!=="ForStatement")throw this.astErrorOutput("Invalid for statement",a);let b=[],w=[],I=[],S=[],D=null;if(a.init){let{declarations:C}=a.init;C.length>1&&(D=!1),this.astGeneric(a.init,b);for(let T=0;T<C.length;T++)C[T].init&&C[T].init.type!=="Literal"&&(D=!1)}else D=!1;if(a.test?this.astGeneric(a.test,w):D=!1,a.update?this.astGeneric(a.update,I):D=!1,a.body&&(this.pushState("loop-body"),this.astGeneric(a.body,S),this.popState("loop-body")),D===null&&(D=this.isSafe(a.init)&&this.isSafe(a.test)),D){let C=b.join(""),T=C[C.length-1]!==";";o.push(`for (${C}${T?";":""}${w.join("")};${I.join("")}){
`),o.push(S.join("")),o.push(`}
`)}else{let C=this.getInternalVariableName("safeI");b.length>0&&o.push(b.join(""),`
`),o.push(`for (int ${C}=0;${C}<LOOP_MAX;${C}++){
`),w.length>0&&o.push(`if (!${w.join("")}) break;
`),o.push(S.join("")),o.push(`
${I.join("")};`),o.push(`}
`)}return o}astWhileStatement(a,o){if(a.type!=="WhileStatement")throw this.astErrorOutput("Invalid while statement",a);let b=this.getInternalVariableName("safeI");return o.push(`for (int ${b}=0;${b}<LOOP_MAX;${b}++){
`),o.push("if (!"),this.astGeneric(a.test,o),o.push(`) break;
`),this.astGeneric(a.body,o),o.push(`}
`),o}astDoWhileStatement(a,o){if(a.type!=="DoWhileStatement")throw this.astErrorOutput("Invalid while statement",a);let b=this.getInternalVariableName("safeI");return o.push(`for (int ${b}=0;${b}<LOOP_MAX;${b}++){
`),this.astGeneric(a.body,o),o.push("if (!"),this.astGeneric(a.test,o),o.push(`) break;
`),o.push(`}
`),o}astAssignmentExpression(a,o){if(a.operator==="%=")this.astGeneric(a.left,o),o.push("="),o.push("mod("),this.astGeneric(a.left,o),o.push(","),this.astGeneric(a.right,o),o.push(")");else if(a.operator==="**=")this.astGeneric(a.left,o),o.push("="),o.push("pow("),this.astGeneric(a.left,o),o.push(","),this.astGeneric(a.right,o),o.push(")");else{let b=this.getType(a.left),w=this.getType(a.right);return this.astGeneric(a.left,o),o.push(a.operator),b!=="Integer"&&w==="Integer"?(o.push("float("),this.astGeneric(a.right,o),o.push(")")):this.astGeneric(a.right,o),o}}astBlockStatement(a,o){if(this.isState("loop-body")){this.pushState("block-body");for(let b=0;b<a.body.length;b++)this.astGeneric(a.body[b],o);this.popState("block-body")}else{o.push(`{
`);for(let b=0;b<a.body.length;b++)this.astGeneric(a.body[b],o);o.push(`}
`)}return o}astVariableDeclaration(a,o){let b=a.declarations;if(!b||!b[0]||!b[0].init)throw this.astErrorOutput("Unexpected expression",a);let w=[],I=null,S=[],D=[];for(let C=0;C<b.length;C++){let T=b[C],_=T.init,k=this.getDeclaration(T.id),M=this.getType(T.init),P=M;P==="LiteralInteger"&&(k.suggestedType==="Integer"?P="Integer":P="Number");let A=m[P];if(!A)throw this.astErrorOutput(`Markup type ${P} not handled`,a);let f=[];if(M==="Integer"&&P==="Integer"){if(k.valueType="Number",C===0||I===null)f.push("float ");else if(P!==I)throw new Error("Unhandled declaration");I=P,f.push(`user_${p.sanitizeName(T.id.name)}=`),f.push("float("),this.astGeneric(_,f),f.push(")")}else k.valueType=P,C===0||I===null?f.push(`${A} `):P!==I&&(S.push(D.join(",")),D=[],f.push(`${A} `)),I=P,f.push(`user_${p.sanitizeName(T.id.name)}=`),M==="Number"&&P==="Integer"?_.left&&_.left.type==="Literal"?this.astGeneric(_,f):(f.push("int("),this.astGeneric(_,f),f.push(")")):M==="LiteralInteger"&&P==="Integer"?this.castLiteralToInteger(_,f):this.astGeneric(_,f);D.push(f.join(""))}return D.length>0&&S.push(D.join(",")),w.push(S.join(";")),o.push(w.join("")),o.push(";"),o}astIfStatement(a,o){return o.push("if ("),this.astGeneric(a.test,o),o.push(")"),a.consequent.type==="BlockStatement"?this.astGeneric(a.consequent,o):(o.push(` {
`),this.astGeneric(a.consequent,o),o.push(`
}
`)),a.alternate&&(o.push("else "),a.alternate.type==="BlockStatement"||a.alternate.type==="IfStatement"?this.astGeneric(a.alternate,o):(o.push(` {
`),this.astGeneric(a.alternate,o),o.push(`
}
`))),o}astSwitchStatement(a,o){if(a.type!=="SwitchStatement")throw this.astErrorOutput("Invalid switch statement",a);let{discriminant:b,cases:w}=a,I=this.getType(b),S=`switchDiscriminant${this.astKey(a,"_")}`;switch(I){case"Float":case"Number":o.push(`float ${S} = `),this.astGeneric(b,o),o.push(`;
`);break;case"Integer":o.push(`int ${S} = `),this.astGeneric(b,o),o.push(`;
`);break}if(w.length===1&&!w[0].test)return this.astGeneric(w[0].consequent,o),o;let D=!1,C=[],T=!1,_=!1;for(let k=0;k<w.length;k++){if(w[k].test){if(k===0||!_?(_=!0,o.push(`if (${S} == `)):D?(o.push(`${S} == `),D=!1):o.push(` else if (${S} == `),I==="Integer")switch(this.getType(w[k].test)){case"Number":case"Float":this.castValueToInteger(w[k].test,o);break;case"LiteralInteger":this.castLiteralToInteger(w[k].test,o);break}else if(I==="Float")switch(this.getType(w[k].test)){case"LiteralInteger":this.castLiteralToFloat(w[k].test,o);break;case"Integer":this.castValueToFloat(w[k].test,o);break}else throw new Error("unhanlded");if(!w[k].consequent||w[k].consequent.length===0){D=!0,o.push(" || ");continue}o.push(`) {
`)}else if(w.length>k+1){T=!0,this.astGeneric(w[k].consequent,C);continue}else o.push(` else {
`);this.astGeneric(w[k].consequent,o),o.push(`
}`)}return T&&(o.push(" else {"),o.push(C.join("")),o.push("}")),o}astThisExpression(a,o){return o.push("this"),o}astMemberExpression(a,o){let{property:b,name:w,signature:I,origin:S,type:D,xProperty:C,yProperty:T,zProperty:_}=this.getMemberExpressionDetails(a);switch(I){case"value.thread.value":case"this.thread.value":if(w!=="x"&&w!=="y"&&w!=="z")throw this.astErrorOutput("Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`",a);return o.push(`threadId.${w}`),o;case"this.output.value":if(this.dynamicOutput)switch(w){case"x":this.isState("casting-to-float")?o.push("float(uOutputDim.x)"):o.push("uOutputDim.x");break;case"y":this.isState("casting-to-float")?o.push("float(uOutputDim.y)"):o.push("uOutputDim.y");break;case"z":this.isState("casting-to-float")?o.push("float(uOutputDim.z)"):o.push("uOutputDim.z");break;default:throw this.astErrorOutput("Unexpected expression",a)}else switch(w){case"x":this.isState("casting-to-integer")?o.push(this.output[0]):o.push(this.output[0],".0");break;case"y":this.isState("casting-to-integer")?o.push(this.output[1]):o.push(this.output[1],".0");break;case"z":this.isState("casting-to-integer")?o.push(this.output[2]):o.push(this.output[2],".0");break;default:throw this.astErrorOutput("Unexpected expression",a)}return o;case"value":throw this.astErrorOutput("Unexpected expression",a);case"value[]":case"value[][]":case"value[][][]":case"value[][][][]":case"value.value":if(S==="Math")return o.push(Math[w]),o;let M=p.sanitizeName(w);switch(b){case"r":return o.push(`user_${M}.r`),o;case"g":return o.push(`user_${M}.g`),o;case"b":return o.push(`user_${M}.b`),o;case"a":return o.push(`user_${M}.a`),o}break;case"this.constants.value":if(typeof C>"u")switch(D){case"Array(2)":case"Array(3)":case"Array(4)":return o.push(`constants_${p.sanitizeName(w)}`),o}case"this.constants.value[]":case"this.constants.value[][]":case"this.constants.value[][][]":case"this.constants.value[][][][]":break;case"fn()[]":return this.astCallExpression(a.object,o),o.push("["),o.push(this.memberExpressionPropertyMarkup(b)),o.push("]"),o;case"fn()[][]":return this.astCallExpression(a.object.object,o),o.push("["),o.push(this.memberExpressionPropertyMarkup(a.object.property)),o.push("]"),o.push("["),o.push(this.memberExpressionPropertyMarkup(a.property)),o.push("]"),o;case"[][]":return this.astArrayExpression(a.object,o),o.push("["),o.push(this.memberExpressionPropertyMarkup(b)),o.push("]"),o;default:throw this.astErrorOutput("Unexpected expression",a)}if(a.computed===!1)switch(D){case"Number":case"Integer":case"Float":case"Boolean":return o.push(`${S}_${p.sanitizeName(w)}`),o}let k=`${S}_${p.sanitizeName(w)}`;switch(D){case"Array(2)":case"Array(3)":case"Array(4)":this.astGeneric(a.object,o),o.push("["),o.push(this.memberExpressionPropertyMarkup(C)),o.push("]");break;case"HTMLImageArray":o.push(`getImage3D(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"ArrayTexture(1)":o.push(`getFloatFromSampler2D(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"Array1D(2)":case"Array2D(2)":case"Array3D(2)":o.push(`getMemoryOptimizedVec2(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"ArrayTexture(2)":o.push(`getVec2FromSampler2D(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"Array1D(3)":case"Array2D(3)":case"Array3D(3)":o.push(`getMemoryOptimizedVec3(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"ArrayTexture(3)":o.push(`getVec3FromSampler2D(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"Array1D(4)":case"Array2D(4)":case"Array3D(4)":o.push(`getMemoryOptimizedVec4(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"ArrayTexture(4)":case"HTMLCanvas":case"HTMLImage":case"HTMLVideo":o.push(`getVec4FromSampler2D(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"NumberTexture":case"Array":case"Array2D":case"Array3D":case"Array4D":case"Input":case"Number":case"Float":case"Integer":if(this.precision==="single")o.push(`getMemoryOptimized32(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");else{let M=S==="user"?this.lookupFunctionArgumentBitRatio(this.name,w):this.constantBitRatios[w];switch(M){case 1:o.push(`get8(${k}, ${k}Size, ${k}Dim, `);break;case 2:o.push(`get16(${k}, ${k}Size, ${k}Dim, `);break;case 4:case 0:o.push(`get32(${k}, ${k}Size, ${k}Dim, `);break;default:throw new Error(`unhandled bit ratio of ${M}`)}this.memberExpressionXYZ(C,T,_,o),o.push(")")}break;case"MemoryOptimizedNumberTexture":o.push(`getMemoryOptimized32(${k}, ${k}Size, ${k}Dim, `),this.memberExpressionXYZ(C,T,_,o),o.push(")");break;case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":o.push(`${k}[${this.memberExpressionPropertyMarkup(T)}]`),T&&o.push(`[${this.memberExpressionPropertyMarkup(C)}]`);break;default:throw new Error(`unhandled member expression "${D}"`)}return o}astCallExpression(a,o){if(!a.callee)throw this.astErrorOutput("Unknown CallExpression",a);let b=null,w=this.isAstMathFunction(a);if(w||a.callee.object&&a.callee.object.type==="ThisExpression"?b=a.callee.property.name:a.callee.type==="SequenceExpression"&&a.callee.expressions[0].type==="Literal"&&!isNaN(a.callee.expressions[0].raw)?b=a.callee.expressions[1].property.name:b=a.callee.name,!b)throw this.astErrorOutput("Unhandled function, couldn't find name",a);switch(b){case"pow":b="_pow";break;case"round":b="_round";break}if(this.calledFunctions.indexOf(b)<0&&this.calledFunctions.push(b),b==="random"&&this.plugins&&this.plugins.length>0)for(let I=0;I<this.plugins.length;I++){let S=this.plugins[I];if(S.functionMatch==="Math.random()"&&S.functionReplace)return o.push(S.functionReplace),o}if(this.onFunctionCall&&this.onFunctionCall(this.name,b,a.arguments),o.push(b),o.push("("),w)for(let I=0;I<a.arguments.length;++I){let S=a.arguments[I],D=this.getType(S);switch(I>0&&o.push(", "),D){case"Integer":this.castValueToFloat(S,o);break;default:this.astGeneric(S,o);break}}else{let I=this.lookupFunctionArgumentTypes(b)||[];for(let S=0;S<a.arguments.length;++S){let D=a.arguments[S],C=I[S];S>0&&o.push(", ");let T=this.getType(D);switch(C||(this.triggerImplyArgumentType(b,S,T,this),C=T),T){case"Boolean":this.astGeneric(D,o);continue;case"Number":case"Float":if(C==="Integer"){o.push("int("),this.astGeneric(D,o),o.push(")");continue}else if(C==="Number"||C==="Float"){this.astGeneric(D,o);continue}else if(C==="LiteralInteger"){this.castLiteralToFloat(D,o);continue}break;case"Integer":if(C==="Number"||C==="Float"){o.push("float("),this.astGeneric(D,o),o.push(")");continue}else if(C==="Integer"){this.astGeneric(D,o);continue}break;case"LiteralInteger":if(C==="Integer"){this.castLiteralToInteger(D,o);continue}else if(C==="Number"||C==="Float"){this.castLiteralToFloat(D,o);continue}else if(C==="LiteralInteger"){this.astGeneric(D,o);continue}break;case"Array(2)":case"Array(3)":case"Array(4)":if(C===T){if(D.type==="Identifier")o.push(`user_${p.sanitizeName(D.name)}`);else if(D.type==="ArrayExpression"||D.type==="MemberExpression"||D.type==="CallExpression")this.astGeneric(D,o);else throw this.astErrorOutput(`Unhandled argument type ${D.type}`,a);continue}break;case"HTMLCanvas":case"HTMLImage":case"HTMLImageArray":case"HTMLVideo":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":case"Array":case"Input":if(C===T){if(D.type!=="Identifier")throw this.astErrorOutput(`Unhandled argument type ${D.type}`,a);this.triggerImplyArgumentBitRatio(this.name,D.name,b,S);let _=p.sanitizeName(D.name);o.push(`user_${_},user_${_}Size,user_${_}Dim`);continue}break}throw this.astErrorOutput(`Unhandled argument combination of ${T} and ${C} for argument named "${D.name}"`,a)}}return o.push(")"),o}astArrayExpression(a,o){let b=this.getType(a),w=a.elements.length;switch(b){case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":o.push(`mat${w}(`);break;default:o.push(`vec${w}(`)}for(let I=0;I<w;++I){I>0&&o.push(", ");let S=a.elements[I];this.astGeneric(S,o)}return o.push(")"),o}memberExpressionXYZ(a,o,b,w){return b?w.push(this.memberExpressionPropertyMarkup(b),", "):w.push("0, "),o?w.push(this.memberExpressionPropertyMarkup(o),", "):w.push("0, "),w.push(this.memberExpressionPropertyMarkup(a)),w}memberExpressionPropertyMarkup(a){if(!a)throw new Error("Property not set");let o=this.getType(a),b=[];switch(o){case"Number":case"Float":this.castValueToInteger(a,b);break;case"LiteralInteger":this.castLiteralToInteger(a,b);break;default:this.astGeneric(a,b)}return b.join("")}}let m={Array:"sampler2D","Array(2)":"vec2","Array(3)":"vec3","Array(4)":"vec4","Matrix(2)":"mat2","Matrix(3)":"mat3","Matrix(4)":"mat4",Array2D:"sampler2D",Array3D:"sampler2D",Boolean:"bool",Float:"float",Input:"sampler2D",Integer:"int",Number:"float",LiteralInteger:"float",NumberTexture:"sampler2D",MemoryOptimizedNumberTexture:"sampler2D","ArrayTexture(1)":"sampler2D","ArrayTexture(2)":"sampler2D","ArrayTexture(3)":"sampler2D","ArrayTexture(4)":"sampler2D",HTMLVideo:"sampler2D",HTMLCanvas:"sampler2D",HTMLImage:"sampler2D",HTMLImageArray:"sampler2DArray"},l={"===":"==","!==":"!="};c.exports={WebGLFunctionNode:v}},{"../../utils":114,"../function-node":10}],39:[function(i,c,d){let{WebGLKernelValueBoolean:p}=i("./kernel-value/boolean"),{WebGLKernelValueFloat:y}=i("./kernel-value/float"),{WebGLKernelValueInteger:v}=i("./kernel-value/integer"),{WebGLKernelValueHTMLImage:m}=i("./kernel-value/html-image"),{WebGLKernelValueDynamicHTMLImage:l}=i("./kernel-value/dynamic-html-image"),{WebGLKernelValueHTMLVideo:h}=i("./kernel-value/html-video"),{WebGLKernelValueDynamicHTMLVideo:a}=i("./kernel-value/dynamic-html-video"),{WebGLKernelValueSingleInput:o}=i("./kernel-value/single-input"),{WebGLKernelValueDynamicSingleInput:b}=i("./kernel-value/dynamic-single-input"),{WebGLKernelValueUnsignedInput:w}=i("./kernel-value/unsigned-input"),{WebGLKernelValueDynamicUnsignedInput:I}=i("./kernel-value/dynamic-unsigned-input"),{WebGLKernelValueMemoryOptimizedNumberTexture:S}=i("./kernel-value/memory-optimized-number-texture"),{WebGLKernelValueDynamicMemoryOptimizedNumberTexture:D}=i("./kernel-value/dynamic-memory-optimized-number-texture"),{WebGLKernelValueNumberTexture:C}=i("./kernel-value/number-texture"),{WebGLKernelValueDynamicNumberTexture:T}=i("./kernel-value/dynamic-number-texture"),{WebGLKernelValueSingleArray:_}=i("./kernel-value/single-array"),{WebGLKernelValueDynamicSingleArray:k}=i("./kernel-value/dynamic-single-array"),{WebGLKernelValueSingleArray1DI:M}=i("./kernel-value/single-array1d-i"),{WebGLKernelValueDynamicSingleArray1DI:P}=i("./kernel-value/dynamic-single-array1d-i"),{WebGLKernelValueSingleArray2DI:A}=i("./kernel-value/single-array2d-i"),{WebGLKernelValueDynamicSingleArray2DI:f}=i("./kernel-value/dynamic-single-array2d-i"),{WebGLKernelValueSingleArray3DI:R}=i("./kernel-value/single-array3d-i"),{WebGLKernelValueDynamicSingleArray3DI:N}=i("./kernel-value/dynamic-single-array3d-i"),{WebGLKernelValueSingleArray2:K}=i("./kernel-value/single-array2"),{WebGLKernelValueSingleArray3:O}=i("./kernel-value/single-array3"),{WebGLKernelValueSingleArray4:V}=i("./kernel-value/single-array4"),{WebGLKernelValueUnsignedArray:j}=i("./kernel-value/unsigned-array"),{WebGLKernelValueDynamicUnsignedArray:z}=i("./kernel-value/dynamic-unsigned-array"),q={unsigned:{dynamic:{Boolean:p,Integer:v,Float:y,Array:z,"Array(2)":!1,"Array(3)":!1,"Array(4)":!1,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:I,NumberTexture:T,"ArrayTexture(1)":T,"ArrayTexture(2)":T,"ArrayTexture(3)":T,"ArrayTexture(4)":T,MemoryOptimizedNumberTexture:D,HTMLCanvas:l,HTMLImage:l,HTMLImageArray:!1,HTMLVideo:a},static:{Boolean:p,Float:y,Integer:v,Array:j,"Array(2)":!1,"Array(3)":!1,"Array(4)":!1,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:w,NumberTexture:C,"ArrayTexture(1)":C,"ArrayTexture(2)":C,"ArrayTexture(3)":C,"ArrayTexture(4)":C,MemoryOptimizedNumberTexture:S,HTMLCanvas:m,HTMLImage:m,HTMLImageArray:!1,HTMLVideo:h}},single:{dynamic:{Boolean:p,Integer:v,Float:y,Array:k,"Array(2)":K,"Array(3)":O,"Array(4)":V,"Array1D(2)":P,"Array1D(3)":P,"Array1D(4)":P,"Array2D(2)":f,"Array2D(3)":f,"Array2D(4)":f,"Array3D(2)":N,"Array3D(3)":N,"Array3D(4)":N,Input:b,NumberTexture:T,"ArrayTexture(1)":T,"ArrayTexture(2)":T,"ArrayTexture(3)":T,"ArrayTexture(4)":T,MemoryOptimizedNumberTexture:D,HTMLCanvas:l,HTMLImage:l,HTMLImageArray:!1,HTMLVideo:a},static:{Boolean:p,Float:y,Integer:v,Array:_,"Array(2)":K,"Array(3)":O,"Array(4)":V,"Array1D(2)":M,"Array1D(3)":M,"Array1D(4)":M,"Array2D(2)":A,"Array2D(3)":A,"Array2D(4)":A,"Array3D(2)":R,"Array3D(3)":R,"Array3D(4)":R,Input:o,NumberTexture:C,"ArrayTexture(1)":C,"ArrayTexture(2)":C,"ArrayTexture(3)":C,"ArrayTexture(4)":C,MemoryOptimizedNumberTexture:S,HTMLCanvas:m,HTMLImage:m,HTMLImageArray:!1,HTMLVideo:h}}};function H(U,J,ee,Z){if(!U)throw new Error("type missing");if(!J)throw new Error("dynamic missing");if(!ee)throw new Error("precision missing");Z.type&&(U=Z.type);let Y=q[ee][J];if(Y[U]===!1)return null;if(Y[U]===void 0)throw new Error(`Could not find a KernelValue for ${U}`);return Y[U]}c.exports={lookupKernelValueType:H,kernelValueMaps:q}},{"./kernel-value/boolean":41,"./kernel-value/dynamic-html-image":42,"./kernel-value/dynamic-html-video":43,"./kernel-value/dynamic-memory-optimized-number-texture":44,"./kernel-value/dynamic-number-texture":45,"./kernel-value/dynamic-single-array":46,"./kernel-value/dynamic-single-array1d-i":47,"./kernel-value/dynamic-single-array2d-i":48,"./kernel-value/dynamic-single-array3d-i":49,"./kernel-value/dynamic-single-input":50,"./kernel-value/dynamic-unsigned-array":51,"./kernel-value/dynamic-unsigned-input":52,"./kernel-value/float":53,"./kernel-value/html-image":54,"./kernel-value/html-video":55,"./kernel-value/integer":57,"./kernel-value/memory-optimized-number-texture":58,"./kernel-value/number-texture":59,"./kernel-value/single-array":60,"./kernel-value/single-array1d-i":61,"./kernel-value/single-array2":62,"./kernel-value/single-array2d-i":63,"./kernel-value/single-array3":64,"./kernel-value/single-array3d-i":65,"./kernel-value/single-array4":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(i,c,d){let{WebGLKernelValue:p}=i("./index"),{Input:y}=i("../../../input");class v extends p{checkSize(l,h){if(!this.kernel.validate)return;let{maxTextureSize:a}=this.kernel.constructor.features;if(l>a||h>a)throw l>h?new Error(`Argument texture width of ${l} larger than maximum size of ${a} for your GPU`):l<h?new Error(`Argument texture height of ${h} larger than maximum size of ${a} for your GPU`):new Error(`Argument texture height and width of ${h} larger than maximum size of ${a} for your GPU`)}setup(){this.requestTexture(),this.setupTexture(),this.defineTexture()}requestTexture(){this.texture=this.onRequestTexture()}defineTexture(){let{context:l}=this;l.activeTexture(this.contextHandle),l.bindTexture(l.TEXTURE_2D,this.texture),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.NEAREST)}setupTexture(){this.contextHandle=this.onRequestContextHandle(),this.index=this.onRequestIndex(),this.dimensionsId=this.id+"Dim",this.sizeId=this.id+"Size"}getBitRatio(l){if(Array.isArray(l[0]))return this.getBitRatio(l[0]);if(l.constructor===y)return this.getBitRatio(l.value);switch(l.constructor){case Uint8ClampedArray:case Uint8Array:case Int8Array:return 1;case Uint16Array:case Int16Array:return 2;case Float32Array:case Int32Array:default:return 4}}destroy(){this.prevArg&&this.prevArg.delete(),this.context.deleteTexture(this.texture)}}c.exports={WebGLKernelArray:v}},{"../../../input":110,"./index":56}],41:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValue:y}=i("./index");class v extends y{constructor(l,h){super(l,h),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const bool ${this.id} = ${l};
`:`uniform bool ${this.id};
`}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=l)}}c.exports={WebGLKernelValueBoolean:v}},{"../../../utils":114,"./index":56}],42:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueHTMLImage:y}=i("./html-image");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){let{width:h,height:a}=l;this.checkSize(h,a),this.dimensions=[h,a,1],this.textureSize=[h,a],this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicHTMLImage:v}},{"../../../utils":114,"./html-image":54}],43:[function(i,c,d){let{WebGLKernelValueDynamicHTMLImage:p}=i("./dynamic-html-image");class y extends p{}c.exports={WebGLKernelValueDynamicHTMLVideo:y}},{"./dynamic-html-image":42}],44:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueMemoryOptimizedNumberTexture:y}=i("./memory-optimized-number-texture");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=l.dimensions,this.checkSize(l.size[0],l.size[1]),this.textureSize=l.size,this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicMemoryOptimizedNumberTexture:v}},{"../../../utils":114,"./memory-optimized-number-texture":58}],45:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueNumberTexture:y}=i("./number-texture");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=l.dimensions,this.checkSize(l.size[0],l.size[1]),this.textureSize=l.size,this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicNumberTexture:v}},{"../../../utils":114,"./number-texture":59}],46:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray:y}=i("./single-array");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=p.getDimensions(l,!0),this.textureSize=p.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicSingleArray:v}},{"../../../utils":114,"./single-array":60}],47:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray1DI:y}=i("./single-array1d-i");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicSingleArray1DI:v}},{"../../../utils":114,"./single-array1d-i":61}],48:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray2DI:y}=i("./single-array2d-i");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicSingleArray2DI:v}},{"../../../utils":114,"./single-array2d-i":63}],49:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray3DI:y}=i("./single-array3d-i");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicSingleArray3DI:v}},{"../../../utils":114,"./single-array3d-i":65}],50:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleInput:y}=i("./single-input");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){let[h,a,o]=l.size;this.dimensions=new Int32Array([h||1,a||1,o||1]),this.textureSize=p.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicSingleInput:v}},{"../../../utils":114,"./single-input":67}],51:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueUnsignedArray:y}=i("./unsigned-array");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=p.getDimensions(l,!0),this.textureSize=p.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]);let h=this.getTransferArrayType(l);this.preUploadValue=new h(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicUnsignedArray:v}},{"../../../utils":114,"./unsigned-array":68}],52:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueUnsignedInput:y}=i("./unsigned-input");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}updateValue(l){let[h,a,o]=l.size;this.dimensions=new Int32Array([h||1,a||1,o||1]),this.textureSize=p.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]);let b=this.getTransferArrayType(l.value);this.preUploadValue=new b(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGLKernelValueDynamicUnsignedInput:v}},{"../../../utils":114,"./unsigned-input":69}],53:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValue:y}=i("./index");class v extends y{constructor(l,h){super(l,h),this.uploadValue=l}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(l){return this.origin==="constants"?Number.isInteger(l)?`const float ${this.id} = ${l}.0;
`:`const float ${this.id} = ${l};
`:`uniform float ${this.id};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1f(this.id,this.uploadValue=l)}}c.exports={WebGLKernelValueFloat:v}},{"../../../utils":114,"./index":56}],54:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h);let{width:a,height:o}=l;this.checkSize(a,o),this.dimensions=[a,o,1],this.textureSize=[a,o],this.uploadValue=l}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!0),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue=l),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueHTMLImage:v}},{"../../../utils":114,"./array":40}],55:[function(i,c,d){let{WebGLKernelValueHTMLImage:p}=i("./html-image");class y extends p{}c.exports={WebGLKernelValueHTMLVideo:y}},{"./html-image":54}],56:[function(i,c,d){let{utils:p}=i("../../../utils"),{KernelValue:y}=i("../../kernel-value");class v extends y{constructor(l,h){super(l,h),this.dimensionsId=null,this.sizeId=null,this.initialValueConstructor=l.constructor,this.onRequestTexture=h.onRequestTexture,this.onRequestIndex=h.onRequestIndex,this.uploadValue=null,this.textureSize=null,this.bitRatio=null,this.prevArg=null}get id(){return`${this.origin}_${p.sanitizeName(this.name)}`}setup(){}getTransferArrayType(l){if(Array.isArray(l[0]))return this.getTransferArrayType(l[0]);switch(l.constructor){case Array:case Int32Array:case Int16Array:case Int8Array:return Float32Array;case Uint8ClampedArray:case Uint8Array:case Uint16Array:case Uint32Array:case Float32Array:case Float64Array:return l.constructor}return console.warn("Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros"),l.constructor}getStringValueHandler(){throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`)}getVariablePrecisionString(){return this.kernel.getVariablePrecisionString(this.textureSize||void 0,this.tactic||void 0)}destroy(){}}c.exports={WebGLKernelValue:v}},{"../../../utils":114,"../../kernel-value":35}],57:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValue:y}=i("./index");class v extends y{constructor(l,h){super(l,h),this.uploadValue=l}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(l){return this.origin==="constants"?`const int ${this.id} = ${parseInt(l)};
`:`uniform int ${this.id};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=l)}}c.exports={WebGLKernelValueInteger:v}},{"../../../utils":114,"./index":56}],58:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array"),v="Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()";class m extends y{constructor(h,a){super(h,a);let[o,b]=h.size;this.checkSize(o,b),this.dimensions=h.dimensions,this.textureSize=h.size,this.uploadValue=h.texture,this.forceUploadEachRun=!0}setup(){this.setupTexture()}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName}.texture;
`}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(h){if(h.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(h.constructor);return}if(this.checkContext&&h.context!==this.context)throw new Error(`Value ${this.name} (${this.type}) must be from same context`);let{kernel:a,context:o}=this;if(a.pipeline)if(a.immutable)a.updateTextureArgumentRefs(this,h);else{if(a.texture.texture===h.texture)throw new Error(v);if(a.mappedTextures){let{mappedTextures:b}=a;for(let w=0;w<b.length;w++)if(b[w].texture===h.texture)throw new Error(v)}}o.activeTexture(this.contextHandle),o.bindTexture(o.TEXTURE_2D,this.uploadValue=h.texture),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueMemoryOptimizedNumberTexture:m,sameError:v}},{"../../../utils":114,"./array":40}],59:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array"),{sameError:v}=i("./memory-optimized-number-texture");class m extends y{constructor(h,a){super(h,a);let[o,b]=h.size;this.checkSize(o,b);let{size:w,dimensions:I}=h;this.bitRatio=this.getBitRatio(h),this.dimensions=I,this.textureSize=w,this.uploadValue=h.texture,this.forceUploadEachRun=!0}setup(){this.setupTexture()}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName}.texture;
`}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(h){if(h.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(h.constructor);return}if(this.checkContext&&h.context!==this.context)throw new Error(`Value ${this.name} (${this.type}) must be from same context`);let{kernel:a,context:o}=this;if(a.pipeline)if(a.immutable)a.updateTextureArgumentRefs(this,h);else{if(a.texture.texture===h.texture)throw new Error(v);if(a.mappedTextures){let{mappedTextures:b}=a;for(let w=0;w<b.length;w++)if(b[w].texture===h.texture)throw new Error(v)}}o.activeTexture(this.contextHandle),o.bindTexture(o.TEXTURE_2D,this.uploadValue=h.texture),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueNumberTexture:m}},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":58}],60:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=4,this.dimensions=p.getDimensions(l,!0),this.textureSize=p.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return p.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueSingleArray:v}},{"../../../utils":114,"./array":40}],61:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=4,this.setShape(l)}setShape(l){let h=p.getDimensions(l,!0);this.textureSize=p.getMemoryOptimizedFloatTextureSize(h,this.bitRatio),this.dimensions=new Int32Array([h[1],1,1]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return p.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flatten2dArrayTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueSingleArray1DI:v}},{"../../../utils":114,"./array":40}],62:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValue:y}=i("./index");class v extends y{constructor(l,h){super(l,h),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const vec2 ${this.id} = vec2(${l[0]},${l[1]});
`:`uniform vec2 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform2fv(this.id,this.uploadValue=l)}}c.exports={WebGLKernelValueSingleArray2:v}},{"../../../utils":114,"./index":56}],63:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=4,this.setShape(l)}setShape(l){let h=p.getDimensions(l,!0);this.textureSize=p.getMemoryOptimizedFloatTextureSize(h,this.bitRatio),this.dimensions=new Int32Array([h[1],h[2],1]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return p.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flatten3dArrayTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueSingleArray2DI:v}},{"../../../utils":114,"./array":40}],64:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValue:y}=i("./index");class v extends y{constructor(l,h){super(l,h),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const vec3 ${this.id} = vec3(${l[0]},${l[1]},${l[2]});
`:`uniform vec3 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform3fv(this.id,this.uploadValue=l)}}c.exports={WebGLKernelValueSingleArray3:v}},{"../../../utils":114,"./index":56}],65:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=4,this.setShape(l)}setShape(l){let h=p.getDimensions(l,!0);this.textureSize=p.getMemoryOptimizedFloatTextureSize(h,this.bitRatio),this.dimensions=new Int32Array([h[1],h[2],h[3]]),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return p.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}, uploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flatten4dArrayTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueSingleArray3DI:v}},{"../../../utils":114,"./array":40}],66:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValue:y}=i("./index");class v extends y{constructor(l,h){super(l,h),this.uploadValue=l}getSource(l){return this.origin==="constants"?`const vec4 ${this.id} = vec4(${l[0]},${l[1]},${l[2]},${l[3]});
`:`uniform vec4 ${this.id};
`}getStringValueHandler(){return this.origin==="constants"?"":`const uploadValue_${this.name} = ${this.varName};
`}updateValue(l){this.origin!=="constants"&&this.kernel.setUniform4fv(this.id,this.uploadValue=l)}}c.exports={WebGLKernelValueSingleArray4:v}},{"../../../utils":114,"./index":56}],67:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=4;let[a,o,b]=l.size;this.dimensions=new Int32Array([a||1,o||1,b||1]),this.textureSize=p.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength)}getStringValueHandler(){return p.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,`flattenTo(${this.varName}.value, uploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l.value,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueSingleInput:v}},{"../../../utils":114,"./array":40}],68:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=this.getBitRatio(l),this.dimensions=p.getDimensions(l,!0),this.textureSize=p.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]),this.TranserArrayType=this.getTransferArrayType(l),this.preUploadValue=new this.TranserArrayType(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer)}getStringValueHandler(){return p.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,`const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,`flattenTo(${this.varName}, preUploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l,this.preUploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueUnsignedArray:v}},{"../../../utils":114,"./array":40}],69:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("./array");class v extends y{constructor(l,h){super(l,h),this.bitRatio=this.getBitRatio(l);let[a,o,b]=l.size;this.dimensions=new Int32Array([a||1,o||1,b||1]),this.textureSize=p.getMemoryOptimizedPackedTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*(4/this.bitRatio),this.checkSize(this.textureSize[0],this.textureSize[1]),this.TranserArrayType=this.getTransferArrayType(l.value),this.preUploadValue=new this.TranserArrayType(this.uploadArrayLength),this.uploadValue=new Uint8Array(this.preUploadValue.buffer)}getStringValueHandler(){return p.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,`const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,`flattenTo(${this.varName}.value, preUploadValue_${this.name})`])}getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(value.constructor);return}let{context:h}=this;p.flattenTo(l.value,this.preUploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGLKernelValueUnsignedInput:v}},{"../../../utils":114,"./array":40}],70:[function(i,c,d){let{GLKernel:p}=i("../gl/kernel"),{FunctionBuilder:y}=i("../function-builder"),{WebGLFunctionNode:v}=i("./function-node"),{utils:m}=i("../../utils"),l=i("../../plugins/math-random-uniformly-distributed"),{fragmentShader:h}=i("./fragment-shader"),{vertexShader:a}=i("./vertex-shader"),{glKernelString:o}=i("../gl/kernel-string"),{lookupKernelValueType:b}=i("./kernel-value-maps"),w=null,I=null,S=null,D=null,C=null,T=[l],_=[],k={};class M extends p{static get isSupported(){return w!==null||(this.setupFeatureChecks(),w=this.isContextMatch(S)),w}static setupFeatureChecks(){typeof document<"u"?I=document.createElement("canvas"):typeof OffscreenCanvas<"u"&&(I=new OffscreenCanvas(0,0)),I&&(S=I.getContext("webgl")||I.getContext("experimental-webgl"),!(!S||!S.getExtension)&&(D={OES_texture_float:S.getExtension("OES_texture_float"),OES_texture_float_linear:S.getExtension("OES_texture_float_linear"),OES_element_index_uint:S.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:S.getExtension("WEBGL_draw_buffers")},C=this.getFeatures()))}static isContextMatch(A){return typeof WebGLRenderingContext<"u"?A instanceof WebGLRenderingContext:!1}static getIsTextureFloat(){return Boolean(D.OES_texture_float)}static getIsDrawBuffers(){return Boolean(D.WEBGL_draw_buffers)}static getChannelCount(){return D.WEBGL_draw_buffers?S.getParameter(D.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL):1}static getMaxTextureSize(){return S.getParameter(S.MAX_TEXTURE_SIZE)}static lookupKernelValueType(A,f,R,N){return b(A,f,R,N)}static get testCanvas(){return I}static get testContext(){return S}static get features(){return C}static get fragmentShader(){return h}static get vertexShader(){return a}constructor(A,f){super(A,f),this.program=null,this.pipeline=f.pipeline,this.endianness=m.systemEndianness(),this.extensions={},this.argumentTextureCount=0,this.constantTextureCount=0,this.fragShader=null,this.vertShader=null,this.drawBuffersMap=null,this.maxTexSize=null,this.onRequestSwitchKernel=null,this.texture=null,this.mappedTextures=null,this.mergeSettings(A.settings||f),this.threadDim=null,this.framebuffer=null,this.buffer=null,this.textureCache=[],this.programUniformLocationCache={},this.uniform1fCache={},this.uniform1iCache={},this.uniform2fCache={},this.uniform2fvCache={},this.uniform2ivCache={},this.uniform3fvCache={},this.uniform3ivCache={},this.uniform4fvCache={},this.uniform4ivCache={}}initCanvas(){if(typeof document<"u"){let A=document.createElement("canvas");return A.width=2,A.height=2,A}else if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(0,0)}initContext(){let A={alpha:!1,depth:!1,antialias:!1};return this.canvas.getContext("webgl",A)||this.canvas.getContext("experimental-webgl",A)}initPlugins(A){let f=[],{source:R}=this;if(typeof R=="string")for(let N=0;N<T.length;N++){let K=T[N];R.match(K.functionMatch)&&f.push(K)}else if(typeof R=="object"&&A.pluginNames)for(let N=0;N<T.length;N++){let K=T[N];A.pluginNames.some(O=>O===K.name)&&f.push(K)}return f}initExtensions(){this.extensions={OES_texture_float:this.context.getExtension("OES_texture_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear"),OES_element_index_uint:this.context.getExtension("OES_element_index_uint"),WEBGL_draw_buffers:this.context.getExtension("WEBGL_draw_buffers"),WEBGL_color_buffer_float:this.context.getExtension("WEBGL_color_buffer_float")}}validateSettings(A){if(!this.validate){this.texSize=m.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output);return}let{features:f}=this.constructor;if(this.optimizeFloatMemory===!0&&!f.isTextureFloat)throw new Error("Float textures are not supported");if(this.precision==="single"&&!f.isFloatRead)throw new Error("Single precision not supported");if(!this.graphical&&this.precision===null&&f.isTextureFloat&&(this.precision=f.isFloatRead?"single":"unsigned"),this.subKernels&&this.subKernels.length>0&&!this.extensions.WEBGL_draw_buffers)throw new Error("could not instantiate draw buffers extension");if(this.fixIntegerDivisionAccuracy===null?this.fixIntegerDivisionAccuracy=!f.isIntegerDivisionAccurate:this.fixIntegerDivisionAccuracy&&f.isIntegerDivisionAccurate&&(this.fixIntegerDivisionAccuracy=!1),this.checkOutput(),!this.output||this.output.length===0){if(A.length!==1)throw new Error("Auto output only supported for kernels with only one input");let R=m.getVariableType(A[0],this.strictIntegers);switch(R){case"Array":this.output=m.getDimensions(R);break;case"NumberTexture":case"MemoryOptimizedNumberTexture":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":this.output=A[0].output;break;default:throw new Error("Auto output not supported for input type: "+R)}}if(this.graphical){if(this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.precision==="precision"&&(this.precision="unsigned",console.warn("Cannot use graphical mode and single precision at the same time")),this.texSize=m.clone(this.output);return}else this.precision===null&&f.isTextureFloat&&(this.precision="single");this.texSize=m.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output),this.checkTextureSize()}updateMaxTexSize(){let{texSize:A,canvas:f}=this;if(this.maxTexSize===null){let R=_.indexOf(f);R===-1&&(R=_.length,_.push(f),k[R]=[A[0],A[1]]),this.maxTexSize=k[R]}this.maxTexSize[0]<A[0]&&(this.maxTexSize[0]=A[0]),this.maxTexSize[1]<A[1]&&(this.maxTexSize[1]=A[1])}setupArguments(A){this.kernelArguments=[],this.argumentTextureCount=0;let f=this.argumentTypes===null;if(f&&(this.argumentTypes=[]),this.argumentSizes=[],this.argumentBitRatios=[],A.length<this.argumentNames.length)throw new Error("not enough arguments for kernel");if(A.length>this.argumentNames.length)throw new Error("too many arguments for kernel");let{context:R}=this,N=0,K=()=>this.createTexture(),O=()=>this.constantTextureCount+N++,V=z=>{this.switchKernels({type:"argumentMismatch",needed:z})},j=()=>R.TEXTURE0+this.constantTextureCount+this.argumentTextureCount++;for(let z=0;z<A.length;z++){let q=A[z],H=this.argumentNames[z],U;f?(U=m.getVariableType(q,this.strictIntegers),this.argumentTypes.push(U)):U=this.argumentTypes[z];let J=this.constructor.lookupKernelValueType(U,this.dynamicArguments?"dynamic":"static",this.precision,A[z]);if(J===null)return this.requestFallback(A);let ee=new J(q,{name:H,type:U,tactic:this.tactic,origin:"user",context:R,checkContext:this.checkContext,kernel:this,strictIntegers:this.strictIntegers,onRequestTexture:K,onRequestIndex:O,onUpdateValueMismatch:V,onRequestContextHandle:j});this.kernelArguments.push(ee),ee.setup(),this.argumentSizes.push(ee.textureSize),this.argumentBitRatios[z]=ee.bitRatio}}createTexture(){let A=this.context.createTexture();return this.textureCache.push(A),A}setupConstants(A){let{context:f}=this;this.kernelConstants=[],this.forceUploadKernelConstants=[];let R=this.constantTypes===null;R&&(this.constantTypes={}),this.constantBitRatios={};let N=0;for(let K in this.constants){let O=this.constants[K],V;R?(V=m.getVariableType(O,this.strictIntegers),this.constantTypes[K]=V):V=this.constantTypes[K];let j=this.constructor.lookupKernelValueType(V,"static",this.precision,O);if(j===null)return this.requestFallback(A);let z=new j(O,{name:K,type:V,tactic:this.tactic,origin:"constants",context:this.context,checkContext:this.checkContext,kernel:this,strictIntegers:this.strictIntegers,onRequestTexture:()=>this.createTexture(),onRequestIndex:()=>N++,onRequestContextHandle:()=>f.TEXTURE0+this.constantTextureCount++});this.constantBitRatios[K]=z.bitRatio,this.kernelConstants.push(z),z.setup(),z.forceUploadEachRun&&this.forceUploadKernelConstants.push(z)}}build(){if(this.built||(this.initExtensions(),this.validateSettings(arguments),this.setupConstants(arguments),this.fallbackRequested)||(this.setupArguments(arguments),this.fallbackRequested))return;this.updateMaxTexSize(),this.translateSource();let A=this.pickRenderStrategy(arguments);if(A)return A;let{texSize:f,context:R,canvas:N}=this;R.enable(R.SCISSOR_TEST),this.pipeline&&this.precision==="single"?(R.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),N.width=this.maxTexSize[0],N.height=this.maxTexSize[1]):(R.viewport(0,0,this.maxTexSize[0],this.maxTexSize[1]),N.width=this.maxTexSize[0],N.height=this.maxTexSize[1]);let K=this.threadDim=Array.from(this.output);for(;K.length<3;)K.push(1);let O=this.getVertexShader(arguments),V=R.createShader(R.VERTEX_SHADER);R.shaderSource(V,O),R.compileShader(V),this.vertShader=V;let j=this.getFragmentShader(arguments),z=R.createShader(R.FRAGMENT_SHADER);if(R.shaderSource(z,j),R.compileShader(z),this.fragShader=z,this.debug&&(console.log("GLSL Shader Output:"),console.log(j)),!R.getShaderParameter(V,R.COMPILE_STATUS))throw new Error("Error compiling vertex shader: "+R.getShaderInfoLog(V));if(!R.getShaderParameter(z,R.COMPILE_STATUS))throw new Error("Error compiling fragment shader: "+R.getShaderInfoLog(z));let q=this.program=R.createProgram();R.attachShader(q,V),R.attachShader(q,z),R.linkProgram(q),this.framebuffer=R.createFramebuffer(),this.framebuffer.width=f[0],this.framebuffer.height=f[1],this.rawValueFramebuffers={};let H=new Float32Array([-1,-1,1,-1,-1,1,1,1]),U=new Float32Array([0,0,1,0,0,1,1,1]),J=H.byteLength,ee=this.buffer;ee?R.bindBuffer(R.ARRAY_BUFFER,ee):(ee=this.buffer=R.createBuffer(),R.bindBuffer(R.ARRAY_BUFFER,ee),R.bufferData(R.ARRAY_BUFFER,H.byteLength+U.byteLength,R.STATIC_DRAW)),R.bufferSubData(R.ARRAY_BUFFER,0,H),R.bufferSubData(R.ARRAY_BUFFER,J,U);let Z=R.getAttribLocation(this.program,"aPos");R.enableVertexAttribArray(Z),R.vertexAttribPointer(Z,2,R.FLOAT,!1,0,0);let Y=R.getAttribLocation(this.program,"aTexCoord");R.enableVertexAttribArray(Y),R.vertexAttribPointer(Y,2,R.FLOAT,!1,0,J),R.bindFramebuffer(R.FRAMEBUFFER,this.framebuffer);let X=0;R.useProgram(this.program);for(let ge in this.constants)this.kernelConstants[X++].updateValue(this.constants[ge]);this._setupOutputTexture(),this.subKernels!==null&&this.subKernels.length>0&&(this._mappedTextureSwitched={},this._setupSubOutputTextures()),this.buildSignature(arguments),this.built=!0}translateSource(){let A=y.fromKernel(this,v,{fixIntegerDivisionAccuracy:this.fixIntegerDivisionAccuracy});this.translatedSource=A.getPrototypeString("kernel"),this.setupReturnTypes(A)}setupReturnTypes(A){if(!this.graphical&&!this.returnType&&(this.returnType=A.getKernelResultType()),this.subKernels&&this.subKernels.length>0)for(let f=0;f<this.subKernels.length;f++){let R=this.subKernels[f];R.returnType||(R.returnType=A.getSubKernelResultType(f))}}run(){let{kernelArguments:A,texSize:f,forceUploadKernelConstants:R,context:N}=this;N.useProgram(this.program),N.scissor(0,0,f[0],f[1]),this.dynamicOutput&&(this.setUniform3iv("uOutputDim",new Int32Array(this.threadDim)),this.setUniform2iv("uTexSize",f)),this.setUniform2f("ratio",f[0]/this.maxTexSize[0],f[1]/this.maxTexSize[1]);for(let K=0;K<R.length;K++){let O=R[K];if(O.updateValue(this.constants[O.name]),this.switchingKernels)return}for(let K=0;K<A.length;K++)if(A[K].updateValue(arguments[K]),this.switchingKernels)return;if(this.plugins)for(let K=0;K<this.plugins.length;K++){let O=this.plugins[K];O.onBeforeRun&&O.onBeforeRun(this)}if(this.graphical){if(this.pipeline)return N.bindRenderbuffer(N.RENDERBUFFER,null),N.bindFramebuffer(N.FRAMEBUFFER,this.framebuffer),this.immutable&&this._replaceOutputTexture(),N.drawArrays(N.TRIANGLE_STRIP,0,4),this.immutable?this.texture.clone():this.texture;N.bindRenderbuffer(N.RENDERBUFFER,null),N.bindFramebuffer(N.FRAMEBUFFER,null),N.drawArrays(N.TRIANGLE_STRIP,0,4);return}N.bindFramebuffer(N.FRAMEBUFFER,this.framebuffer),this.immutable&&this._replaceOutputTexture(),this.subKernels!==null&&(this.immutable&&this._replaceSubOutputTextures(),this.drawBuffers()),N.drawArrays(N.TRIANGLE_STRIP,0,4)}drawBuffers(){this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap)}getInternalFormat(){return this.context.RGBA}getTextureFormat(){let{context:A}=this;switch(this.getInternalFormat()){case A.RGBA:return A.RGBA;default:throw new Error("Unknown internal format")}}_replaceOutputTexture(){if(this.texture.beforeMutate()||this._textureSwitched){let A=this.context;A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,this.texture.texture,0),this._textureSwitched=!1}}_setupOutputTexture(){let A=this.context,f=this.texSize;if(this.texture){A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,this.texture.texture,0);return}let R=this.createTexture();A.activeTexture(A.TEXTURE0+this.constantTextureCount+this.argumentTextureCount),A.bindTexture(A.TEXTURE_2D,R),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,A.NEAREST);let N=this.getInternalFormat();this.precision==="single"?A.texImage2D(A.TEXTURE_2D,0,N,f[0],f[1],0,A.RGBA,A.FLOAT,null):A.texImage2D(A.TEXTURE_2D,0,N,f[0],f[1],0,N,A.UNSIGNED_BYTE,null),A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,R,0),this.texture=new this.TextureConstructor({texture:R,size:f,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this})}_replaceSubOutputTextures(){let A=this.context;for(let f=0;f<this.mappedTextures.length;f++){let R=this.mappedTextures[f];(R.beforeMutate()||this._mappedTextureSwitched[f])&&(A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0+f+1,A.TEXTURE_2D,R.texture,0),this._mappedTextureSwitched[f]=!1)}}_setupSubOutputTextures(){let A=this.context;if(this.mappedTextures){for(let R=0;R<this.subKernels.length;R++)A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0+R+1,A.TEXTURE_2D,this.mappedTextures[R].texture,0);return}let f=this.texSize;this.drawBuffersMap=[A.COLOR_ATTACHMENT0],this.mappedTextures=[];for(let R=0;R<this.subKernels.length;R++){let N=this.createTexture();this.drawBuffersMap.push(A.COLOR_ATTACHMENT0+R+1),A.activeTexture(A.TEXTURE0+this.constantTextureCount+this.argumentTextureCount+R),A.bindTexture(A.TEXTURE_2D,N),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,A.NEAREST),this.precision==="single"?A.texImage2D(A.TEXTURE_2D,0,A.RGBA,f[0],f[1],0,A.RGBA,A.FLOAT,null):A.texImage2D(A.TEXTURE_2D,0,A.RGBA,f[0],f[1],0,A.RGBA,A.UNSIGNED_BYTE,null),A.framebufferTexture2D(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0+R+1,A.TEXTURE_2D,N,0),this.mappedTextures.push(new this.TextureConstructor({texture:N,size:f,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this}))}}setUniform1f(A,f){if(this.uniform1fCache.hasOwnProperty(A)){let N=this.uniform1fCache[A];if(f===N)return}this.uniform1fCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform1f(R,f)}setUniform1i(A,f){if(this.uniform1iCache.hasOwnProperty(A)){let N=this.uniform1iCache[A];if(f===N)return}this.uniform1iCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform1i(R,f)}setUniform2f(A,f,R){if(this.uniform2fCache.hasOwnProperty(A)){let K=this.uniform2fCache[A];if(f===K[0]&&R===K[1])return}this.uniform2fCache[A]=[f,R];let N=this.getUniformLocation(A);this.context.uniform2f(N,f,R)}setUniform2fv(A,f){if(this.uniform2fvCache.hasOwnProperty(A)){let N=this.uniform2fvCache[A];if(f[0]===N[0]&&f[1]===N[1])return}this.uniform2fvCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform2fv(R,f)}setUniform2iv(A,f){if(this.uniform2ivCache.hasOwnProperty(A)){let N=this.uniform2ivCache[A];if(f[0]===N[0]&&f[1]===N[1])return}this.uniform2ivCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform2iv(R,f)}setUniform3fv(A,f){if(this.uniform3fvCache.hasOwnProperty(A)){let N=this.uniform3fvCache[A];if(f[0]===N[0]&&f[1]===N[1]&&f[2]===N[2])return}this.uniform3fvCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform3fv(R,f)}setUniform3iv(A,f){if(this.uniform3ivCache.hasOwnProperty(A)){let N=this.uniform3ivCache[A];if(f[0]===N[0]&&f[1]===N[1]&&f[2]===N[2])return}this.uniform3ivCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform3iv(R,f)}setUniform4fv(A,f){if(this.uniform4fvCache.hasOwnProperty(A)){let N=this.uniform4fvCache[A];if(f[0]===N[0]&&f[1]===N[1]&&f[2]===N[2]&&f[3]===N[3])return}this.uniform4fvCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform4fv(R,f)}setUniform4iv(A,f){if(this.uniform4ivCache.hasOwnProperty(A)){let N=this.uniform4ivCache[A];if(f[0]===N[0]&&f[1]===N[1]&&f[2]===N[2]&&f[3]===N[3])return}this.uniform4ivCache[A]=f;let R=this.getUniformLocation(A);this.context.uniform4iv(R,f)}getUniformLocation(A){return this.programUniformLocationCache.hasOwnProperty(A)?this.programUniformLocationCache[A]:this.programUniformLocationCache[A]=this.context.getUniformLocation(this.program,A)}_getFragShaderArtifactMap(A){return{HEADER:this._getHeaderString(),LOOP_MAX:this._getLoopMaxString(),PLUGINS:this._getPluginsString(),CONSTANTS:this._getConstantsString(),DECODE32_ENDIANNESS:this._getDecode32EndiannessString(),ENCODE32_ENDIANNESS:this._getEncode32EndiannessString(),DIVIDE_WITH_INTEGER_CHECK:this._getDivideWithIntegerCheckString(),INJECTED_NATIVE:this._getInjectedNative(),MAIN_CONSTANTS:this._getMainConstantsString(),MAIN_ARGUMENTS:this._getMainArgumentsString(A),KERNEL:this.getKernelString(),MAIN_RESULT:this.getMainResultString(),FLOAT_TACTIC_DECLARATION:this.getFloatTacticDeclaration(),INT_TACTIC_DECLARATION:this.getIntTacticDeclaration(),SAMPLER_2D_TACTIC_DECLARATION:this.getSampler2DTacticDeclaration(),SAMPLER_2D_ARRAY_TACTIC_DECLARATION:this.getSampler2DArrayTacticDeclaration()}}_getVertShaderArtifactMap(A){return{FLOAT_TACTIC_DECLARATION:this.getFloatTacticDeclaration(),INT_TACTIC_DECLARATION:this.getIntTacticDeclaration(),SAMPLER_2D_TACTIC_DECLARATION:this.getSampler2DTacticDeclaration(),SAMPLER_2D_ARRAY_TACTIC_DECLARATION:this.getSampler2DArrayTacticDeclaration()}}_getHeaderString(){return this.subKernels!==null?`#extension GL_EXT_draw_buffers : require
`:""}_getLoopMaxString(){return this.loopMaxIterations?` ${parseInt(this.loopMaxIterations)};
`:` 1000;
`}_getPluginsString(){return this.plugins?this.plugins.map(A=>A.source&&this.source.match(A.functionMatch)?A.source:"").join(`
`):`
`}_getConstantsString(){let A=[],{threadDim:f,texSize:R}=this;return this.dynamicOutput?A.push("uniform ivec3 uOutputDim","uniform ivec2 uTexSize"):A.push(`ivec3 uOutputDim = ivec3(${f[0]}, ${f[1]}, ${f[2]})`,`ivec2 uTexSize = ivec2(${R[0]}, ${R[1]})`),m.linesToString(A)}_getTextureCoordinate(){let A=this.subKernels;return A===null||A.length<1?`varying vec2 vTexCoord;
`:`out vec2 vTexCoord;
`}_getDecode32EndiannessString(){return this.endianness==="LE"?"":`  texel.rgba = texel.abgr;
`}_getEncode32EndiannessString(){return this.endianness==="LE"?"":`  texel.rgba = texel.abgr;
`}_getDivideWithIntegerCheckString(){return this.fixIntegerDivisionAccuracy?`float divWithIntCheck(float x, float y) {
        if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
          return float(int(x) / int(y));
        }
        return x / y;
      }
      
      float integerCorrectionModulo(float number, float divisor) {
        if (number < 0.0) {
          number = abs(number);
          if (divisor < 0.0) {
            divisor = abs(divisor);
          }
          return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
        }
        if (divisor < 0.0) {
          divisor = abs(divisor);
        }
        return number - (divisor * floor(divWithIntCheck(number, divisor)));
      }`:""}_getMainArgumentsString(A){let f=[],{argumentNames:R}=this;for(let N=0;N<R.length;N++)f.push(this.kernelArguments[N].getSource(A[N]));return f.join("")}_getInjectedNative(){return this.injectedNative||""}_getMainConstantsString(){let A=[],{constants:f}=this;if(f){let R=0;for(let N in f)!this.constants.hasOwnProperty(N)||A.push(this.kernelConstants[R++].getSource(this.constants[N]))}return A.join("")}getRawValueFramebuffer(A,f){if(this.rawValueFramebuffers[A]||(this.rawValueFramebuffers[A]={}),!this.rawValueFramebuffers[A][f]){let R=this.context.createFramebuffer();R.width=A,R.height=f,this.rawValueFramebuffers[A][f]=R}return this.rawValueFramebuffers[A][f]}getKernelResultDeclaration(){switch(this.returnType){case"Array(2)":return"vec2 kernelResult";case"Array(3)":return"vec3 kernelResult";case"Array(4)":return"vec4 kernelResult";case"LiteralInteger":case"Float":case"Number":case"Integer":return"float kernelResult";default:if(this.graphical)return"float kernelResult";throw new Error(`unrecognized output type "${this.returnType}"`)}}getKernelString(){let A=[this.getKernelResultDeclaration()],{subKernels:f}=this;if(f!==null)switch(this.returnType){case"Number":case"Float":case"Integer":for(let R=0;R<f.length;R++){let N=f[R];A.push(N.returnType==="Integer"?`int subKernelResult_${N.name} = 0`:`float subKernelResult_${N.name} = 0.0`)}break;case"Array(2)":for(let R=0;R<f.length;R++)A.push(`vec2 subKernelResult_${f[R].name}`);break;case"Array(3)":for(let R=0;R<f.length;R++)A.push(`vec3 subKernelResult_${f[R].name}`);break;case"Array(4)":for(let R=0;R<f.length;R++)A.push(`vec4 subKernelResult_${f[R].name}`);break}return m.linesToString(A)+this.translatedSource}getMainResultGraphical(){return m.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragColor = actualColor"])}getMainResultPackedPixels(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return this.getMainResultKernelPackedPixels()+this.getMainResultSubKernelPackedPixels();default:throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)}}getMainResultKernelPackedPixels(){return m.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  gl_FragData[0] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])}getMainResultSubKernelPackedPixels(){let A=[];if(!this.subKernels)return"";for(let f=0;f<this.subKernels.length;f++)this.subKernels[f].returnType==="Integer"?A.push(`  gl_FragData[${f+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[f].name}))`):A.push(`  gl_FragData[${f+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[f].name})`);return m.linesToString(A)}getMainResultMemoryOptimizedFloats(){let A=["  index *= 4"];switch(this.returnType){case"Number":case"Integer":case"Float":let f=["r","g","b","a"];for(let R=0;R<f.length;R++){let N=f[R];this.getMainResultKernelMemoryOptimizedFloats(A,N),this.getMainResultSubKernelMemoryOptimizedFloats(A,N),R+1<f.length&&A.push("  index += 1")}break;default:throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`)}return m.linesToString(A)}getMainResultKernelMemoryOptimizedFloats(A,f){A.push("  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  gl_FragData[0].${f} = kernelResult`)}getMainResultSubKernelMemoryOptimizedFloats(A,f){if(!this.subKernels)return A;for(let R=0;R<this.subKernels.length;R++)this.subKernels[R].returnType==="Integer"?A.push(`  gl_FragData[${R+1}].${f} = float(subKernelResult_${this.subKernels[R].name})`):A.push(`  gl_FragData[${R+1}].${f} = subKernelResult_${this.subKernels[R].name}`)}getMainResultKernelNumberTexture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult"]}getMainResultSubKernelNumberTexture(){let A=[];if(!this.subKernels)return A;for(let f=0;f<this.subKernels.length;++f){let R=this.subKernels[f];R.returnType==="Integer"?A.push(`  gl_FragData[${f+1}][0] = float(subKernelResult_${R.name})`):A.push(`  gl_FragData[${f+1}][0] = subKernelResult_${R.name}`)}return A}getMainResultKernelArray2Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult[0]","  gl_FragData[0][1] = kernelResult[1]"]}getMainResultSubKernelArray2Texture(){let A=[];if(!this.subKernels)return A;for(let f=0;f<this.subKernels.length;++f)A.push(`  gl_FragData[${f+1}][0] = subKernelResult_${this.subKernels[f].name}[0]`,`  gl_FragData[${f+1}][1] = subKernelResult_${this.subKernels[f].name}[1]`);return A}getMainResultKernelArray3Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0][0] = kernelResult[0]","  gl_FragData[0][1] = kernelResult[1]","  gl_FragData[0][2] = kernelResult[2]"]}getMainResultSubKernelArray3Texture(){let A=[];if(!this.subKernels)return A;for(let f=0;f<this.subKernels.length;++f)A.push(`  gl_FragData[${f+1}][0] = subKernelResult_${this.subKernels[f].name}[0]`,`  gl_FragData[${f+1}][1] = subKernelResult_${this.subKernels[f].name}[1]`,`  gl_FragData[${f+1}][2] = subKernelResult_${this.subKernels[f].name}[2]`);return A}getMainResultKernelArray4Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  gl_FragData[0] = kernelResult"]}getMainResultSubKernelArray4Texture(){let A=[];if(!this.subKernels)return A;switch(this.returnType){case"Number":case"Float":case"Integer":for(let f=0;f<this.subKernels.length;++f)this.subKernels[f].returnType==="Integer"?A.push(`  gl_FragData[${f+1}] = float(subKernelResult_${this.subKernels[f].name})`):A.push(`  gl_FragData[${f+1}] = subKernelResult_${this.subKernels[f].name}`);break;case"Array(2)":for(let f=0;f<this.subKernels.length;++f)A.push(`  gl_FragData[${f+1}][0] = subKernelResult_${this.subKernels[f].name}[0]`,`  gl_FragData[${f+1}][1] = subKernelResult_${this.subKernels[f].name}[1]`);break;case"Array(3)":for(let f=0;f<this.subKernels.length;++f)A.push(`  gl_FragData[${f+1}][0] = subKernelResult_${this.subKernels[f].name}[0]`,`  gl_FragData[${f+1}][1] = subKernelResult_${this.subKernels[f].name}[1]`,`  gl_FragData[${f+1}][2] = subKernelResult_${this.subKernels[f].name}[2]`);break;case"Array(4)":for(let f=0;f<this.subKernels.length;++f)A.push(`  gl_FragData[${f+1}][0] = subKernelResult_${this.subKernels[f].name}[0]`,`  gl_FragData[${f+1}][1] = subKernelResult_${this.subKernels[f].name}[1]`,`  gl_FragData[${f+1}][2] = subKernelResult_${this.subKernels[f].name}[2]`,`  gl_FragData[${f+1}][3] = subKernelResult_${this.subKernels[f].name}[3]`);break}return A}replaceArtifacts(A,f){return A.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g,(R,N)=>{if(f.hasOwnProperty(N))return f[N];throw`unhandled artifact ${N}`})}getFragmentShader(A){return this.compiledFragmentShader!==null?this.compiledFragmentShader:this.compiledFragmentShader=this.replaceArtifacts(this.constructor.fragmentShader,this._getFragShaderArtifactMap(A))}getVertexShader(A){return this.compiledVertexShader!==null?this.compiledVertexShader:this.compiledVertexShader=this.replaceArtifacts(this.constructor.vertexShader,this._getVertShaderArtifactMap(A))}toString(){let A=m.linesToString(["const gl = context"]);return o(this.constructor,arguments,this,A)}destroy(A){if(!this.context)return;this.buffer&&this.context.deleteBuffer(this.buffer),this.framebuffer&&this.context.deleteFramebuffer(this.framebuffer);for(let R in this.rawValueFramebuffers){for(let N in this.rawValueFramebuffers[R])this.context.deleteFramebuffer(this.rawValueFramebuffers[R][N]),delete this.rawValueFramebuffers[R][N];delete this.rawValueFramebuffers[R]}if(this.vertShader&&this.context.deleteShader(this.vertShader),this.fragShader&&this.context.deleteShader(this.fragShader),this.program&&this.context.deleteProgram(this.program),this.texture){this.texture.delete();let R=this.textureCache.indexOf(this.texture.texture);R>-1&&this.textureCache.splice(R,1),this.texture=null}if(this.mappedTextures&&this.mappedTextures.length){for(let R=0;R<this.mappedTextures.length;R++){let N=this.mappedTextures[R];N.delete();let K=this.textureCache.indexOf(N.texture);K>-1&&this.textureCache.splice(K,1)}this.mappedTextures=null}if(this.kernelArguments)for(let R=0;R<this.kernelArguments.length;R++)this.kernelArguments[R].destroy();if(this.kernelConstants)for(let R=0;R<this.kernelConstants.length;R++)this.kernelConstants[R].destroy();for(;this.textureCache.length>0;){let R=this.textureCache.pop();this.context.deleteTexture(R)}if(A){let R=_.indexOf(this.canvas);R>=0&&(_[R]=null,k[R]=null)}if(this.destroyExtensions(),delete this.context,delete this.canvas,!this.gpu)return;let f=this.gpu.kernels.indexOf(this);f!==-1&&this.gpu.kernels.splice(f,1)}destroyExtensions(){this.extensions.OES_texture_float=null,this.extensions.OES_texture_float_linear=null,this.extensions.OES_element_index_uint=null,this.extensions.WEBGL_draw_buffers=null}static destroyContext(A){let f=A.getExtension("WEBGL_lose_context");f&&f.loseContext()}toJSON(){let A=super.toJSON();return A.functionNodes=y.fromKernel(this,v).toJSON(),A.settings.threadDim=this.threadDim,A}}c.exports={WebGLKernel:M}},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(i,c,d){let p=`__FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      
      attribute vec2 aPos;
      attribute vec2 aTexCoord;
      
      varying vec2 vTexCoord;
      uniform vec2 ratio;
      
      void main(void) {
        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
        vTexCoord = aTexCoord;
      }`;c.exports={vertexShader:p}},{}],72:[function(i,c,d){let p=`#version 300 es
      __HEADER__;
      __FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      __SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;
      
      const int LOOP_MAX = __LOOP_MAX__;
      
      __PLUGINS__;
      __CONSTANTS__;
      
      in vec2 vTexCoord;
      
      float atan2(float v1, float v2) {
        if (v1 == 0.0 || v2 == 0.0) return 0.0;
        return atan(v1 / v2);
      }
      
      float cbrt(float x) {
        if (x >= 0.0) {
          return pow(x, 1.0 / 3.0);
        } else {
          return -pow(x, 1.0 / 3.0);
        }
      }
      
      float expm1(float x) {
        return pow(${Math.E}, x) - 1.0; 
      }
      
      float fround(highp float x) {
        return x;
      }
      
      float imul(float v1, float v2) {
        return float(int(v1) * int(v2));
      }
      
      float log10(float x) {
        return log2(x) * (1.0 / log2(10.0));
      }
      
      float log1p(float x) {
        return log(1.0 + x);
      }
      
      float _pow(float v1, float v2) {
        if (v2 == 0.0) return 1.0;
        return pow(v1, v2);
      }
      
      float _round(float x) {
        return floor(x + 0.5);
      }
      
      
      const int BIT_COUNT = 32;
      int modi(int x, int y) {
        return x - y * (x / y);
      }
      
      int bitwiseOr(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseXOR(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseAnd(int a, int b) {
        int result = 0;
        int n = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 && b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseNot(int a) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if (modi(a, 2) == 0) {
            result += n;    
          }
          a = a / 2;
          n = n * 2;
        }
        return result;
      }
      int bitwiseZeroFillLeftShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n *= 2;
        }
      
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      int bitwiseSignedRightShift(int num, int shifts) {
        return int(floor(float(num) / pow(2.0, float(shifts))));
      }
      
      int bitwiseZeroFillRightShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n /= 2;
        }
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      vec2 integerMod(vec2 x, float y) {
        vec2 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec3 integerMod(vec3 x, float y) {
        vec3 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec4 integerMod(vec4 x, vec4 y) {
        vec4 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      float integerMod(float x, float y) {
        float res = floor(mod(x, y));
        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
      }
      
      int integerMod(int x, int y) {
        return x - (y * int(x/y));
      }
      
      __DIVIDE_WITH_INTEGER_CHECK__;
      
      // Here be dragons!
      // DO NOT OPTIMIZE THIS CODE
      // YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
      const vec2 MAGIC_VEC = vec2(1.0, -256.0);
      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
      float decode32(vec4 texel) {
        __DECODE32_ENDIANNESS__;
        texel *= 255.0;
        vec2 gte128;
        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
        float res = exp2(round(exponent));
        texel.b = texel.b - 128.0 * gte128.x;
        res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
        res *= gte128.y * -2.0 + 1.0;
        return res;
      }
      
      float decode16(vec4 texel, int index) {
        int channel = integerMod(index, 2);
        return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
      }
      
      float decode8(vec4 texel, int index) {
        int channel = integerMod(index, 4);
        return texel[channel] * 255.0;
      }
      
      vec4 legacyEncode32(float f) {
        float F = abs(f);
        float sign = f < 0.0 ? 1.0 : 0.0;
        float exponent = floor(log2(F));
        float mantissa = (exp2(-exponent) * F);
        // exponent += floor(log2(mantissa));
        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
        texel.rg = integerMod(texel.rg, 256.0);
        texel.b = integerMod(texel.b, 128.0);
        texel.a = exponent*0.5 + 63.5;
        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
        texel = floor(texel);
        texel *= 0.003921569; // 1/255
        __ENCODE32_ENDIANNESS__;
        return texel;
      }
      
      // https://github.com/gpujs/gpu.js/wiki/Encoder-details
      vec4 encode32(float value) {
        if (value == 0.0) return vec4(0, 0, 0, 0);
      
        float exponent;
        float mantissa;
        vec4  result;
        float sgn;
      
        sgn = step(0.0, -value);
        value = abs(value);
      
        exponent = floor(log2(value));
      
        mantissa = value*pow(2.0, -exponent)-1.0;
        exponent = exponent+127.0;
        result   = vec4(0,0,0,0);
      
        result.a = floor(exponent/2.0);
        exponent = exponent - result.a*2.0;
        result.a = result.a + 128.0*sgn;
      
        result.b = floor(mantissa * 128.0);
        mantissa = mantissa - result.b / 128.0;
        result.b = result.b + exponent*128.0;
      
        result.g = floor(mantissa*32768.0);
        mantissa = mantissa - result.g/32768.0;
      
        result.r = floor(mantissa*8388608.0);
        return result/255.0;
      }
      // Dragons end here
      
      int index;
      ivec3 threadId;
      
      ivec3 indexTo3D(int idx, ivec3 texDim) {
        int z = int(idx / (texDim.x * texDim.y));
        idx -= z * int(texDim.x * texDim.y);
        int y = int(idx / texDim.x);
        int x = int(integerMod(idx, texDim.x));
        return ivec3(x, y, z);
      }
      
      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize));
        return decode32(texel);
      }
      
      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int w = texSize.x * 2;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
        return decode16(texel, index);
      }
      
      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int w = texSize.x * 4;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
        return decode8(texel, index);
      }
      
      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int channel = integerMod(index, 4);
        index = index / 4;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        index = index / 4;
        vec4 texel = texture(tex, st / vec2(texSize));
        return texel[channel];
      }
      
      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        return texture(tex, st / vec2(texSize));
      }
      
      vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        return texture(tex, vec3(st / vec2(texSize), z));
      }
      
      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return result[0];
      }
      
      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec2(result[0], result[1]);
      }
      
      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 2);
        index = index / 2;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize));
        if (channel == 0) return vec2(texel.r, texel.g);
        if (channel == 1) return vec2(texel.b, texel.a);
        return vec2(0.0, 0.0);
      }
      
      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec3(result[0], result[1], result[2]);
      }
      
      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
        int vectorIndex = fieldIndex / 4;
        int vectorOffset = fieldIndex - vectorIndex * 4;
        int readY = vectorIndex / texSize.x;
        int readX = vectorIndex - readY * texSize.x;
        vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
      
        if (vectorOffset == 0) {
          return tex1.xyz;
        } else if (vectorOffset == 1) {
          return tex1.yzw;
        } else {
          readX++;
          if (readX >= texSize.x) {
            readX = 0;
            readY++;
          }
          vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
          if (vectorOffset == 2) {
            return vec3(tex1.z, tex1.w, tex2.x);
          } else {
            return vec3(tex1.w, tex2.x, tex2.y);
          }
        }
      }
      
      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        return getImage2D(tex, texSize, texDim, z, y, x);
      }
      
      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 2);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize));
        return vec4(texel.r, texel.g, texel.b, texel.a);
      }
      
      vec4 actualColor;
      void color(float r, float g, float b, float a) {
        actualColor = vec4(r,g,b,a);
      }
      
      void color(float r, float g, float b) {
        color(r,g,b,1.0);
      }
      
      float modulo(float number, float divisor) {
        if (number < 0.0) {
          number = abs(number);
          if (divisor < 0.0) {
            divisor = abs(divisor);
          }
          return -mod(number, divisor);
        }
        if (divisor < 0.0) {
          divisor = abs(divisor);
        }
        return mod(number, divisor);
      }
      
      __INJECTED_NATIVE__;
      __MAIN_CONSTANTS__;
      __MAIN_ARGUMENTS__;
      __KERNEL__;
      
      void main(void) {
        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
        __MAIN_RESULT__;
      }`;c.exports={fragmentShader:p}},{}],73:[function(i,c,d){let{utils:p}=i("../../utils"),{WebGLFunctionNode:y}=i("../web-gl/function-node");class v extends y{astIdentifierExpression(l,h){if(l.type!=="Identifier")throw this.astErrorOutput("IdentifierExpression - not an Identifier",l);let a=this.getType(l),o=p.sanitizeName(l.name);return l.name==="Infinity"?h.push("intBitsToFloat(2139095039)"):a==="Boolean"?this.argumentNames.indexOf(o)>-1?h.push(`bool(user_${o})`):h.push(`user_${o}`):h.push(`user_${o}`),h}}c.exports={WebGL2FunctionNode:v}},{"../../utils":114,"../web-gl/function-node":38}],74:[function(i,c,d){let{WebGL2KernelValueBoolean:p}=i("./kernel-value/boolean"),{WebGL2KernelValueFloat:y}=i("./kernel-value/float"),{WebGL2KernelValueInteger:v}=i("./kernel-value/integer"),{WebGL2KernelValueHTMLImage:m}=i("./kernel-value/html-image"),{WebGL2KernelValueDynamicHTMLImage:l}=i("./kernel-value/dynamic-html-image"),{WebGL2KernelValueHTMLImageArray:h}=i("./kernel-value/html-image-array"),{WebGL2KernelValueDynamicHTMLImageArray:a}=i("./kernel-value/dynamic-html-image-array"),{WebGL2KernelValueHTMLVideo:o}=i("./kernel-value/html-video"),{WebGL2KernelValueDynamicHTMLVideo:b}=i("./kernel-value/dynamic-html-video"),{WebGL2KernelValueSingleInput:w}=i("./kernel-value/single-input"),{WebGL2KernelValueDynamicSingleInput:I}=i("./kernel-value/dynamic-single-input"),{WebGL2KernelValueUnsignedInput:S}=i("./kernel-value/unsigned-input"),{WebGL2KernelValueDynamicUnsignedInput:D}=i("./kernel-value/dynamic-unsigned-input"),{WebGL2KernelValueMemoryOptimizedNumberTexture:C}=i("./kernel-value/memory-optimized-number-texture"),{WebGL2KernelValueDynamicMemoryOptimizedNumberTexture:T}=i("./kernel-value/dynamic-memory-optimized-number-texture"),{WebGL2KernelValueNumberTexture:_}=i("./kernel-value/number-texture"),{WebGL2KernelValueDynamicNumberTexture:k}=i("./kernel-value/dynamic-number-texture"),{WebGL2KernelValueSingleArray:M}=i("./kernel-value/single-array"),{WebGL2KernelValueDynamicSingleArray:P}=i("./kernel-value/dynamic-single-array"),{WebGL2KernelValueSingleArray1DI:A}=i("./kernel-value/single-array1d-i"),{WebGL2KernelValueDynamicSingleArray1DI:f}=i("./kernel-value/dynamic-single-array1d-i"),{WebGL2KernelValueSingleArray2DI:R}=i("./kernel-value/single-array2d-i"),{WebGL2KernelValueDynamicSingleArray2DI:N}=i("./kernel-value/dynamic-single-array2d-i"),{WebGL2KernelValueSingleArray3DI:K}=i("./kernel-value/single-array3d-i"),{WebGL2KernelValueDynamicSingleArray3DI:O}=i("./kernel-value/dynamic-single-array3d-i"),{WebGL2KernelValueSingleArray2:V}=i("./kernel-value/single-array2"),{WebGL2KernelValueSingleArray3:j}=i("./kernel-value/single-array3"),{WebGL2KernelValueSingleArray4:z}=i("./kernel-value/single-array4"),{WebGL2KernelValueUnsignedArray:q}=i("./kernel-value/unsigned-array"),{WebGL2KernelValueDynamicUnsignedArray:H}=i("./kernel-value/dynamic-unsigned-array"),U={unsigned:{dynamic:{Boolean:p,Integer:v,Float:y,Array:H,"Array(2)":!1,"Array(3)":!1,"Array(4)":!1,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:D,NumberTexture:k,"ArrayTexture(1)":k,"ArrayTexture(2)":k,"ArrayTexture(3)":k,"ArrayTexture(4)":k,MemoryOptimizedNumberTexture:T,HTMLCanvas:l,HTMLImage:l,HTMLImageArray:a,HTMLVideo:b},static:{Boolean:p,Float:y,Integer:v,Array:q,"Array(2)":!1,"Array(3)":!1,"Array(4)":!1,"Array1D(2)":!1,"Array1D(3)":!1,"Array1D(4)":!1,"Array2D(2)":!1,"Array2D(3)":!1,"Array2D(4)":!1,"Array3D(2)":!1,"Array3D(3)":!1,"Array3D(4)":!1,Input:S,NumberTexture:_,"ArrayTexture(1)":_,"ArrayTexture(2)":_,"ArrayTexture(3)":_,"ArrayTexture(4)":_,MemoryOptimizedNumberTexture:T,HTMLCanvas:m,HTMLImage:m,HTMLImageArray:h,HTMLVideo:o}},single:{dynamic:{Boolean:p,Integer:v,Float:y,Array:P,"Array(2)":V,"Array(3)":j,"Array(4)":z,"Array1D(2)":f,"Array1D(3)":f,"Array1D(4)":f,"Array2D(2)":N,"Array2D(3)":N,"Array2D(4)":N,"Array3D(2)":O,"Array3D(3)":O,"Array3D(4)":O,Input:I,NumberTexture:k,"ArrayTexture(1)":k,"ArrayTexture(2)":k,"ArrayTexture(3)":k,"ArrayTexture(4)":k,MemoryOptimizedNumberTexture:T,HTMLCanvas:l,HTMLImage:l,HTMLImageArray:a,HTMLVideo:b},static:{Boolean:p,Float:y,Integer:v,Array:M,"Array(2)":V,"Array(3)":j,"Array(4)":z,"Array1D(2)":A,"Array1D(3)":A,"Array1D(4)":A,"Array2D(2)":R,"Array2D(3)":R,"Array2D(4)":R,"Array3D(2)":K,"Array3D(3)":K,"Array3D(4)":K,Input:w,NumberTexture:_,"ArrayTexture(1)":_,"ArrayTexture(2)":_,"ArrayTexture(3)":_,"ArrayTexture(4)":_,MemoryOptimizedNumberTexture:C,HTMLCanvas:m,HTMLImage:m,HTMLImageArray:h,HTMLVideo:o}}};function J(ee,Z,Y,X){if(!ee)throw new Error("type missing");if(!Z)throw new Error("dynamic missing");if(!Y)throw new Error("precision missing");X.type&&(ee=X.type);let ge=U[Y][Z];if(ge[ee]===!1)return null;if(ge[ee]===void 0)throw new Error(`Could not find a KernelValue for ${ee}`);return ge[ee]}c.exports={kernelValueMaps:U,lookupKernelValueType:J}},{"./kernel-value/boolean":75,"./kernel-value/dynamic-html-image":77,"./kernel-value/dynamic-html-image-array":76,"./kernel-value/dynamic-html-video":78,"./kernel-value/dynamic-memory-optimized-number-texture":79,"./kernel-value/dynamic-number-texture":80,"./kernel-value/dynamic-single-array":81,"./kernel-value/dynamic-single-array1d-i":82,"./kernel-value/dynamic-single-array2d-i":83,"./kernel-value/dynamic-single-array3d-i":84,"./kernel-value/dynamic-single-input":85,"./kernel-value/dynamic-unsigned-array":86,"./kernel-value/dynamic-unsigned-input":87,"./kernel-value/float":88,"./kernel-value/html-image":90,"./kernel-value/html-image-array":89,"./kernel-value/html-video":91,"./kernel-value/integer":92,"./kernel-value/memory-optimized-number-texture":93,"./kernel-value/number-texture":94,"./kernel-value/single-array":95,"./kernel-value/single-array1d-i":96,"./kernel-value/single-array2":97,"./kernel-value/single-array2d-i":98,"./kernel-value/single-array3":99,"./kernel-value/single-array3d-i":100,"./kernel-value/single-array4":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(i,c,d){let{WebGLKernelValueBoolean:p}=i("../../web-gl/kernel-value/boolean");class y extends p{}c.exports={WebGL2KernelValueBoolean:y}},{"../../web-gl/kernel-value/boolean":41}],76:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueHTMLImageArray:y}=i("./html-image-array");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2DArray ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){let{width:h,height:a}=l[0];this.checkSize(h,a),this.dimensions=[h,a,l.length],this.textureSize=[h,a],this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGL2KernelValueDynamicHTMLImageArray:v}},{"../../../utils":114,"./html-image-array":89}],77:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueDynamicHTMLImage:y}=i("../../web-gl/kernel-value/dynamic-html-image");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}c.exports={WebGL2KernelValueDynamicHTMLImage:v}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":42}],78:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueDynamicHTMLImage:y}=i("./dynamic-html-image");class v extends y{}c.exports={WebGL2KernelValueDynamicHTMLVideo:v}},{"../../../utils":114,"./dynamic-html-image":77}],79:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueDynamicMemoryOptimizedNumberTexture:y}=i("../../web-gl/kernel-value/dynamic-memory-optimized-number-texture");class v extends y{getSource(){return p.linesToString([`uniform sampler2D ${this.id}`,`uniform ivec2 ${this.sizeId}`,`uniform ivec3 ${this.dimensionsId}`])}}c.exports={WebGL2KernelValueDynamicMemoryOptimizedNumberTexture:v}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":44}],80:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueDynamicNumberTexture:y}=i("../../web-gl/kernel-value/dynamic-number-texture");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}c.exports={WebGL2KernelValueDynamicNumberTexture:v}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":45}],81:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueSingleArray:y}=i("../../web-gl2/kernel-value/single-array");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.dimensions=p.getDimensions(l,!0),this.textureSize=p.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGL2KernelValueDynamicSingleArray:v}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":95}],82:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueSingleArray1DI:y}=i("../../web-gl2/kernel-value/single-array1d-i");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGL2KernelValueDynamicSingleArray1DI:v}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":96}],83:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueSingleArray2DI:y}=i("../../web-gl2/kernel-value/single-array2d-i");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGL2KernelValueDynamicSingleArray2DI:v}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":98}],84:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueSingleArray3DI:y}=i("../../web-gl2/kernel-value/single-array3d-i");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){this.setShape(l),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGL2KernelValueDynamicSingleArray3DI:v}},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":100}],85:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueSingleInput:y}=i("../../web-gl2/kernel-value/single-input");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}updateValue(l){let[h,a,o]=l.size;this.dimensions=new Int32Array([h||1,a||1,o||1]),this.textureSize=p.getMemoryOptimizedFloatTextureSize(this.dimensions,this.bitRatio),this.uploadArrayLength=this.textureSize[0]*this.textureSize[1]*this.bitRatio,this.checkSize(this.textureSize[0],this.textureSize[1]),this.uploadValue=new Float32Array(this.uploadArrayLength),this.kernel.setUniform3iv(this.dimensionsId,this.dimensions),this.kernel.setUniform2iv(this.sizeId,this.textureSize),super.updateValue(l)}}c.exports={WebGL2KernelValueDynamicSingleInput:v}},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],86:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueDynamicUnsignedArray:y}=i("../../web-gl/kernel-value/dynamic-unsigned-array");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}c.exports={WebGL2KernelValueDynamicUnsignedArray:v}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":51}],87:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueDynamicUnsignedInput:y}=i("../../web-gl/kernel-value/dynamic-unsigned-input");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`uniform ${l} ivec2 ${this.sizeId}`,`uniform ${l} ivec3 ${this.dimensionsId}`])}}c.exports={WebGL2KernelValueDynamicUnsignedInput:v}},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":52}],88:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueFloat:y}=i("../../web-gl/kernel-value/float");class v extends y{}c.exports={WebGL2KernelValueFloat:v}},{"../../../utils":114,"../../web-gl/kernel-value/float":53}],89:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelArray:y}=i("../../web-gl/kernel-value/array");class v extends y{constructor(l,h){super(l,h),this.checkSize(l[0].width,l[0].height),this.dimensions=[l[0].width,l[0].height,l.length],this.textureSize=[l[0].width,l[0].height]}defineTexture(){let{context:l}=this;l.activeTexture(this.contextHandle),l.bindTexture(l.TEXTURE_2D_ARRAY,this.texture),l.texParameteri(l.TEXTURE_2D_ARRAY,l.TEXTURE_MAG_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D_ARRAY,l.TEXTURE_MIN_FILTER,l.NEAREST)}getStringValueHandler(){return`const uploadValue_${this.name} = ${this.varName};
`}getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2DArray ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){let{context:h}=this;h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D_ARRAY,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!0),h.texImage3D(h.TEXTURE_2D_ARRAY,0,h.RGBA,l[0].width,l[0].height,l.length,0,h.RGBA,h.UNSIGNED_BYTE,null);for(let a=0;a<l.length;a++)h.texSubImage3D(h.TEXTURE_2D_ARRAY,0,0,0,a,l[a].width,l[a].height,1,h.RGBA,h.UNSIGNED_BYTE,this.uploadValue=l[a]);this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGL2KernelValueHTMLImageArray:v}},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],90:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueHTMLImage:y}=i("../../web-gl/kernel-value/html-image");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}c.exports={WebGL2KernelValueHTMLImage:v}},{"../../../utils":114,"../../web-gl/kernel-value/html-image":54}],91:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGL2KernelValueHTMLImage:y}=i("./html-image");class v extends y{}c.exports={WebGL2KernelValueHTMLVideo:v}},{"../../../utils":114,"./html-image":90}],92:[function(i,c,d){let{WebGLKernelValueInteger:p}=i("../../web-gl/kernel-value/integer");class y extends p{getSource(m){let l=this.getVariablePrecisionString();return this.origin==="constants"?`const ${l} int ${this.id} = ${parseInt(m)};
`:`uniform ${l} int ${this.id};
`}updateValue(m){this.origin!=="constants"&&this.kernel.setUniform1i(this.id,this.uploadValue=m)}}c.exports={WebGL2KernelValueInteger:y}},{"../../web-gl/kernel-value/integer":57}],93:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueMemoryOptimizedNumberTexture:y}=i("../../web-gl/kernel-value/memory-optimized-number-texture");class v extends y{getSource(){let{id:l,sizeId:h,textureSize:a,dimensionsId:o,dimensions:b}=this,w=this.getVariablePrecisionString();return p.linesToString([`uniform sampler2D ${l}`,`${w} ivec2 ${h} = ivec2(${a[0]}, ${a[1]})`,`${w} ivec3 ${o} = ivec3(${b[0]}, ${b[1]}, ${b[2]})`])}}c.exports={WebGL2KernelValueMemoryOptimizedNumberTexture:v}},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":58}],94:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueNumberTexture:y}=i("../../web-gl/kernel-value/number-texture");class v extends y{getSource(){let{id:l,sizeId:h,textureSize:a,dimensionsId:o,dimensions:b}=this,w=this.getVariablePrecisionString();return p.linesToString([`uniform ${w} sampler2D ${l}`,`${w} ivec2 ${h} = ivec2(${a[0]}, ${a[1]})`,`${w} ivec3 ${o} = ivec3(${b[0]}, ${b[1]}, ${b[2]})`])}}c.exports={WebGL2KernelValueNumberTexture:v}},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":59}],95:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray:y}=i("../../web-gl/kernel-value/single-array");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGL2KernelValueSingleArray:v}},{"../../../utils":114,"../../web-gl/kernel-value/single-array":60}],96:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray1DI:y}=i("../../web-gl/kernel-value/single-array1d-i");class v extends y{updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGL2KernelValueSingleArray1DI:v}},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":61}],97:[function(i,c,d){let{WebGLKernelValueSingleArray2:p}=i("../../web-gl/kernel-value/single-array2");class y extends p{}c.exports={WebGL2KernelValueSingleArray2:y}},{"../../web-gl/kernel-value/single-array2":62}],98:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray2DI:y}=i("../../web-gl/kernel-value/single-array2d-i");class v extends y{updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGL2KernelValueSingleArray2DI:v}},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":63}],99:[function(i,c,d){let{WebGLKernelValueSingleArray3:p}=i("../../web-gl/kernel-value/single-array3");class y extends p{}c.exports={WebGL2KernelValueSingleArray3:y}},{"../../web-gl/kernel-value/single-array3":64}],100:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleArray3DI:y}=i("../../web-gl/kernel-value/single-array3d-i");class v extends y{updateValue(l){if(l.constructor!==this.initialValueConstructor){this.onUpdateValueMismatch(l.constructor);return}let{context:h}=this;p.flattenTo(l,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGL2KernelValueSingleArray3DI:v}},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":65}],101:[function(i,c,d){let{WebGLKernelValueSingleArray4:p}=i("../../web-gl/kernel-value/single-array4");class y extends p{}c.exports={WebGL2KernelValueSingleArray4:y}},{"../../web-gl/kernel-value/single-array4":66}],102:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueSingleInput:y}=i("../../web-gl/kernel-value/single-input");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}updateValue(l){let{context:h}=this;p.flattenTo(l.value,this.uploadValue),h.activeTexture(this.contextHandle),h.bindTexture(h.TEXTURE_2D,this.texture),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),h.texImage2D(h.TEXTURE_2D,0,h.RGBA32F,this.textureSize[0],this.textureSize[1],0,h.RGBA,h.FLOAT,this.uploadValue),this.kernel.setUniform1i(this.id,this.index)}}c.exports={WebGL2KernelValueSingleInput:v}},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueUnsignedArray:y}=i("../../web-gl/kernel-value/unsigned-array");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}c.exports={WebGL2KernelValueUnsignedArray:v}},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(i,c,d){let{utils:p}=i("../../../utils"),{WebGLKernelValueUnsignedInput:y}=i("../../web-gl/kernel-value/unsigned-input");class v extends y{getSource(){let l=this.getVariablePrecisionString();return p.linesToString([`uniform ${l} sampler2D ${this.id}`,`${l} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,`${l} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])}}c.exports={WebGL2KernelValueUnsignedInput:v}},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(i,c,d){let{WebGLKernel:p}=i("../web-gl/kernel"),{WebGL2FunctionNode:y}=i("./function-node"),{FunctionBuilder:v}=i("../function-builder"),{utils:m}=i("../../utils"),{fragmentShader:l}=i("./fragment-shader"),{vertexShader:h}=i("./vertex-shader"),{lookupKernelValueType:a}=i("./kernel-value-maps"),o=null,b=null,w=null,I=null,S=null;class D extends p{static get isSupported(){return o!==null||(this.setupFeatureChecks(),o=this.isContextMatch(w)),o}static setupFeatureChecks(){typeof document<"u"?b=document.createElement("canvas"):typeof OffscreenCanvas<"u"&&(b=new OffscreenCanvas(0,0)),b&&(w=b.getContext("webgl2"),!(!w||!w.getExtension)&&(I={EXT_color_buffer_float:w.getExtension("EXT_color_buffer_float"),OES_texture_float_linear:w.getExtension("OES_texture_float_linear")},S=this.getFeatures()))}static isContextMatch(T){return typeof WebGL2RenderingContext<"u"?T instanceof WebGL2RenderingContext:!1}static getFeatures(){let T=this.testContext;return Object.freeze({isFloatRead:this.getIsFloatRead(),isIntegerDivisionAccurate:this.getIsIntegerDivisionAccurate(),isSpeedTacticSupported:this.getIsSpeedTacticSupported(),kernelMap:!0,isTextureFloat:!0,isDrawBuffers:!0,channelCount:this.getChannelCount(),maxTextureSize:this.getMaxTextureSize(),lowIntPrecision:T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.LOW_INT),lowFloatPrecision:T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.LOW_FLOAT),mediumIntPrecision:T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.MEDIUM_INT),mediumFloatPrecision:T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.MEDIUM_FLOAT),highIntPrecision:T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.HIGH_INT),highFloatPrecision:T.getShaderPrecisionFormat(T.FRAGMENT_SHADER,T.HIGH_FLOAT)})}static getIsTextureFloat(){return!0}static getChannelCount(){return w.getParameter(w.MAX_DRAW_BUFFERS)}static getMaxTextureSize(){return w.getParameter(w.MAX_TEXTURE_SIZE)}static lookupKernelValueType(T,_,k,M){return a(T,_,k,M)}static get testCanvas(){return b}static get testContext(){return w}static get features(){return S}static get fragmentShader(){return l}static get vertexShader(){return h}initContext(){let T={alpha:!1,depth:!1,antialias:!1};return this.canvas.getContext("webgl2",T)}initExtensions(){this.extensions={EXT_color_buffer_float:this.context.getExtension("EXT_color_buffer_float"),OES_texture_float_linear:this.context.getExtension("OES_texture_float_linear")}}validateSettings(T){if(!this.validate){this.texSize=m.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output);return}let{features:_}=this.constructor;if(this.precision==="single"&&!_.isFloatRead)throw new Error("Float texture outputs are not supported");if(!this.graphical&&this.precision===null&&(this.precision=_.isFloatRead?"single":"unsigned"),this.fixIntegerDivisionAccuracy===null?this.fixIntegerDivisionAccuracy=!_.isIntegerDivisionAccurate:this.fixIntegerDivisionAccuracy&&_.isIntegerDivisionAccurate&&(this.fixIntegerDivisionAccuracy=!1),this.checkOutput(),!this.output||this.output.length===0){if(T.length!==1)throw new Error("Auto output only supported for kernels with only one input");let k=m.getVariableType(T[0],this.strictIntegers);switch(k){case"Array":this.output=m.getDimensions(k);break;case"NumberTexture":case"MemoryOptimizedNumberTexture":case"ArrayTexture(1)":case"ArrayTexture(2)":case"ArrayTexture(3)":case"ArrayTexture(4)":this.output=T[0].output;break;default:throw new Error("Auto output not supported for input type: "+k)}}if(this.graphical){if(this.output.length!==2)throw new Error("Output must have 2 dimensions on graphical mode");this.precision==="single"&&(console.warn("Cannot use graphical mode and single precision at the same time"),this.precision="unsigned"),this.texSize=m.clone(this.output);return}else!this.graphical&&this.precision===null&&_.isTextureFloat&&(this.precision="single");this.texSize=m.getKernelTextureSize({optimizeFloatMemory:this.optimizeFloatMemory,precision:this.precision},this.output),this.checkTextureSize()}translateSource(){let T=v.fromKernel(this,y,{fixIntegerDivisionAccuracy:this.fixIntegerDivisionAccuracy});this.translatedSource=T.getPrototypeString("kernel"),this.setupReturnTypes(T)}drawBuffers(){this.context.drawBuffers(this.drawBuffersMap)}getTextureFormat(){let{context:T}=this;switch(this.getInternalFormat()){case T.R32F:return T.RED;case T.RG32F:return T.RG;case T.RGBA32F:return T.RGBA;case T.RGBA:return T.RGBA;default:throw new Error("Unknown internal format")}}getInternalFormat(){let{context:T}=this;if(this.precision==="single"){if(this.pipeline)switch(this.returnType){case"Number":case"Float":case"Integer":return this.optimizeFloatMemory?T.RGBA32F:T.R32F;case"Array(2)":return T.RG32F;case"Array(3)":case"Array(4)":return T.RGBA32F;default:throw new Error("Unhandled return type")}return T.RGBA32F}return T.RGBA}_setupOutputTexture(){let T=this.context;if(this.texture){T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0,T.TEXTURE_2D,this.texture.texture,0);return}T.bindFramebuffer(T.FRAMEBUFFER,this.framebuffer);let _=T.createTexture(),k=this.texSize;T.activeTexture(T.TEXTURE0+this.constantTextureCount+this.argumentTextureCount),T.bindTexture(T.TEXTURE_2D,_),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_S,T.REPEAT),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_T,T.REPEAT),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,T.NEAREST),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MAG_FILTER,T.NEAREST);let M=this.getInternalFormat();this.precision==="single"?T.texStorage2D(T.TEXTURE_2D,1,M,k[0],k[1]):T.texImage2D(T.TEXTURE_2D,0,M,k[0],k[1],0,M,T.UNSIGNED_BYTE,null),T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0,T.TEXTURE_2D,_,0),this.texture=new this.TextureConstructor({texture:_,size:k,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this})}_setupSubOutputTextures(){let T=this.context;if(this.mappedTextures){for(let k=0;k<this.subKernels.length;k++)T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0+k+1,T.TEXTURE_2D,this.mappedTextures[k].texture,0);return}let _=this.texSize;this.drawBuffersMap=[T.COLOR_ATTACHMENT0],this.mappedTextures=[];for(let k=0;k<this.subKernels.length;k++){let M=this.createTexture();this.drawBuffersMap.push(T.COLOR_ATTACHMENT0+k+1),T.activeTexture(T.TEXTURE0+this.constantTextureCount+this.argumentTextureCount+k),T.bindTexture(T.TEXTURE_2D,M),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_S,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_WRAP_T,T.CLAMP_TO_EDGE),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MIN_FILTER,T.NEAREST),T.texParameteri(T.TEXTURE_2D,T.TEXTURE_MAG_FILTER,T.NEAREST);let P=this.getInternalFormat();this.precision==="single"?T.texStorage2D(T.TEXTURE_2D,1,P,_[0],_[1]):T.texImage2D(T.TEXTURE_2D,0,T.RGBA,_[0],_[1],0,T.RGBA,T.UNSIGNED_BYTE,null),T.framebufferTexture2D(T.FRAMEBUFFER,T.COLOR_ATTACHMENT0+k+1,T.TEXTURE_2D,M,0),this.mappedTextures.push(new this.TextureConstructor({texture:M,size:_,dimensions:this.threadDim,output:this.output,context:this.context,internalFormat:this.getInternalFormat(),textureFormat:this.getTextureFormat(),kernel:this}))}}_getHeaderString(){return""}_getTextureCoordinate(){let T=this.subKernels,_=this.getVariablePrecisionString(this.texSize,this.tactic);return T===null||T.length<1?`in ${_} vec2 vTexCoord;
`:`out ${_} vec2 vTexCoord;
`}_getMainArgumentsString(T){let _=[],k=this.argumentNames;for(let M=0;M<k.length;M++)_.push(this.kernelArguments[M].getSource(T[M]));return _.join("")}getKernelString(){let T=[this.getKernelResultDeclaration()],_=this.subKernels;if(_!==null)switch(T.push("layout(location = 0) out vec4 data0"),this.returnType){case"Number":case"Float":case"Integer":for(let k=0;k<_.length;k++){let M=_[k];T.push(M.returnType==="Integer"?`int subKernelResult_${M.name} = 0`:`float subKernelResult_${M.name} = 0.0`,`layout(location = ${k+1}) out vec4 data${k+1}`)}break;case"Array(2)":for(let k=0;k<_.length;k++)T.push(`vec2 subKernelResult_${_[k].name}`,`layout(location = ${k+1}) out vec4 data${k+1}`);break;case"Array(3)":for(let k=0;k<_.length;k++)T.push(`vec3 subKernelResult_${_[k].name}`,`layout(location = ${k+1}) out vec4 data${k+1}`);break;case"Array(4)":for(let k=0;k<_.length;k++)T.push(`vec4 subKernelResult_${_[k].name}`,`layout(location = ${k+1}) out vec4 data${k+1}`);break}else T.push("out vec4 data0");return m.linesToString(T)+this.translatedSource}getMainResultGraphical(){return m.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0 = actualColor"])}getMainResultPackedPixels(){switch(this.returnType){case"LiteralInteger":case"Number":case"Integer":case"Float":return this.getMainResultKernelPackedPixels()+this.getMainResultSubKernelPackedPixels();default:throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)}}getMainResultKernelPackedPixels(){return m.linesToString(["  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  data0 = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])}getMainResultSubKernelPackedPixels(){let T=[];if(!this.subKernels)return"";for(let _=0;_<this.subKernels.length;_++)this.subKernels[_].returnType==="Integer"?T.push(`  data${_+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[_].name}))`):T.push(`  data${_+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[_].name})`);return m.linesToString(T)}getMainResultKernelMemoryOptimizedFloats(T,_){T.push("  threadId = indexTo3D(index, uOutputDim)","  kernel()",`  data0.${_} = kernelResult`)}getMainResultSubKernelMemoryOptimizedFloats(T,_){if(!this.subKernels)return T;for(let k=0;k<this.subKernels.length;k++){let M=this.subKernels[k];M.returnType==="Integer"?T.push(`  data${k+1}.${_} = float(subKernelResult_${M.name})`):T.push(`  data${k+1}.${_} = subKernelResult_${M.name}`)}}getMainResultKernelNumberTexture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult"]}getMainResultSubKernelNumberTexture(){let T=[];if(!this.subKernels)return T;for(let _=0;_<this.subKernels.length;++_){let k=this.subKernels[_];k.returnType==="Integer"?T.push(`  data${_+1}[0] = float(subKernelResult_${k.name})`):T.push(`  data${_+1}[0] = subKernelResult_${k.name}`)}return T}getMainResultKernelArray2Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult[0]","  data0[1] = kernelResult[1]"]}getMainResultSubKernelArray2Texture(){let T=[];if(!this.subKernels)return T;for(let _=0;_<this.subKernels.length;++_){let k=this.subKernels[_];T.push(`  data${_+1}[0] = subKernelResult_${k.name}[0]`,`  data${_+1}[1] = subKernelResult_${k.name}[1]`)}return T}getMainResultKernelArray3Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0[0] = kernelResult[0]","  data0[1] = kernelResult[1]","  data0[2] = kernelResult[2]"]}getMainResultSubKernelArray3Texture(){let T=[];if(!this.subKernels)return T;for(let _=0;_<this.subKernels.length;++_){let k=this.subKernels[_];T.push(`  data${_+1}[0] = subKernelResult_${k.name}[0]`,`  data${_+1}[1] = subKernelResult_${k.name}[1]`,`  data${_+1}[2] = subKernelResult_${k.name}[2]`)}return T}getMainResultKernelArray4Texture(){return["  threadId = indexTo3D(index, uOutputDim)","  kernel()","  data0 = kernelResult"]}getMainResultSubKernelArray4Texture(){let T=[];if(!this.subKernels)return T;for(let _=0;_<this.subKernels.length;++_)T.push(`  data${_+1} = subKernelResult_${this.subKernels[_].name}`);return T}destroyExtensions(){this.extensions.EXT_color_buffer_float=null,this.extensions.OES_texture_float_linear=null}toJSON(){let T=super.toJSON();return T.functionNodes=v.fromKernel(this,y).toJSON(),T.settings.threadDim=this.threadDim,T}}c.exports={WebGL2Kernel:D}},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(i,c,d){let p=`#version 300 es
      __FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      
      in vec2 aPos;
      in vec2 aTexCoord;
      
      out vec2 vTexCoord;
      uniform vec2 ratio;
      
      void main(void) {
        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
        vTexCoord = aTexCoord;
      }`;c.exports={vertexShader:p}},{}],107:[function(i,c,d){let p=i("./index"),y=p.GPU;for(let m in p)!p.hasOwnProperty(m)||m!=="GPU"&&(y[m]=p[m]);typeof window<"u"&&v(window),typeof self<"u"&&v(self);function v(m){m.GPU||Object.defineProperty(m,"GPU",{get(){return y}})}c.exports=p},{"./index":109}],108:[function(i,c,d){let{gpuMock:p}=i("gpu-mock.js"),{utils:y}=i("./utils"),{Kernel:v}=i("./backend/kernel"),{CPUKernel:m}=i("./backend/cpu/kernel"),{HeadlessGLKernel:l}=i("./backend/headless-gl/kernel"),{WebGL2Kernel:h}=i("./backend/web-gl2/kernel"),{WebGLKernel:a}=i("./backend/web-gl/kernel"),{kernelRunShortcut:o}=i("./kernel-run-shortcut"),b=[l,h,a],w=["gpu","cpu"],I={headlessgl:l,webgl2:h,webgl:a},S=!0;class D{static disableValidation(){S=!1}static enableValidation(){S=!0}static get isGPUSupported(){return b.some(_=>_.isSupported)}static get isKernelMapSupported(){return b.some(_=>_.isSupported&&_.features.kernelMap)}static get isOffscreenCanvasSupported(){return typeof Worker<"u"&&typeof OffscreenCanvas<"u"||typeof importScripts<"u"}static get isWebGLSupported(){return a.isSupported}static get isWebGL2Supported(){return h.isSupported}static get isHeadlessGLSupported(){return l.isSupported}static get isCanvasSupported(){return typeof HTMLCanvasElement<"u"}static get isGPUHTMLImageArraySupported(){return h.isSupported}static get isSinglePrecisionSupported(){return b.some(_=>_.isSupported&&_.features.isFloatRead&&_.features.isTextureFloat)}constructor(_){if(_=_||{},this.canvas=_.canvas||null,this.context=_.context||null,this.mode=_.mode,this.Kernel=null,this.kernels=[],this.functions=[],this.nativeFunctions=[],this.injectedNative=null,this.mode!=="dev"){if(this.chooseKernel(),_.functions)for(let k=0;k<_.functions.length;k++)this.addFunction(_.functions[k]);if(_.nativeFunctions)for(let k in _.nativeFunctions){if(!_.nativeFunctions.hasOwnProperty(k))continue;let M=_.nativeFunctions[k],{name:P,source:A}=M;this.addNativeFunction(P,A,M)}}}chooseKernel(){if(this.Kernel)return;let _=null;if(this.context){for(let k=0;k<b.length;k++){let M=b[k];if(M.isContextMatch(this.context)){if(!M.isSupported)throw new Error(`Kernel type ${M.name} not supported`);_=M;break}}if(_===null)throw new Error("unknown Context")}else if(this.mode){if(this.mode in I)(!S||I[this.mode].isSupported)&&(_=I[this.mode]);else if(this.mode==="gpu"){for(let k=0;k<b.length;k++)if(b[k].isSupported){_=b[k];break}}else this.mode==="cpu"&&(_=m);if(!_)throw new Error(`A requested mode of "${this.mode}" and is not supported`)}else{for(let k=0;k<b.length;k++)if(b[k].isSupported){_=b[k];break}_||(_=m)}this.mode||(this.mode=_.mode),this.Kernel=_}createKernel(_,k){if(typeof _>"u")throw new Error("Missing source parameter");if(typeof _!="object"&&!y.isFunction(_)&&typeof _!="string")throw new Error("source parameter not a function");let M=this.kernels;if(this.mode==="dev"){let V=p(_,C(k));return M.push(V),V}_=typeof _=="function"?_.toString():_;let P={},A=C(k)||{};k&&typeof k.argumentTypes=="object"&&(A.argumentTypes=Object.keys(k.argumentTypes).map(V=>k.argumentTypes[V]));function f(V){console.warn("Falling back to CPU");let j=new m(_,{argumentTypes:O.argumentTypes,constantTypes:O.constantTypes,graphical:O.graphical,loopMaxIterations:O.loopMaxIterations,constants:O.constants,dynamicOutput:O.dynamicOutput,dynamicArgument:O.dynamicArguments,output:O.output,precision:O.precision,pipeline:O.pipeline,immutable:O.immutable,optimizeFloatMemory:O.optimizeFloatMemory,fixIntegerDivisionAccuracy:O.fixIntegerDivisionAccuracy,functions:O.functions,nativeFunctions:O.nativeFunctions,injectedNative:O.injectedNative,subKernels:O.subKernels,strictIntegers:O.strictIntegers,debug:O.debug});j.build.apply(j,V);let z=j.run.apply(j,V);return O.replaceKernel(j),z}function R(V,j,z){z.debug&&console.warn("Switching kernels");let q=null;if(z.signature&&!P[z.signature]&&(P[z.signature]=z),z.dynamicOutput)for(let Y=V.length-1;Y>=0;Y--){let X=V[Y];X.type==="outputPrecisionMismatch"&&(q=X.needed)}let H=z.constructor,U=H.getArgumentTypes(z,j),J=H.getSignature(z,U),ee=P[J];if(ee)return ee.onActivate(z),ee;let Z=P[J]=new H(_,{argumentTypes:U,constantTypes:z.constantTypes,graphical:z.graphical,loopMaxIterations:z.loopMaxIterations,constants:z.constants,dynamicOutput:z.dynamicOutput,dynamicArgument:z.dynamicArguments,context:z.context,canvas:z.canvas,output:q||z.output,precision:z.precision,pipeline:z.pipeline,immutable:z.immutable,optimizeFloatMemory:z.optimizeFloatMemory,fixIntegerDivisionAccuracy:z.fixIntegerDivisionAccuracy,functions:z.functions,nativeFunctions:z.nativeFunctions,injectedNative:z.injectedNative,subKernels:z.subKernels,strictIntegers:z.strictIntegers,debug:z.debug,gpu:z.gpu,validate:S,returnType:z.returnType,tactic:z.tactic,onRequestFallback:f,onRequestSwitchKernel:R,texture:z.texture,mappedTextures:z.mappedTextures,drawBuffersMap:z.drawBuffersMap});return Z.build.apply(Z,j),O.replaceKernel(Z),M.push(Z),Z}let N=Object.assign({context:this.context,canvas:this.canvas,functions:this.functions,nativeFunctions:this.nativeFunctions,injectedNative:this.injectedNative,gpu:this,validate:S,onRequestFallback:f,onRequestSwitchKernel:R},A),K=new this.Kernel(_,N),O=o(K);return this.canvas||(this.canvas=K.canvas),this.context||(this.context=K.context),M.push(K),O}createKernelMap(){let _,k,M=typeof arguments[arguments.length-2];if(M==="function"||M==="string"?(_=arguments[arguments.length-2],k=arguments[arguments.length-1]):_=arguments[arguments.length-1],this.mode!=="dev"&&(!this.Kernel.isSupported||!this.Kernel.features.kernelMap)&&this.mode&&w.indexOf(this.mode)<0)throw new Error(`kernelMap not supported on ${this.Kernel.name}`);let P=C(k);if(k&&typeof k.argumentTypes=="object"&&(P.argumentTypes=Object.keys(k.argumentTypes).map(A=>k.argumentTypes[A])),Array.isArray(arguments[0])){P.subKernels=[];let A=arguments[0];for(let f=0;f<A.length;f++){let R=A[f].toString(),N=y.getFunctionNameFromString(R);P.subKernels.push({name:N,source:R,property:f})}}else{P.subKernels=[];let A=arguments[0];for(let f in A){if(!A.hasOwnProperty(f))continue;let R=A[f].toString(),N=y.getFunctionNameFromString(R);P.subKernels.push({name:N||f,source:R,property:f})}}return this.createKernel(_,P)}combineKernels(){let _=arguments[0],k=arguments[arguments.length-1];if(_.kernel.constructor.mode==="cpu")return k;let M=arguments[0].canvas,P=arguments[0].context,A=arguments.length-1;for(let f=0;f<A;f++)arguments[f].setCanvas(M).setContext(P).setPipeline(!0);return function(){let f=k.apply(this,arguments);return f.toArray?f.toArray():f}}setFunctions(_){return this.functions=_,this}setNativeFunctions(_){return this.nativeFunctions=_,this}addFunction(_,k){return this.functions.push({source:_,settings:k}),this}addNativeFunction(_,k,M){if(this.kernels.length>0)throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');return this.nativeFunctions.push(Object.assign({name:_,source:k},M)),this}injectNative(_){return this.injectedNative=_,this}destroy(){return new Promise((_,k)=>{this.kernels||_(),setTimeout(()=>{try{for(let P=0;P<this.kernels.length;P++)this.kernels[P].destroy(!0);let M=this.kernels[0];M&&(M.kernel&&(M=M.kernel),M.constructor.destroyContext&&M.constructor.destroyContext(this.context))}catch(M){k(M)}_()},0)})}}function C(T){if(!T)return{};let _=Object.assign({},T);return T.hasOwnProperty("floatOutput")&&(y.warnDeprecated("setting","floatOutput","precision"),_.precision=T.floatOutput?"single":"unsigned"),T.hasOwnProperty("outputToTexture")&&(y.warnDeprecated("setting","outputToTexture","pipeline"),_.pipeline=Boolean(T.outputToTexture)),T.hasOwnProperty("outputImmutable")&&(y.warnDeprecated("setting","outputImmutable","immutable"),_.immutable=Boolean(T.outputImmutable)),T.hasOwnProperty("floatTextures")&&(y.warnDeprecated("setting","floatTextures","optimizeFloatMemory"),_.optimizeFloatMemory=Boolean(T.floatTextures)),_}c.exports={GPU:D,kernelOrder:b,kernelTypes:w}},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(i,c,d){let{GPU:p}=i("./gpu"),{alias:y}=i("./alias"),{utils:v}=i("./utils"),{Input:m,input:l}=i("./input"),{Texture:h}=i("./texture"),{FunctionBuilder:a}=i("./backend/function-builder"),{FunctionNode:o}=i("./backend/function-node"),{CPUFunctionNode:b}=i("./backend/cpu/function-node"),{CPUKernel:w}=i("./backend/cpu/kernel"),{HeadlessGLKernel:I}=i("./backend/headless-gl/kernel"),{WebGLFunctionNode:S}=i("./backend/web-gl/function-node"),{WebGLKernel:D}=i("./backend/web-gl/kernel"),{kernelValueMaps:C}=i("./backend/web-gl/kernel-value-maps"),{WebGL2FunctionNode:T}=i("./backend/web-gl2/function-node"),{WebGL2Kernel:_}=i("./backend/web-gl2/kernel"),{kernelValueMaps:k}=i("./backend/web-gl2/kernel-value-maps"),{GLKernel:M}=i("./backend/gl/kernel"),{Kernel:P}=i("./backend/kernel"),{FunctionTracer:A}=i("./backend/function-tracer"),f=i("./plugins/math-random-uniformly-distributed");c.exports={alias:y,CPUFunctionNode:b,CPUKernel:w,GPU:p,FunctionBuilder:a,FunctionNode:o,HeadlessGLKernel:I,Input:m,input:l,Texture:h,utils:v,WebGL2FunctionNode:T,WebGL2Kernel:_,webGL2KernelValueMaps:k,WebGLFunctionNode:S,WebGLKernel:D,webGLKernelValueMaps:C,GLKernel:M,Kernel:P,FunctionTracer:A,plugins:{mathRandom:f}}},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(i,c,d){class p{constructor(m,l){this.value=m,Array.isArray(l)?this.size=l:(this.size=new Int32Array(3),l.z?this.size=new Int32Array([l.x,l.y,l.z]):l.y?this.size=new Int32Array([l.x,l.y]):this.size=new Int32Array([l.x]));let[h,a,o]=this.size;if(o){if(this.value.length!==h*a*o)throw new Error(`Input size ${this.value.length} does not match ${h} * ${a} * ${o} = ${a*h*o}`)}else if(a){if(this.value.length!==h*a)throw new Error(`Input size ${this.value.length} does not match ${h} * ${a} = ${a*h}`)}else if(this.value.length!==h)throw new Error(`Input size ${this.value.length} does not match ${h}`)}toArray(){let{utils:m}=i("./utils"),[l,h,a]=this.size;return a?m.erectMemoryOptimized3DFloat(this.value.subarray?this.value:new Float32Array(this.value),l,h,a):h?m.erectMemoryOptimized2DFloat(this.value.subarray?this.value:new Float32Array(this.value),l,h):this.value}}function y(v,m){return new p(v,m)}c.exports={Input:p,input:y}},{"./utils":114}],111:[function(i,c,d){let{utils:p}=i("./utils");function y(m){let l=function(){return m.build.apply(m,arguments),l=function(){let a=m.run.apply(m,arguments);if(m.switchingKernels){let o=m.resetSwitchingKernels(),b=m.onRequestSwitchKernel(o,arguments,m);h.kernel=m=b,a=b.run.apply(b,arguments)}return m.renderKernels?m.renderKernels():m.renderOutput?m.renderOutput():a},l.apply(m,arguments)},h=function(){return l.apply(m,arguments)};return h.exec=function(){return new Promise((a,o)=>{try{a(l.apply(this,arguments))}catch(b){o(b)}})},h.replaceKernel=function(a){m=a,v(m,h)},v(m,h),h}function v(m,l){if(l.kernel){l.kernel=m;return}let h=p.allPropertiesOf(m);for(let a=0;a<h.length;a++){let o=h[a];o[0]==="_"&&o[1]==="_"||(typeof m[o]=="function"?o.substring(0,3)==="add"||o.substring(0,3)==="set"?l[o]=function(){return l.kernel[o].apply(l.kernel,arguments),l}:l[o]=function(){return l.kernel[o].apply(l.kernel,arguments)}:(l.__defineGetter__(o,()=>l.kernel[o]),l.__defineSetter__(o,b=>{l.kernel[o]=b})))}l.kernel=m}c.exports={kernelRunShortcut:y}},{"./utils":114}],112:[function(i,c,d){let p={name:"math-random-uniformly-distributed",onBeforeRun:y=>{y.setUniform1f("randomSeed1",Math.random()),y.setUniform1f("randomSeed2",Math.random())},functionMatch:"Math.random()",functionReplace:"nrand(vTexCoord)",functionReturnType:"Number",source:`// https://www.shadertoy.com/view/4t2SDh
      //note: uniformly distributed, normalized rand, [0,1]
      highp float randomSeedShift = 1.0;
      highp float slide = 1.0;
      uniform highp float randomSeed1;
      uniform highp float randomSeed2;
      
      highp float nrand(highp vec2 n) {
        highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
        randomSeedShift = result;
        if (randomSeedShift > 0.5) {
          slide += 0.00009; 
        } else {
          slide += 0.0009;
        }
        return result;
      }`};c.exports=p},{}],113:[function(i,c,d){class p{constructor(v){let{texture:m,size:l,dimensions:h,output:a,context:o,type:b="NumberTexture",kernel:w,internalFormat:I,textureFormat:S}=v;if(!a)throw new Error('settings property "output" required.');if(!o)throw new Error('settings property "context" required.');if(!m)throw new Error('settings property "texture" required.');if(!w)throw new Error('settings property "kernel" required.');this.texture=m,m._refs?m._refs++:m._refs=1,this.size=l,this.dimensions=h,this.output=a,this.context=o,this.kernel=w,this.type=b,this._deleted=!1,this.internalFormat=I,this.textureFormat=S}toArray(){throw new Error(`Not implemented on ${this.constructor.name}`)}clone(){throw new Error(`Not implemented on ${this.constructor.name}`)}delete(){throw new Error(`Not implemented on ${this.constructor.name}`)}clear(){throw new Error(`Not implemented on ${this.constructor.name}`)}}c.exports={Texture:p}},{}],114:[function(i,c,d){let p=i("acorn"),{Input:y}=i("./input"),{Texture:v}=i("./texture"),m=/function ([^(]*)/,l=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,h=/([^\s,]+)/g,a={systemEndianness(){return I},getSystemEndianness(){let S=new ArrayBuffer(4),D=new Uint32Array(S),C=new Uint8Array(S);if(D[0]=3735928559,C[0]===239)return"LE";if(C[0]===222)return"BE";throw new Error("unknown endianness")},isFunction(S){return typeof S=="function"},isFunctionString(S){return typeof S=="string"?S.slice(0,8).toLowerCase()==="function":!1},getFunctionNameFromString(S){let D=m.exec(S);return!D||D.length===0?null:D[1].trim()},getFunctionBodyFromString(S){return S.substring(S.indexOf("{")+1,S.lastIndexOf("}"))},getArgumentNamesFromString(S){let D=S.replace(l,""),C=D.slice(D.indexOf("(")+1,D.indexOf(")")).match(h);return C===null&&(C=[]),C},clone(S){if(S===null||typeof S!="object"||S.hasOwnProperty("isActiveClone"))return S;let D=S.constructor();for(let C in S)Object.prototype.hasOwnProperty.call(S,C)&&(S.isActiveClone=null,D[C]=a.clone(S[C]),delete S.isActiveClone);return D},isArray(S){return!isNaN(S.length)},getVariableType(S,D){if(a.isArray(S))return S.length>0&&S[0].nodeName==="IMG"?"HTMLImageArray":"Array";switch(S.constructor){case Boolean:return"Boolean";case Number:return D&&Number.isInteger(S)?"Integer":"Float";case v:return S.type;case y:return"Input"}switch(S.nodeName){case"IMG":return"HTMLImage";case"CANVAS":return"HTMLImage";case"VIDEO":return"HTMLVideo"}return S.hasOwnProperty("type")?S.type:"Unknown"},getKernelTextureSize(S,D){let[C,T,_]=D,k=(C||1)*(T||1)*(_||1);return S.optimizeFloatMemory&&S.precision==="single"&&(C=k=Math.ceil(k/4)),T>1&&C*T===k?new Int32Array([C,T]):a.closestSquareDimensions(k)},closestSquareDimensions(S){let D=Math.sqrt(S),C=Math.ceil(D),T=Math.floor(D);for(;C*T<S;)C--,T=Math.ceil(S/C);return new Int32Array([T,Math.ceil(S/T)])},getMemoryOptimizedFloatTextureSize(S,D){let C=a.roundTo((S[0]||1)*(S[1]||1)*(S[2]||1)*(S[3]||1),4)/D;return a.closestSquareDimensions(C)},getMemoryOptimizedPackedTextureSize(S,D){let[C,T,_]=S,k=a.roundTo((C||1)*(T||1)*(_||1),4)/(4/D);return a.closestSquareDimensions(k)},roundTo(S,D){return Math.floor((S+D-1)/D)*D},getDimensions(S,D){let C;if(a.isArray(S)){let T=[],_=S;for(;a.isArray(_);)T.push(_.length),_=_[0];C=T.reverse()}else if(S instanceof v)C=S.output;else if(S instanceof y)C=S.size;else throw new Error(`Unknown dimensions of ${S}`);if(D)for(C=Array.from(C);C.length<3;)C.push(1);return new Int32Array(C)},flatten2dArrayTo(S,D){let C=0;for(let T=0;T<S.length;T++)D.set(S[T],C),C+=S[T].length},flatten3dArrayTo(S,D){let C=0;for(let T=0;T<S.length;T++)for(let _=0;_<S[T].length;_++)D.set(S[T][_],C),C+=S[T][_].length},flatten4dArrayTo(S,D){let C=0;for(let T=0;T<S.length;T++)for(let _=0;_<S[T].length;_++)for(let k=0;k<S[T][_].length;k++)D.set(S[T][_][k],C),C+=S[T][_][k].length},flattenTo(S,D){a.isArray(S[0])?a.isArray(S[0][0])?a.isArray(S[0][0][0])?a.flatten4dArrayTo(S,D):a.flatten3dArrayTo(S,D):a.flatten2dArrayTo(S,D):D.set(S)},splitArray(S,D){let C=[];for(let T=0;T<S.length;T+=D)C.push(new S.constructor(S.buffer,T*4+S.byteOffset,D));return C},getAstString(S,D){let C=Array.isArray(S)?S:S.split(/\r?\n/g),T=D.loc.start,_=D.loc.end,k=[];if(T.line===_.line)k.push(C[T.line-1].substring(T.column,_.column));else{k.push(C[T.line-1].slice(T.column));for(let M=T.line;M<_.line;M++)k.push(C[M]);k.push(C[_.line-1].slice(0,_.column))}return k.join(`
`)},allPropertiesOf(S){let D=[];do D.push.apply(D,Object.getOwnPropertyNames(S));while(S=Object.getPrototypeOf(S));return D},linesToString(S){return S.length>0?S.join(`;
`)+`;
`:`
`},warnDeprecated(S,D,C){console.warn(C?`You are using a deprecated ${S} "${D}". It has been replaced with "${C}". Fixing, but please upgrade as it will soon be removed.`:`You are using a deprecated ${S} "${D}". It has been removed. Fixing, but please upgrade as it will soon be removed.`)},flipPixels:(S,D,C)=>{let T=C/2|0,_=D*4,k=new Uint8ClampedArray(D*4),M=S.slice(0);for(let P=0;P<T;++P){let A=P*_,f=(C-P-1)*_;k.set(M.subarray(A,A+_)),M.copyWithin(A,f,f+_),M.set(k,f)}return M},erectPackedFloat:(S,D)=>S.subarray(0,D),erect2DPackedFloat:(S,D,C)=>{let T=new Array(C);for(let _=0;_<C;_++){let k=_*D,M=k+D;T[_]=S.subarray(k,M)}return T},erect3DPackedFloat:(S,D,C,T)=>{let _=new Array(T);for(let k=0;k<T;k++){let M=new Array(C);for(let P=0;P<C;P++){let A=k*C*D+P*D,f=A+D;M[P]=S.subarray(A,f)}_[k]=M}return _},erectMemoryOptimizedFloat:(S,D)=>S.subarray(0,D),erectMemoryOptimized2DFloat:(S,D,C)=>{let T=new Array(C);for(let _=0;_<C;_++){let k=_*D;T[_]=S.subarray(k,k+D)}return T},erectMemoryOptimized3DFloat:(S,D,C,T)=>{let _=new Array(T);for(let k=0;k<T;k++){let M=new Array(C);for(let P=0;P<C;P++){let A=k*C*D+P*D;M[P]=S.subarray(A,A+D)}_[k]=M}return _},erectFloat:(S,D)=>{let C=new Float32Array(D),T=0;for(let _=0;_<D;_++)C[_]=S[T],T+=4;return C},erect2DFloat:(S,D,C)=>{let T=new Array(C),_=0;for(let k=0;k<C;k++){let M=new Float32Array(D);for(let P=0;P<D;P++)M[P]=S[_],_+=4;T[k]=M}return T},erect3DFloat:(S,D,C,T)=>{let _=new Array(T),k=0;for(let M=0;M<T;M++){let P=new Array(C);for(let A=0;A<C;A++){let f=new Float32Array(D);for(let R=0;R<D;R++)f[R]=S[k],k+=4;P[A]=f}_[M]=P}return _},erectArray2:(S,D)=>{let C=new Array(D),T=D*4,_=0;for(let k=0;k<T;k+=4)C[_++]=S.subarray(k,k+2);return C},erect2DArray2:(S,D,C)=>{let T=new Array(C),_=D*4;for(let k=0;k<C;k++){let M=new Array(D),P=k*_,A=0;for(let f=0;f<_;f+=4)M[A++]=S.subarray(f+P,f+P+2);T[k]=M}return T},erect3DArray2:(S,D,C,T)=>{let _=D*4,k=new Array(T);for(let M=0;M<T;M++){let P=new Array(C);for(let A=0;A<C;A++){let f=new Array(D),R=M*_*C+A*_,N=0;for(let K=0;K<_;K+=4)f[N++]=S.subarray(K+R,K+R+2);P[A]=f}k[M]=P}return k},erectArray3:(S,D)=>{let C=new Array(D),T=D*4,_=0;for(let k=0;k<T;k+=4)C[_++]=S.subarray(k,k+3);return C},erect2DArray3:(S,D,C)=>{let T=D*4,_=new Array(C);for(let k=0;k<C;k++){let M=new Array(D),P=k*T,A=0;for(let f=0;f<T;f+=4)M[A++]=S.subarray(f+P,f+P+3);_[k]=M}return _},erect3DArray3:(S,D,C,T)=>{let _=D*4,k=new Array(T);for(let M=0;M<T;M++){let P=new Array(C);for(let A=0;A<C;A++){let f=new Array(D),R=M*_*C+A*_,N=0;for(let K=0;K<_;K+=4)f[N++]=S.subarray(K+R,K+R+3);P[A]=f}k[M]=P}return k},erectArray4:(S,D)=>{let C=new Array(S),T=D*4,_=0;for(let k=0;k<T;k+=4)C[_++]=S.subarray(k,k+4);return C},erect2DArray4:(S,D,C)=>{let T=D*4,_=new Array(C);for(let k=0;k<C;k++){let M=new Array(D),P=k*T,A=0;for(let f=0;f<T;f+=4)M[A++]=S.subarray(f+P,f+P+4);_[k]=M}return _},erect3DArray4:(S,D,C,T)=>{let _=D*4,k=new Array(T);for(let M=0;M<T;M++){let P=new Array(C);for(let A=0;A<C;A++){let f=new Array(D),R=M*_*C+A*_,N=0;for(let K=0;K<_;K+=4)f[N++]=S.subarray(K+R,K+R+4);P[A]=f}k[M]=P}return k},flattenFunctionToString:(S,D)=>{let{findDependency:C,thisLookup:T,doNotDefine:_}=D,k=D.flattened;k||(k=D.flattened={});let M=p.parse(S),P=[],A=0;function f(N){if(Array.isArray(N)){let K=[];for(let O=0;O<N.length;O++)K.push(f(N[O]));return K.join("")}switch(N.type){case"Program":return f(N.body)+(N.body[0].type==="VariableDeclaration"?";":"");case"FunctionDeclaration":return`function ${N.id.name}(${N.params.map(f).join(", ")}) ${f(N.body)}`;case"BlockStatement":{let O=[];A+=2;for(let V=0;V<N.body.length;V++){let j=f(N.body[V]);j&&O.push(" ".repeat(A)+j,`;
`)}return A-=2,`{
${O.join("")}}`}case"VariableDeclaration":let K=a.normalizeDeclarations(N).map(f).filter(O=>O!==null);return K.length<1?"":`${N.kind} ${K.join(",")}`;case"VariableDeclarator":return N.init.object&&N.init.object.type==="ThisExpression"?T(N.init.property.name,!0)?`${N.id.name} = ${f(N.init)}`:null:`${N.id.name} = ${f(N.init)}`;case"CallExpression":{if(N.callee.property.name==="subarray")return`${f(N.callee.object)}.${f(N.callee.property)}(${N.arguments.map(O=>f(O)).join(", ")})`;if(N.callee.object.name==="gl"||N.callee.object.name==="context")return`${f(N.callee.object)}.${f(N.callee.property)}(${N.arguments.map(O=>f(O)).join(", ")})`;if(N.callee.object.type==="ThisExpression")return P.push(C("this",N.callee.property.name)),`${N.callee.property.name}(${N.arguments.map(O=>f(O)).join(", ")})`;if(N.callee.object.name){let O=C(N.callee.object.name,N.callee.property.name);return O===null?`${N.callee.object.name}.${N.callee.property.name}(${N.arguments.map(V=>f(V)).join(", ")})`:(P.push(O),`${N.callee.property.name}(${N.arguments.map(V=>f(V)).join(", ")})`)}else{if(N.callee.object.type==="MemberExpression")return`${f(N.callee.object)}.${N.callee.property.name}(${N.arguments.map(O=>f(O)).join(", ")})`;throw new Error("unknown ast.callee")}}case"ReturnStatement":return`return ${f(N.argument)}`;case"BinaryExpression":return`(${f(N.left)}${N.operator}${f(N.right)})`;case"UnaryExpression":return N.prefix?`${N.operator} ${f(N.argument)}`:`${f(N.argument)} ${N.operator}`;case"ExpressionStatement":return`${f(N.expression)}`;case"SequenceExpression":return`(${f(N.expressions)})`;case"ArrowFunctionExpression":return`(${N.params.map(f).join(", ")}) => ${f(N.body)}`;case"Literal":return N.raw;case"Identifier":return N.name;case"MemberExpression":return N.object.type==="ThisExpression"?T(N.property.name):N.computed?`${f(N.object)}[${f(N.property)}]`:f(N.object)+"."+f(N.property);case"ThisExpression":return"this";case"NewExpression":return`new ${f(N.callee)}(${N.arguments.map(O=>f(O)).join(", ")})`;case"ForStatement":return`for (${f(N.init)};${f(N.test)};${f(N.update)}) ${f(N.body)}`;case"AssignmentExpression":return`${f(N.left)}${N.operator}${f(N.right)}`;case"UpdateExpression":return`${f(N.argument)}${N.operator}`;case"IfStatement":return`if (${f(N.test)}) ${f(N.consequent)}`;case"ThrowStatement":return`throw ${f(N.argument)}`;case"ObjectPattern":return N.properties.map(f).join(", ");case"ArrayPattern":return N.elements.map(f).join(", ");case"DebuggerStatement":return"debugger;";case"ConditionalExpression":return`${f(N.test)}?${f(N.consequent)}:${f(N.alternate)}`;case"Property":if(N.kind==="init")return f(N.key)}throw new Error(`unhandled ast.type of ${N.type}`)}let R=f(M);if(P.length>0){let N=[];for(let K=0;K<P.length;K++){let O=P[K];k[O]||(k[O]=!0),O&&N.push(a.flattenFunctionToString(O,D)+`
`)}return N.join("")+R}return R},normalizeDeclarations:S=>{if(S.type!=="VariableDeclaration")throw new Error('Ast is not of type "VariableDeclaration"');let D=[];for(let C=0;C<S.declarations.length;C++){let T=S.declarations[C];if(T.id&&T.id.type==="ObjectPattern"&&T.id.properties){let{properties:_}=T.id;for(let k=0;k<_.length;k++){let M=_[k];if(M.value.type==="ObjectPattern"&&M.value.properties)for(let P=0;P<M.value.properties.length;P++){let A=M.value.properties[P];if(A.type==="Property")D.push({type:"VariableDeclarator",id:{type:"Identifier",name:A.key.name},init:{type:"MemberExpression",object:{type:"MemberExpression",object:T.init,property:{type:"Identifier",name:M.key.name},computed:!1},property:{type:"Identifier",name:A.key.name},computed:!1}});else throw new Error("unexpected state")}else if(M.value.type==="Identifier")D.push({type:"VariableDeclarator",id:{type:"Identifier",name:M.value&&M.value.name?M.value.name:M.key.name},init:{type:"MemberExpression",object:T.init,property:{type:"Identifier",name:M.key.name},computed:!1}});else throw new Error("unexpected state")}}else if(T.id&&T.id.type==="ArrayPattern"&&T.id.elements){let{elements:_}=T.id;for(let k=0;k<_.length;k++){let M=_[k];if(M.type==="Identifier")D.push({type:"VariableDeclarator",id:{type:"Identifier",name:M.name},init:{type:"MemberExpression",object:T.init,property:{type:"Literal",value:k,raw:k.toString(),start:M.start,end:M.end},computed:!0}});else throw new Error("unexpected state")}}else D.push(T)}return D},splitHTMLImageToRGB:(S,D)=>{let C=S.createKernel(function(P){return P[this.thread.y][this.thread.x].r*255},{output:[D.width,D.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),T=S.createKernel(function(P){return P[this.thread.y][this.thread.x].g*255},{output:[D.width,D.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),_=S.createKernel(function(P){return P[this.thread.y][this.thread.x].b*255},{output:[D.width,D.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),k=S.createKernel(function(P){return P[this.thread.y][this.thread.x].a*255},{output:[D.width,D.height],precision:"unsigned",argumentTypes:{a:"HTMLImage"}}),M=[C(D),T(D),_(D),k(D)];return M.rKernel=C,M.gKernel=T,M.bKernel=_,M.aKernel=k,M.gpu=S,M},splitRGBAToCanvases:(S,D,C,T)=>{let _=S.createKernel(function(A){let f=A[this.thread.y][this.thread.x];this.color(f.r/255,0,0,255)},{output:[C,T],graphical:!0,argumentTypes:{v:"Array2D(4)"}});_(D);let k=S.createKernel(function(A){let f=A[this.thread.y][this.thread.x];this.color(0,f.g/255,0,255)},{output:[C,T],graphical:!0,argumentTypes:{v:"Array2D(4)"}});k(D);let M=S.createKernel(function(A){let f=A[this.thread.y][this.thread.x];this.color(0,0,f.b/255,255)},{output:[C,T],graphical:!0,argumentTypes:{v:"Array2D(4)"}});M(D);let P=S.createKernel(function(A){let f=A[this.thread.y][this.thread.x];this.color(255,255,255,f.a/255)},{output:[C,T],graphical:!0,argumentTypes:{v:"Array2D(4)"}});return P(D),[_.canvas,k.canvas,M.canvas,P.canvas]},getMinifySafeName:S=>{try{let D=p.parse(`const value = ${S.toString()}`),{init:C}=D.body[0].declarations[0];return C.body.name||C.body.body[0].argument.name}catch{throw new Error("Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }")}},sanitizeName:function(S){return o.test(S)&&(S=S.replace(o,"S_S")),b.test(S)?S=S.replace(b,"U_U"):w.test(S)&&(S=S.replace(w,"u_u")),S}},o=/\$/,b=/__/,w=/_/,I=a.getSystemEndianness();c.exports={utils:a}},{"./input":110,"./texture":113,acorn:1}]},{},[107])(107)})}),ls=Pr(Br());var zr=Object.defineProperty,Gr=(u,t,e)=>t in u?zr(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,pe=(u,t,e)=>(Gr(u,typeof t!="symbol"?t+"":t,e),e),Le=class{constructor(){}static genSineWave(u=20,t=1,e=1,n=512,s=0,i=1){for(var c=[],d=[],p=1/n,y=0;y<e;y+=p){var v=Math.sin(2*Math.PI*u*y)*t;v+=Math.sin(2*Math.PI*s*y)*i,c.push(v),d.push(y)}return[d,c]}static getSineAmplitude(u=20,t=1,e=0,n=0){return Math.sin(this.TWO_PI*u*e+n)*t}static mean(u){var t=u.reduce((e,n)=>n+=e);return t/u.length}static mode(u){return u.sort((t,e)=>u.filter(n=>n===t).length-u.filter(n=>n===e).length).pop()}static std(u,t=void 0){let e=t;t||(e=this.mean(u));let n=0;for(let s=0;s<u.length;s++){let i=u[s]-e;n+=i*i}return Math.sqrt(n/u.length)}static relError(u=[],t=[],e=!0){if(u.length!==t.length)throw new Error("Input arrays of same length!");let n=u.length,s=new Array(u.length);for(let i=0;i<n;i++){let c=(u[i]-t[i])/u[i];e&&(c=Math.abs(c)),s[i]=c}return s}static informationEntropy(u=[]){let t=u.length,e=new Array(t);for(let n=0;n<t;n++){let s=u[n]*Math.log(u[n]);isNaN(s)&&(s=0),e[n]=s}return e}static zscore(u){let t=this.mean(u),e=this.std(u,t),n=new Array().length(u.length);for(let s=0;s<u.length;s++)n[s]=(u[s]-t)/e;return n}static variance(u){var t=this.mean(u);return u.reduce((e,n)=>e+(n-t)**2,0)/u.length}static dot(u,t){for(var e=0,n=0;n<u.length;n++)e+=u[n]*t[n];return e}static cross3D(u,t){return[u[1]*t[2]-u[2]*t[1],u[2]*t[0]-u[0]*t[2],u[0]*t[1]-u[1]*t[0]]}static magnitude(u){var t=0;return u.forEach(e=>{t+=e*e}),Math.sqrt(t)}static distance(u,t){var e=0;return u.forEach((n,s)=>{e+=(t[s]-n)*(t[s]-n)}),Math.sqrt(e)}static midpoint(u=[1,2,3],t=[3,4,5]){return u.map((e,n)=>(e+t[n])*.5)}static normalize(u){var t=0;t=this.magnitude(u);var e=new Array(u.length);return u.forEach((n,s)=>{e[s]=n*t}),e}static normalizeSeries(u=[],t=!0){let e=Math.max(...u),n=Math.min(...u);return t==!1&&(e=Math.max(e,Math.abs(n)),n=0),e-n===0&&(n=0,e===0&&(e=1e-13)),u.map(s=>(s-n)/(e-n))}static quadraticFormula(u,t,e){let n=Math.sqrt(t*t-4*u*e);if(!isNaN(n))return["complex","complex"];let s=1/(2*u);if(n===0)return[t*s];let i=-t;return[(i+n)*s,(i-n)*s]}static newtonsMethod(u=i=>Math.pow(i,5)+i*i-i-.2,t=0,e=1,n=.01,s=10){let i=[];for(let c=0;c<s;c++){let d=Math.random()*(e-t),p=u(d),y=u(d+n),v=(y-p)/n,m=d+n;for(;Math.abs(v)>n;){let a=-p/b,o=m+a;p=y,y=u(o);let b=(y-p)/(o-m)}let l,h=i.find((a,o)=>{if(Math.abs(xn1-a)<n)return l=o,!0});h?i[l]=(xn1+h)*.5:i.push(xn1)}return i}static makeVec(u,t){var e=[];return u.forEach((n,s)=>{e.push(t[s]-n)}),e}static getBufferedValueByCoordinates(u=new Array(300).fill(1),t=[10,10,2],e=[1,2,1],n=void 0){let s=(c=0,d=0)=>{if(d===t.length)return c;if(d==0)c+=e[d];else if(t[d]==0)dimsAt0++;else{let p=(y=e[d],v=d-1)=>(y*=t[v],v--,v==0?y:p(y,v));c+=p(e[d]+1,d-1)}return d++,s(c,d)},i=s();if(n){if(e[e.length-1]===0){let c=0,d=0;for(;d!==e.length-1;)e[d]!==0&&(c=d),d++;return u[i-c+n]}return u[i-t.length+n]}else{if(e[e.length-1]===0){let c=0,d=0;for(;d!==e.length-1;)e[d]!==0&&(c=d),d++;return u.slice(i-c,i+1)}return u.slice(i-t.length,i+1)}}static forBufferedMat(u=new Array(100).fill(1),t=[10,10],e=(n,s,i,c)=>n+i+c){let n=[],s=0,i=(d=0,p=d+1)=>{let y=new Array(u.length);for(let v=0;v<t[d];v++)n[d]=v,t[p]?i(p):(y[s]=e(u[s],s,...n),s++);return y},c=(d,p=d+1)=>{let y=new Array(u.length);for(let v=0;v<t[d];v++)if(n[d]=v,t[p])i(p);else for(let m=0;m<t.length;m++)y[s]=e[m](u[s],s,...n),s++;return y};if(typeof e=="function")return i();if(Array.isArray(e))return c()}static mapBufferedMat(u=new Array(100).fill(1),t=[10,10],e=(n,s,i,c)=>(console.log(`value:${n}, idx:${s}, x:${i},y:${c}`),n+i+c)){let n=new Array(t.length).fill(0),s=(d,p=0)=>{if(d[p]>=t[p]){if(d[p]=0,p++,p===t.length)return;s(d,p)}else d[p]++},i=new Array(u.length),c=0;if(typeof e=="function")for(;c<u.length;)i[c]=e(u[c],c,...n),c+=t.length,s(n);else if(Array.isArray(e))for(;c<u.length;)e.forEach(d=>{i[c]=d(u[c],c,...n),c++,s(n)});return i}static combinations(u=["a","b","c"],t=3){var e=[];return t<=0?e.push([]):Le.combinations(u,t-1).forEach(function(n){u.forEach(function(s){e.push([s].concat(n))})}),e}static generateCoordinateSpace(u=[10,10,10],t=[-10,-10,-10],e=[1,1,1],n=void 0){for(let d=0;d<u.length;d++)if(t[d]>u[d]){let p=u[d];u[d]=t[d],t[d]=p}let s=[],i=[...u],c=i.length-1;for(s.push([...i]);i[0]>=t[0];){let d=y=>{if(i[y]<=t[y]){if(y===0||(i[y]=u[y],y--,y<0))return;typeof e[y]=="function"?i[y]-=e[y](i[y]):i[y]-=e[y],d(y)}},p=c;typeof e[p]=="function"?i[p]-=e[p](i[p]):i[p]-=e[p],s.push([...i]),d(p),n&&(s[s.length-1]=n(s[s.length-1]))}return s}static calcVectorField(u=[[0,0],[0,1],[1,0],[1,1]],t=(e,n)=>[e*10,n*10]){return u.map(e=>t(...e))}static transpose(u){return u[0].map((t,e)=>u.map(n=>n[e]))}static matmul(u,t){for(var e=u.length,n=u[0].length,s=t.length,i=t[0].length,c=new Array(e),d=0;d<e;++d){c[d]=new Array(i);for(var p=0;p<i;++p){c[d][p]=0;for(var y=0;y<n;++y)c[d][p]+=u[d][y]*t[y][p]}}return c}static matscale(u,t){let e=[];for(var n=0;n<u.length;n++){e[n]=[];for(let s=0;s<u[0].length;s++)e[n][s]=u[n][s]*t}return e}static matadd(u,t){let e=[];for(let s=0;s<u.length;s++){e[s]=[];for(var n=0;n<u[0].length;n++)e[s][n]=u[s][n]+t[s][n]}return e}static matsub(u,t){let e=[];for(let s=0;s<u.length;s++){e[s]=[];for(var n=0;n<u[0].length;n++)e[s][n]=u[s][n]-t[s][n]}return e}static histogram(u=[],t=1,e=void 0){let n=[...u];n.sort(function(p,y){return p-y});let s=Math.min(...n);if(typeof e=="number"){let p=Math.max(...n);t=Math.abs((p-s)/(e-1))}let i=s,c=[],d=[];for(let p=0;p<n.length;p++){let y=t*i;if(n[p]>s+y){i++,y+=t;let m=s+y+y*.5;c.push(m),d.push(0)}d[d.length-1]++}return[c,d]}static normalDistribution(u=[],t=!0,e=1e-4){let n=this.mean(u),s=this.variance(u),i=u.length,c=[],d=1/(this.TWO_PI*s),p=1/s,y=0;for(let v=0;v<i;v++){let m=Math.exp(-.5*Math.pow((u[v]-n)*p,2))*d;m<e&&(m=0),c.push(m),y+=m}if(t){let v=1/y;c=c.map(m=>m*v)}return c}static expectedValue(u=[],t=this.normalDistribution(u)){return u.reduce((e,n,s)=>e+n*t[s])}static originMoment(u=[],t=this.normalDistribution(u),e=1){return u.reduce((n,s,i)=>n+Math.pow(s,e)*t[i])}static centralMoment(u=[],t=this.normalDistribution(u),e=1){let n=this.mean(u);return u.reduce((s,i,c)=>s+Math.pow(i-n,e)*t[c]/u.length)}static linearDiscriminantAnalysis(u=[],t=[]){let e=this.mean(u),n=this.mean(t),s=this.cov1d(u,t),i=this.normalDistribution(u),c=[];for(let d=0;d<u.length;d++)c.push(x[d]*s*n-.5*e*s*n+Math.log10(i[d]));return c}static conv1D(u=[],t=[1/3,1/3,1/3],e=Math.floor(t.length*.5)){let n=[],s=1/t.length;if(e>0){let d=new Array(e).fill(0);u=[...d,...u,...d]}let i=Math.floor(t.length*.5),c=u.length-t.length+i;for(let d=i;d<c;d++){let p=0;for(let y=0;y<t.length;y++)p+=u[d-i]*t[y];n.push(p*s)}return n}static conv2D(u=[[],[],[]],t=[[],[],[]],e=0){let n=new Array(u.length-Math.ceil(t.length*.5)).fill([]),s,i=Le.transpose(i);if(e>0){let o=new Array(e).fill(0);s=Le.transpose(u);for(let b=0;b<s.length;b++)s[b]=[...o,...s[b],...o];u=Le.transpose(s);for(let b=0;b<u.length;b++)u[b]=[...o,...u[b],...o]}let c=Math.floor(t[0].length*.5),d=Math.floor(i[0].length*.5),p=u[0].length-t[0].length+c,y=s[0].length-i[0].length+d,v=1/(t[0].length*i[0].length),m=p*y,l=c,h,a=d;for(;l<m;){let o=0;h=l%u[0].length,h===0&&a++;for(let b=0;b<t[0].length;b++){for(let w=0;w<i[0].length;b++)o+=u[a-d+w][h-c+b]*t[w][b];n[a].push(o*v)}l++}return n}static cov2d(u){var t=this.transpose(u),e=[],n=[],s=[];u.forEach((a,o)=>{n.push(this.mean(a))}),t.forEach((a,o)=>{s.push(this.mean(a))}),u.forEach((a,o)=>{e.push([]);for(var b=0;b<a.length;b++)e[o].push((u[o][b]-n[o])*(u[o][b]-s[b])/(a.length-1))});for(var i=this.transpose(e),c=e.length,d=e[0].length,p=i.length,y=i[0].length,v=new Array(c),m=0;m<c;++m){v[m]=new Array(y);for(var l=0;l<y;++l){v[m][l]=0;for(var h=0;h<d;++h)v[m][l]+=e[m][h]*i[h][l]/(u[0].length-1)}}return v}static cov1d(u=[],t=[]){return this.cov2d([u,t])}static cov3d(u=[],t=[],e=[]){return[[this.cov1d(u,u),this.cov1d(u,t),this.cov1d(u,e)],[this.cov1d(t,u),this.cov1d(t,t),this.cov1d(t,e)],[this.cov1d(e,u),this.cov1d(e,t),this.cov1d(e,e)]]}static covNd(u=[]){let t=[];u.forEach((e,n)=>{t.push([]),u.forEach((s,i)=>{t[n].push(this.cov1d(e,s))})})}static eigens2x2(u=[[1,2],[3,4]]){let t=u[0][0]*u[1][1]-u[0][1]*u[1][0],e=(u[0][0]+u[1][1])*.5,n=Math.sqrt(e*e-t),s=e+n,i=e-n;return[s,i]}static eigenvectors2x2(u=[[1,2],[3,4]],t=[1,2]){let e=[-u[0][1],u[0][0]-t[0]];e[0]===0&&e[1]===0&&(e[0]=u[1][1]-t[0],e[1]=-u[1][0]);let n=[-u[0][1],u[0][0]-t[1]];return n[0]===0&&n[1]===0&&(n[0]=u[1][1]-t[1],n[1]=-u[1][0]),[e,n]}static fastpca2d(u,t){let e=this.cov1d(u,t),n=this.eigens2x2(e);n[1]>n[0]&&n.reverse();let s=this.eigenvectors2x2(e,n);return console.log(n,s),[n,s]}static crosscorrelation(u,t){var e=[...t,...Array(t.length).fill(0)],n=this.mean(u),s=this.mean(t),i=u.reduce((m,l)=>m+=Math.pow(l-n,2));i=Math.sqrt(i);var c=t.reduce((m,l)=>m+=Math.pow(l-n,2));c=Math.sqrt(c);for(var d=1/(i*c),p=new Array(u.length).fill(0),y=0;y<u.length;y++){var v=u.reduce((m,l,h)=>m+=(l-n)*(e[y+h]-s));p[y]=v*d}return p}static autocorrelation(u){var t=[...u,...Array(u.length).fill(0)],e=this.mean(u),n=u.reduce((p,y)=>p+=Math.pow(y-e,2));n=Math.sqrt(n);for(var s=1/(n*n),i=new Array(u.length).fill(0),c=0;c<u.length;c++){var d=u.reduce((p,y,v)=>p+=(y-e)*(t[c+v]-e));i[c]=d*s}return i}static autocorrelation2dNormalized(u){let t=[];for(let e=0;e<u.length;e++){t.push([]);for(let n=0;n<u[e].length;n++){let s=0,i=0;for(let c=0;c<u.length;c++)for(let d=0;d<u[c].length;d++)s+=u[e][n]*u[u.length-1-c][u[e].length-1-d],i+=u[e][n]*u[u.length-1][u[e].length-1];t[e][n]=s/i-1}}return t}static crosscorrelation2d(u,t){let e=[];for(let n=0;n<u.length;n++){e.push([]);for(let s=0;s<u[n].length;s++){let i=0;for(let c=0;c<t.length;c++)for(let d=0;d<t[c].length;d++)i+=u[n][s]*t[t.length-1-c][t[n].length-1-d];e[n][s]=i}}return e}static crosscorrelation2dNormalized(u,t){let e=[];for(let n=0;n<u.length;n++){e.push([]);for(let s=0;s<u[n].length;s++){let i=0,c=0;for(let d=0;d<t.length;d++)for(let p=0;p<t[d].length;p++)i+=u[n][s]*t[mat2d.length-1-d][t[n].length-1-p],c+=u[n][s]*t[t.length-1][t[n].length-1];e[n][s]=i/c-1}}return e}static correlograms(u=[[],[]]){var t=[];return u.forEach((e,n)=>{u.forEach((s,i)=>{i>=n&&t.push(Le.crosscorrelation(e,s))})}),t}static dft(u=[]){for(var t=6.283185307179586,e=[],n=[],s=[],i=0;i<u.length;i++){e.push(0),n.push(0);for(var c=0;c<u.length;c++){var d=t*i*c/u.length;e[i]=e[i]+u[c]*Math.cos(d),n[i]=n[i]-u[c]*Math.sin(d)}s.push(Math.sqrt(e[i]*e[i]+n[i]*n[i]))}function p(m){return[...m.slice(Math.ceil(m.length*.5),m.length),...m.slice(0,Math.ceil(m.length*.5))]}s=p(s);let y=s.length*.5,v=s.map((m,l)=>l-y);return{real:e,imag:n,freqs:v,mags:s}}static sma(u=[],t){for(var e=[],n=0;n<u.length;n++)if(n==0)e.push(u[0]);else if(n<t){var s=u.slice(0,n+1);e.push(s.reduce((i,c)=>c+=i)/(n+1))}else{var s=u.slice(n-t,n);e.push(s.reduce((c,d)=>d+=c)/t)}return e}static sum(u=[]){if(u.length>0){var t=u.reduce((e,n)=>n+=e);return t}else return 0}static reduceArrByFactor(u,t=2){return u.filter((n,s)=>s%t===0)}static makeArr(u,t,e){for(var n=[],s=(t-u)/(e-1),i=0;i<e;i++)n.push(u+s*i);return n}static autoscale(u,t=1,e=0,n=!1){if(u?.length===0)return u;let s=Math.max(...u),i=Math.min(...u),c=1/t,d;if(n){let p=Math.max(Math.abs(i),Math.abs(s));return d=c/p,u.map(y=>y*d+(c*(e+1)*2-1-c))}else return d=c/(s-i),u.map(p=>2*((p-i)*d-1/(2*t))+(c*(e+1)*2-1-c))}static absmax(u){return Math.max(Math.abs(Math.min(...u)),Math.max(...u))}static downsample(u,t,e=1){if(u.length>t){let n=new Array(t),s=u.length/t,i=u.length-1,c=0,d=0;for(let p=s;p<u.length;p+=s){let y=Math.round(p);y>i&&(y=i);for(let v=c;v<y;v++)n[d]+=u[v];n[d]/=(y-c)*e,d++,c=y}return n}else return u}static interpolateArray(u,t,e=1){var n=function(m,l,h){return(m+(l-m)*h)*e},s=new Array,i=new Number((u.length-1)/(t-1));s[0]=u[0];for(var c=1;c<t-1;c++){var d=c*i,p=new Number(Math.floor(d)).toFixed(),y=new Number(Math.ceil(d)).toFixed(),v=d-p;s[c]=n(u[p],u[y],v)}return s[t-1]=u[u.length-1],s}static isExtrema(u,t="peak"){let e=[...u];if(e.length%2===0&&e.pop(),u.length>1){let n=!0;for(let s=0;s<e.length;s++){let i=e[s];if(t==="peak"){if(s<Math.floor(e.length*.5)&&i>=e[Math.floor(e.length*.5)]){n=!1;break}else if(s>Math.floor(e.length*.5)&&i>=e[Math.floor(e.length*.5)]){n=!1;break}}else if(t==="valley"){if(s<Math.floor(e.length*.5)&&i<=e[Math.floor(e.length*.5)]){n=!1;break}else if(s>Math.floor(e.length*.5)&&i<=e[Math.floor(e.length*.5)]){n=!1;break}}else if(s<Math.floor(e.length*.5)&&i<=e[Math.floor(e.length*.5)]){n=!1;break}else if(s>Math.floor(e.length*.5)&&i<=e[Math.floor(e.length*.5)]){n=!1;break}}if(t!=="peak"&&t!=="valley"&&n===!1){n=!0;for(let s=0;s<e.length;s++){let i=e[s];if(s<Math.floor(e.length*.5)&&i>=e[Math.floor(e.length*.5)]){n=!1;break}else if(s>Math.floor(e.length*.5)&&i>=e[Math.floor(e.length*.5)]){n=!1;break}}}return n}else return}static isCriticalPoint(u,t="peak"){let e=[...u];if(e.length%2===0&&e.pop(),u.length>1){let n=!0;for(let s=0;s<e.length;s++){let i=e[s];if(t==="peak"){if(s<e.length*.5&&i<=0){n=!1;break}else if(s>e.length*.5&&i>0){n=!1;break}}else if(t==="valley"){if(s<e.length*.5&&i>=0){n=!1;break}else if(s>e.length*.5&&i<0){n=!1;break}}else if(s<e.length*.5&&i>=0){n=!1;break}else if(s>e.length*.5&&i<0){n=!1;break}}if(t!=="peak"&&t!=="valley"&&n===!1){n=!0;for(let s=0;s<e.length;s++){let i=e[s];if(s<e.length*.5&&i<=0){n=!1;break}else if(s>e.length*.5&&i>0){n=!1;break}}}return n}else return}static getPeakThreshold(u,t,e){let n,s=u.filter((i,c)=>{if(t.indexOf(c)>-1)return!0});return e===0?n=this.mean(s):n=(e+this.mean(s))*.5,n}static column(u,t){let e=new Array(u.length).fill(0).map(()=>new Array(1).fill(0));for(let n=0;n<u.length;n++)e[n][0]=u[n][t];return e}static flatten_vector(u){let t=[];for(let e=0;e<u.length;e++)t[e]=u[e][0];return t}static squared_difference(u,t){let e=0;for(let n=0;n<u.length;n++)e=e+Math.pow(u[n]-t[n],2);return e}static shift_deflate(u,t,e){let n=Math.sqrt(this.matmul(this.transpose(e),e)),s=this.matscale(e,1/n),i=this.matscale(this.matmul(s,this.transpose(s)),t);return this.matsub(u,i)}static eigenvalue_of_vector(u,t){return ev=this.matmul(this.matmul(this.transpose(t),u),t),ev}static power_iteration(u,t=1e-5,e=1e3){let n=u.length,s=new Array(n).fill(0).map(()=>new Array(1).fill(Math.sqrt(n))),i=this.eigenvalue_of_vector(u,s),c=1,d=0;for(;c>t&&d<e;){let p=JSON.parse(JSON.stringify(i)),y=this.matmul(u,s);s=this.normalize(y),i=this.eigenvalue_of_vector(u,s),c=Math.abs(i-p),d++}return[i,s]}static eigens(u,t=1e-4,e=1e3){let n=[],s=[];for(let i=0;i<u.length;i++){let c=this.power_iteration(u,t,e),d=c[0],p=c[1];n[i]=d,s[i]=this.flatten_vector(p),u=this.shift_deflate(u,d,p)}return[n,s]}static pca(u,t=1e-5){let e=u.length,n=new Array(e),s=new Array(e),i=this.transpose(u);n[0]=this.column(u,0);let c=1,d=0;for(;espilon>t;){d++,s[0]=this.matmul(i,n[0]);let y=this.matmul(this.transpose(n[0]),n[0]);s[0]=this.matscale(s[0],1/y);let v=Math.sqrt(this.matmul(this.transpose(s[0]),s[0]));s[0]=this.matscale(s[0],1/v);let m=this.matmul(u,s[0]),l=this.matmul(this.transpose(s[0]),s[0]);m=this.matscale(m,1/l),c=this.squared_difference(n[0],m),n[0]=JSON.parse(JSON.stringify(m))}return this.matmul(this.transpose(n[0]),n[0])}static p300(u=[],t=[],e=[],n=256){let s=Math.floor(n/10),i=this.sma(t,s),c=this.peakDetect(i,"peak",s),d=this.mean(i),p=this.std(i,d),y=0,v=[];return c.length>0&&u.forEach((m,l)=>{for(;e[c[y]]<m+200&&(y++,!!c[y]););let h=0,a=[];for(;e[c[y+h]]<m+600&&(a.push(y+h),h++,!!c[y+h]););if(a.length>1){let o=[];a.forEach(I=>{o.push(i[c[I]])});let b=Math.max(...o),w=a[o.indexOf(b)];v.push({event_timestamp:m,event_index:l,peak_timestamp:e[[c[w]]],signal_index:[c[w]],signal_amplitude:t[[c[w]]],zscore:(i[c[w]]-d)/p})}else a.length===1&&v.push({event_timestamp:m,event_index:l,peak_timestamp:e[c[a[0]]],signal_index:c[a[0]],signal_amplitude:t[[c[a[0]]]],zscore:(i[c[a[0]]]-d)/p})}),v}},he=Le;pe(he,"TWO_PI",Math.PI*2);pe(he,"C",299792458);pe(he,"G",66743e-15);pe(he,"h",662607015e-42);pe(he,"R",8314.32);pe(he,"Ra",287);pe(he,"H",69.3);pe(he,"kbar",1054571817e-43);pe(he,"kB",1380649e-29);pe(he,"ke",89875517923e-1);pe(he,"me",91093837015e-41);pe(he,"mp",167262192369e-38);pe(he,"mn",167492749804e-38);pe(he,"P0",101325);pe(he,"T0",288.15);pe(he,"p0",1.225);pe(he,"Na",60220978e16);pe(he,"y",1.405);pe(he,"M0",28.96643);pe(he,"g0",9.80665);pe(he,"Re",6378100);pe(he,"B",1458e-9);pe(he,"S",110.4);pe(he,"Sigma",365e-12);pe(he,"imgkernels",{edgeDetection:[[-1,-1,-1],[-1,8,-1],[-1,-1,-1]],boxBlur:[[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]],sobelLeft:[[1,0,-1],[2,0,-2],[1,0,-1]],sobelRight:[[-1,0,1],[-2,0,2],[-1,0,1]],sobelTop:[[1,2,1],[0,0,0],[-1,-2,-1]],sobelBottom:[[-1,2,1],[0,0,0],[1,2,1]],identity:[[0,0,0],[0,1,0],[0,0,0]],gaussian3x3:[[1,2,1],[2,4,2],[1,2,1]],guassian7x7:[[0,0,0,5,0,0,0],[0,5,18,32,18,5,0],[0,18,64,100,64,18,0],[5,32,100,100,100,32,5],[0,18,64,100,64,18,0],[0,5,18,32,18,5,0],[0,0,0,5,0,0,0]],emboss:[[-2,-1,0],[-1,1,1],[0,1,2]],sharpen:[[0,-1,0],[-1,5,-1],[0,-1,0]]});pe(he,"integral",(u=n=>n,t=[],e=.01)=>{let n=0;for(let s=t[0];s<t[1];s+=e)n+=u(s)*e;return n});pe(he,"dintegral",(u=(s,i)=>s+i,t=[[],[]],e=.01,n=e)=>{let s=0;for(let i=t[0][0]+e;i<t[0][1];i+=e)for(let c=t[1][0]+n;c<t[1][1];c+=n)s+=u(i,c)*e*n;return s});pe(he,"tintegral",(u=(i,c,d)=>i+c+d,t=[[],[],[]],e=.01,n=e,s=e)=>{let i=0;for(let c=t[0][0]+e;c<t[0][1];c+=e)for(let d=t[1][0]+n;d<t[1][1];d+=n)for(let p=t[2][0]+s;p<t[2][1];p+=s)i+=u(c,d,p)*e*n*s;return i});pe(he,"pintegral",(u=n=>n,t=[],e=.01)=>{let n=0,s,i;for(let c=t[0];c<t[1];c+=e)s=i,i=u(c),s&&(n+=Le.distance([0,s],[e,i]));return n});pe(he,"meshgrid",Le.generateCoordinateSpace);pe(he,"autocorrelation2d",u=>{let t=[];for(let e=0;e<u.length;e++){t.push([]);for(let n=0;n<u[e].length;n++){let s=0;for(let i=0;i<u.length;i++)for(let c=0;c<u[i].length;c++)s+=u[e][n]*u[u.length-1-i][u[e].length-1-c];t[e][n]=s}}return t});pe(he,"upsample",Le.interpolateArray);pe(he,"peakDetect",(u,t="peak",e=49)=>{let n=Math.floor(e*.5),s=[];for(let i=0;i<u.length-e;i++)Le.isExtrema(u.slice(i,i+e),t)&&s.push(i+n-1);return s});Object.assign(Math,he);var Me=zt(Bn()),Rt=class extends we{constructor(e){super(e);this.name="worker";this.workers={};this.threadRot=0;this.addWorker=e=>{let n;e.url?n=new Me.default(e.url):n=new Me.default(Me.default),e._id||(e._id=`worker${Math.floor(Math.random()*1e15)}`);let s=(c,d)=>this.transmit(c,n,d),i=(c,d,p,y)=>new Promise((v,m)=>{let l=Math.random(),h={route:"runRequest",args:[c,e._id,l]};p&&(h.origin=p),y&&(h.method=y);let a=o=>{typeof o.data=="object"&&o.data.callbackId===l&&(n.removeEventListener("message",a),v(o.data))};n.addEventListener("message",a),this.transmit(h,n,d)});return e.onmessage||(e.onmessage=c=>{let d=this.receive(c.data);this.setState({[e._id]:d})}),e.onerror||(e.onerror=c=>{console.error(c.data)}),n.onmessage=e.onmessage,n.onerror=e.onerror,this.workers[e._id]={worker:n,send:s,request:i,...e},this.workers[e._id]};this.toObjectURL=e=>{let n=new Blob([e],{type:"text/javascript"});return URL.createObjectURL(n)};this.transmit=(e,n,s)=>{if(n instanceof Me.default||n instanceof MessagePort)n.postMessage(e,s);else if(typeof n=="string")this.workers[n]&&(this.workers[n].port?this.workers[n].port.postMessage(e,s):this.workers[n].worker&&this.workers[n].worker.postMessage(e,s));else{let i=Object.keys(this.workers);this.workers[i[this.threadRot]].worker.postMessage(e,s),this.threadRot++,this.threadRot===i.length&&(this.threadRot=0)}return e};this.terminate=e=>{if(typeof e=="string"){let n=this.workers[e];n&&delete this.workers[e],e=n.worker}return e instanceof Me.default?(e.terminate(),!0):e instanceof MessagePort?(e.close(),!0):!1};this.establishMessageChannel=(e,n)=>{if(typeof e=="string"&&this.workers[e]&&(e=this.workers[e].worker),typeof n=="string"&&this.workers[n]&&(n=this.workers[n].worker),e instanceof Me.default){let s=new MessageChannel,i=s.port1,c=s.port2,d=`port${Math.floor(Math.random()*1e15)}`;return e.postMessage({route:"recursivelyAssign",args:{workers:{_id:d,port:i}}},[i]),n instanceof Me.default&&n.postMessage({route:"recursivelyAssign",args:{workers:{_id:d,port:c}}},[c]),s}return!1};this.request=(e,n,s,i,c)=>new Promise((d,p)=>{let y=Math.random(),v={route:"runRequest",args:e,callbackId:y};i&&(v.origin=i),c&&(v.method=c);let m=l=>{typeof l.data=="object"&&l.data.callbackId===y&&(n.removeEventListener("message",m),d(l.data))};n.addEventListener("message",m),this.transmit(v,n,s)});this.runRequest=(e,n,s)=>{let i=this.receive(e);return typeof n=="string"&&this.workers[n]&&(this.workers[n].port?n=this.workers[n].port:n=this.workers[n].worker),i instanceof Promise?i.then(c=>{n instanceof Me.default||n instanceof MessagePort?n.postMessage({args:i,callbackId:s}):typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&globalThis.postMessage({args:i,callbackId:s})}):n instanceof Me.default||n instanceof MessagePort?n.postMessage({args:i,callbackId:s}):typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&globalThis.postMessage({args:i,callbackId:s}),i};this.routes={addWorker:this.addWorker,toObjectURL:this.toObjectURL,request:this.request,runRequest:this.runRequest,establishMessageChannel:this.establishMessageChannel}}};var et=Zt(["ctrlKey","metaKey","shiftKey","button","pointerType","clientX","clientY","pageX","pageY"]),Kr=Zt(["deltaX","deltaY"]),Ur=Zt(["ctrlKey","metaKey","shiftKey","keyCode"]);function jr(u,t){u.preventDefault(),Kr(u,t)}function Wr(u){u.preventDefault()}function Hr(u,t,e){for(let n of t)e[n]=u[n]}function Zt(u){return function(e,n){let s={type:e.type};Hr(e,u,s),n(s)}}function qt(u,t){let e=[],n={type:u.type,touches:e};for(let s=0;s<u.touches.length;++s){let i=u.touches[s];e.push({pageX:i.pageX,pageY:i.pageY})}t(n)}var qr={37:!0,38:!0,39:!0,40:!0};function Xr(u,t){let{keyCode:e}=u;qr[e]&&(u.preventDefault(),Ur(u,t))}function Yr(u,t){let e={contextmenu:Wr,mousedown:et,mousemove:et,mouseup:et,pointerdown:et,pointermove:et,pointerup:et,touchstart:qt,touchmove:qt,touchend:qt,wheel:jr,keydown:Xr},n="proxy"+Math.floor(Math.random()*1e4),s=d=>{t.postMessage({route:"proxyHandler",args:[d,n]})};t.postMessage({route:"makeProxy",args:n});let i=Object.entries(e);for(let[d,p]of i)u.addEventListener(d,function(y){p(y,s)});let c=()=>{let d=u.getBoundingClientRect();s({type:"size",left:d.left,top:d.top,width:u.clientWidth,height:u.clientHeight})};return c(),globalThis.addEventListener("resize",c),n}var Xt=class{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});let n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;let n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;let s=this._listeners[t];if(s!==void 0){let i=s.indexOf(e);i!==-1&&s.splice(i,1)}}dispatchEvent(t){if(this._listeners===void 0)return;let n=this._listeners[t.type];if(n!==void 0){t.target=this;let s=n.slice(0);for(let i=0,c=s.length;i<c;i++)s[i].call(this,t);t.target=null}}},Yt=class extends Xt{constructor(){super();this.style={}}get clientWidth(){return this.width}get clientHeight(){return this.height}setPointerCapture(){}releasePointerCapture(){}getBoundingClientRect(){return{left:this.left,top:this.top,width:this.width,height:this.height,right:this.left+this.width,bottom:this.top+this.height}}handleEvent(e){if(e.type==="size"){this.left=e.left,this.top=e.top,this.width=e.width,this.height=e.height;return}e.preventDefault=function(){},e.stopPropagation=function(){},this.dispatchEvent(e)}focus(){}},Jt=class{constructor(){this.id="proxy"+Math.floor(Math.random()*1e4),this.targets={},this.handleEvent=this.handleEvent.bind(this)}makeProxy(t){t||(t=`proxyReceiver${Math.floor(Math.random()*1e12)}`);let e=new Yt;this.targets[t]=e}getProxy(t){return this.targets[t]}handleEvent(t,e){this.targets[e].handleEvent(t)}},zn={initProxyElement:Yr,makeProxy:(u,t,e)=>(u.graph.PROXYELEMENTS||(u.graph.PROXYELEMENTS=new Jt),u.graph.PROXYELEMENTS.makeProxy(e),e),handleProxyEvent:(u,t,e,n)=>(u.graph.PROXYELEMENTS.handleEvent(e,n),n)};var Gn={transferCanvas:(u,t,e,n)=>{let s=`canvas${Math.floor(Math.random()*1e15)}`,i=u.transferControlToOffscreen(),c={route:"receiveCanvas",args:{offscreen:i,_id:s,context:e}};return n&&(typeof n=="function"&&(n=n.toString()),c.animation=n),t.postMessage(c,[i]),s},receiveCanvas:(u,t,e)=>(u.graph.CANVASES||(u.graph.CANVASES={}),u.graph.CANVASES[e._id]={_id:e._id,canvas:e.offscreen,context:e.offscreen.getContext(e.context),animation:e.animation,animating:!1},typeof u.graph.CANVASES[e._id].animation=="string"&&(u.graph.CANVASES[e._id].animation=He(u.graph.CANVASES[e._id].animation)),typeof u.graph.CANVASES[e._id].animation=="function"&&((s,i)=>{u.graph.CANVASES[e._id].animating&&requestAnimationFrame(()=>{u.graph.CANVASES[e._id].animation(s,i)})})(u.graph.CANVASES[e._id].canvas,u.graph.CANVASES[e._id].context),u.graph.CANVASES[e._id]),setDraw:(u,t,e,n)=>{let s=u.graph.CANVASES[e];return s?(typeof n=="string"&&(n=He(n)),typeof n=="function"&&(s.animation=n),!0):!1},animate:(u,t,e,n)=>{let s=u.graph.CANVASES[e];return s&&n&&(typeof n=="string"&&(n=He(n)),typeof n=="function"&&(s.animation=n)),typeof s?.animation=="function"&&!s?.animating?(((c,d)=>{s.animating&&requestAnimationFrame(()=>{s.animation(c,d)})})(s.canvas,u.graph.CANVASES[s._id].context),!0):!1},stopAnim:(u,t,e)=>{let n=u.graph.CANVASES[e];return n&&(n.animating=!1),!0}};var Jr=URL.createObjectURL(new Blob([String(`(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // ../GraphServiceRouter/node_modules/web-worker/cjs/browser.js
  var require_browser = __commonJS({
    "../GraphServiceRouter/node_modules/web-worker/cjs/browser.js"(exports, module) {
      module.exports = Worker;
    }
  });

  // ../GraphServiceRouter/Graph.ts
  var ARGUMENT_NAMES = /([^,]*)/g;
  function getFnParamInfo(fn) {
    var fstr = fn.toString();
    const openPar = fstr.indexOf("(");
    const closePar = fstr.indexOf(")");
    const getFirstBracket = (str, offset = 0) => {
      const fb = offset + str.indexOf("{");
      if (fb < closePar && fb > openPar) {
        return getFirstBracket(str.slice(fb), offset + fb);
      } else
        return fb;
    };
    const firstBracket = getFirstBracket(fstr);
    let innerMatch;
    if (firstBracket === -1 || closePar < firstBracket)
      innerMatch = fstr.slice(fstr.indexOf("(") + 1, fstr.indexOf(")"));
    else
      innerMatch = fstr.match(/([a-zA-Z]\\w*|\\([a-zA-Z]\\w*(,\\s*[a-zA-Z]\\w*)*\\)) =>/)?.[1];
    const matches = innerMatch.match(ARGUMENT_NAMES).filter((e) => !!e);
    const info = /* @__PURE__ */ new Map();
    matches.forEach((v) => {
      let [name2, value2] = v.split("=");
      name2 = name2.trim();
      name2 = name2.replace(/\\d+$/, "");
      try {
        if (name2)
          info.set(name2, (0, eval)(\`(\${value2})\`));
      } catch (e) {
        info.set(name2, void 0);
        console.warn(\`Argument \${name2} could be parsed for\`, fn.toString());
      }
    });
    return info;
  }
  function parseFunctionFromText(method = "") {
    let getFunctionBody = (methodString) => {
      return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, "$2$3$4");
    };
    let getFunctionHead = (methodString) => {
      let startindex = methodString.indexOf(")");
      return methodString.slice(0, methodString.indexOf("{", startindex) + 1);
    };
    let newFuncHead = getFunctionHead(method);
    let newFuncBody = getFunctionBody(method);
    let newFunc;
    if (newFuncHead.includes("function ")) {
      let varName = newFuncHead.split("(")[1].split(")")[0];
      newFunc = new Function(varName, newFuncBody);
    } else {
      if (newFuncHead.substring(0, 6) === newFuncBody.substring(0, 6)) {
        let varName = newFuncHead.split("(")[1].split(")")[0];
        newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf("{") + 1, newFuncBody.length - 1));
      } else {
        try {
          newFunc = (0, eval)(newFuncHead + newFuncBody + "}");
        } catch {
        }
      }
    }
    return newFunc;
  }
  var state = {
    pushToState: {},
    data: {},
    triggers: {},
    setState(updateObj) {
      Object.assign(state.data, updateObj);
      for (const prop of Object.getOwnPropertyNames(updateObj)) {
        if (state.triggers[prop])
          state.triggers[prop].forEach((obj) => obj.onchange(state.data[prop]));
      }
      return state.data;
    },
    subscribeTrigger(key, onchange) {
      if (key) {
        if (!state.triggers[key]) {
          state.triggers[key] = [];
        }
        let l = state.triggers[key].length;
        state.triggers[key].push({ idx: l, onchange });
        return state.triggers[key].length - 1;
      } else
        return void 0;
    },
    unsubscribeTrigger(key, sub) {
      let idx = void 0;
      let triggers = state.triggers[key];
      if (triggers) {
        if (!sub)
          delete state.triggers[key];
        else {
          let obj = triggers.find((o) => {
            if (o.idx === sub) {
              return true;
            }
          });
          if (obj)
            triggers.splice(idx, 1);
          return true;
        }
      }
    },
    subscribeTriggerOnce(key, onchange) {
      let sub;
      let changed = (value2) => {
        onchange(value2);
        state.unsubscribeTrigger(key, sub);
      };
      sub = state.subscribeTrigger(key, changed);
    }
  };
  var GraphNode = class {
    constructor(properties = {}, parentNode, graph) {
      this.nodes = /* @__PURE__ */ new Map();
      this.arguments = /* @__PURE__ */ new Map();
      this._initial = {};
      this.state = state;
      this.isLooping = false;
      this.isAnimating = false;
      this.looper = void 0;
      this.animation = void 0;
      this.forward = true;
      this.backward = false;
      this.runSync = false;
      this.firstRun = true;
      this.DEBUGNODE = false;
      this.operator = (self2 = this, origin, ...args) => {
        return args;
      };
      this.runOp = (node = this, origin = this, ...args) => {
        if (node.DEBUGNODE)
          console.time(node.tag);
        let result = node.operator(node, origin, ...args);
        if (result instanceof Promise) {
          result.then((res) => {
            if (res !== void 0)
              this.setState({ [node.tag]: res });
            if (node.DEBUGNODE) {
              console.timeEnd(node.tag);
              if (result !== void 0)
                console.log(\`\${node.tag} result:\`, result);
            }
            ;
            return res;
          });
        } else {
          if (result !== void 0)
            this.setState({ [node.tag]: result });
          if (node.DEBUGNODE) {
            console.timeEnd(node.tag);
            if (result !== void 0)
              console.log(\`\${node.tag} result:\`, result);
          }
          ;
        }
        return result;
      };
      this.setOperator = (operator) => {
        if (typeof operator !== "function")
          return operator;
        let params = getFnParamInfo(operator);
        const keys = params.keys();
        const paramOne = keys.next().value;
        const paramTwo = keys.next().value;
        const restrictedOne = ["self", "node"];
        const restrictedTwo = ["origin", "parent", "graph", "router"];
        let pass = false;
        if (paramOne)
          restrictedOne.forEach((a) => {
            if (paramOne.includes(a))
              pass = true;
          });
        if (paramTwo)
          restrictedTwo.forEach((a) => {
            if (paramTwo.includes(a))
              pass = true;
          });
        if (!pass) {
          let fn = operator;
          operator = (self2, origin, ...args) => {
            return fn(...args);
          };
          if (this.arguments) {
            params.forEach((v, k) => {
              if (!this.arguments.has(k))
                this.arguments.set(k, v);
            });
          }
        }
        this.operator = operator;
        return operator;
      };
      this.run = (...args) => {
        return this._run(this, void 0, ...args);
      };
      this.runAsync = (...args) => {
        return new Promise((res, rej) => {
          res(this._run(this, void 0, ...args));
        });
      };
      this.transformArgs = (args = []) => args;
      this._run = (node = this, origin, ...args) => {
        if (typeof this.transformArgs === "function")
          args = this.transformArgs(args, node);
        if (!(typeof node === "object")) {
          if (typeof node === "string") {
            let fnd = void 0;
            if (this.graph)
              fnd = this.graph.nodes.get(node);
            if (!fnd)
              fnd = this.nodes.get(node);
            node = fnd;
          }
          if (!node)
            return void 0;
        }
        if (node.firstRun) {
          node.firstRun = false;
          if (!(node.children && node.forward || node.parent && node.backward || node.repeat || node.delay || node.frame || node.recursive || node.branch))
            node.runSync = true;
          if (node.animate && !node.isAnimating) {
            node.runAnimation(node.animation, args, node, origin);
          }
          if (node.loop && typeof node.loop === "number" && !node.isLooping) {
            node.runLoop(node.looper, args, node, origin);
          }
          if (node.loop || node.animate)
            return;
        }
        if (node.runSync) {
          let res = node.runOp(node, origin, ...args);
          return res;
        }
        return new Promise(async (resolve) => {
          if (node) {
            let run = (node2, tick = 0, ...input) => {
              return new Promise(async (r) => {
                tick++;
                let res = await node2.runOp(node2, origin, ...input);
                if (node2.repeat) {
                  while (tick < node2.repeat) {
                    if (node2.delay) {
                      setTimeout(async () => {
                        r(await run(node2, tick, ...input));
                      }, node2.delay);
                      break;
                    } else if (node2.frame && window?.requestAnimationFrame) {
                      requestAnimationFrame(async () => {
                        r(await run(node2, tick, ...input));
                      });
                      break;
                    } else
                      res = await node2.runOp(node2, origin, ...input);
                    tick++;
                  }
                  if (tick === node2.repeat) {
                    r(res);
                    return;
                  }
                } else if (node2.recursive) {
                  while (tick < node2.recursive) {
                    if (node2.delay) {
                      setTimeout(async () => {
                        r(await run(node2, tick, ...res));
                      }, node2.delay);
                      break;
                    } else if (node2.frame && window?.requestAnimationFrame) {
                      requestAnimationFrame(async () => {
                        r(await run(node2, tick, ...res));
                      });
                      break;
                    } else
                      res = await node2.runOp(node2, origin, ...res);
                    tick++;
                  }
                  if (tick === node2.recursive) {
                    r(res);
                    return;
                  }
                } else {
                  r(res);
                  return;
                }
              });
            };
            let runnode = async () => {
              let res = await run(node, void 0, ...args);
              if (res !== void 0) {
                if (node.backward && node.parent instanceof GraphNode) {
                  if (Array.isArray(res))
                    await this.runParent(node, ...res);
                  else
                    await this.runParent(node, res);
                }
                if (node.children && node.forward) {
                  if (Array.isArray(res))
                    await this.runChildren(node, ...res);
                  else
                    await this.runChildren(node, res);
                }
                if (node.branch) {
                  this.runBranch(node, res);
                }
              }
              return res;
            };
            if (node.delay) {
              setTimeout(async () => {
                resolve(await runnode());
              }, node.delay);
            } else if (node.frame && window?.requestAnimationFrame) {
              requestAnimationFrame(async () => {
                resolve(await runnode());
              });
            } else {
              resolve(await runnode());
            }
          } else
            resolve(void 0);
        });
      };
      this.runParent = async (node, ...args) => {
        if (node.backward && node.parent) {
          if (typeof node.parent === "string") {
            if (node.graph && node.graph?.get(node.parent)) {
              node.parent = node.graph;
              if (node.parent)
                this.nodes.set(node.parent.tag, node.parent);
            } else
              node.parent = this.nodes.get(node.parent);
          }
          if (node.parent instanceof GraphNode)
            await node.parent._run(node.parent, this, ...args);
        }
      };
      this.runChildren = async (node, ...args) => {
        if (typeof node.children === "object") {
          for (const key in node.children) {
            if (typeof node.children[key] === "string") {
              if (node.graph && node.graph?.get(node.children[key])) {
                node.children[key] = node.graph.get(node.children[key]);
                if (!node.nodes.get(node.children[key].tag))
                  node.nodes.set(node.children[key].tag, node.children[key]);
              }
              if (!node.children[key] && node.nodes.get(node.children[key]))
                node.children[key] = node.nodes.get(node.children[key]);
            } else if (typeof node.children[key] === "undefined" || node.children[key] === true) {
              if (node.graph && node.graph?.get(key)) {
                node.children[key] = node.graph.get(key);
                if (!node.nodes.get(node.children[key].tag))
                  node.nodes.set(node.children[key].tag, node.children[key]);
              }
              if (!node.children[key] && node.nodes.get(key))
                node.children[key] = node.nodes.get(key);
            }
            if (node.children[key]?.runOp)
              await node.children[key]._run(node.children[key], node, ...args);
          }
        }
      };
      this.runBranch = async (node, output) => {
        if (node.branch) {
          let keys = Object.keys(node.branch);
          await Promise.all(keys.map(async (k) => {
            if (typeof node.branch[k].if === "object")
              node.branch[k].if = stringifyFast(node.branch[k].if);
            let pass = false;
            if (typeof output === "object")
              if (stringifyFast(output) === node.branch[k].if)
                pass = true;
              else if (output === node.branch[k].if)
                pass = true;
              else
                pass = true;
            if (pass) {
              if (node.branch[k].then instanceof GraphNode) {
                if (Array.isArray(output))
                  await node.branch[k].then._run(node.branch[k].then, node, ...output);
                else
                  await node.branch[k].then._run(node.branch[k].then, node, ...output);
              } else if (typeof node.branch[k].then === "function") {
                if (Array.isArray(output))
                  await node.branch[k].then(...output);
                else
                  await node.branch[k].then(output);
              } else if (typeof node.branch[k].then === "string") {
                if (node.graph)
                  node.branch[k].then = node.graph.nodes.get(node.branch[k].then);
                else
                  node.branch[k].then = node.nodes.get(node.branch[k].then);
                if (node.branch[k].then instanceof GraphNode) {
                  if (Array.isArray(output))
                    await node.branch[k].then._run(node.branch[k].then, node, ...output);
                  else
                    await node.branch[k].then._run(node.branch[k].then, node, ...output);
                }
              }
            }
            return pass;
          }));
        }
      };
      this.runAnimation = (animation = this.animation, args = [], node = this, origin) => {
        this.animation = animation;
        if (!animation)
          this.animation = this.operator;
        if (node.animate && !node.isAnimating && "requestAnimationFrame" in window) {
          node.isAnimating = true;
          let anim = async () => {
            if (node.isAnimating) {
              if (node.DEBUGNODE)
                console.time(node.tag);
              let result = this.animation(node, origin, ...args);
              if (result instanceof Promise) {
                result = await result;
              }
              if (node.DEBUGNODE) {
                console.timeEnd(node.tag);
                if (result !== void 0)
                  console.log(\`\${node.tag} result:\`, result);
              }
              ;
              if (result !== void 0) {
                if (this.tag)
                  this.setState({ [this.tag]: result });
                if (node.backward && node.parent?._run) {
                  if (Array.isArray(result))
                    await this.runParent(node, ...result);
                  else
                    await this.runParent(node, result);
                }
                if (node.children && node.forward) {
                  if (Array.isArray(result))
                    await this.runChildren(node, ...result);
                  else
                    await this.runChildren(node, result);
                }
                if (node.branch) {
                  this.runBranch(node, result);
                }
                this.setState({ [node.tag]: result });
              }
              requestAnimationFrame(anim);
            }
          };
          requestAnimationFrame(anim);
        }
      };
      this.runLoop = (loop = this.looper, args = [], node = this, origin, timeout = node.loop) => {
        node.looper = loop;
        if (!loop)
          node.looper = node.operator;
        if (typeof timeout === "number" && !node.isLooping) {
          node.isLooping = true;
          let looping = async () => {
            if (node.isLooping) {
              if (node.DEBUGNODE)
                console.time(node.tag);
              let result = node.looper(node, origin, ...args);
              if (result instanceof Promise) {
                result = await result;
              }
              if (node.DEBUGNODE) {
                console.timeEnd(node.tag);
                if (result !== void 0)
                  console.log(\`\${node.tag} result:\`, result);
              }
              ;
              if (result !== void 0) {
                if (node.tag)
                  node.setState({ [node.tag]: result });
                if (node.backward && node.parent?._run) {
                  if (Array.isArray(result))
                    await this.runParent(node, ...result);
                  else
                    await this.runParent(node, result);
                }
                if (node.children && node.forward) {
                  if (Array.isArray(result))
                    await this.runChildren(node, ...result);
                  else
                    await this.runChildren(node, result);
                }
                if (node.branch) {
                  this.runBranch(node, result);
                }
                node.setState({ [node.tag]: result });
              }
              setTimeout(async () => {
                await looping();
              }, timeout);
            }
          };
          looping();
        }
      };
      this.setParent = (parent) => {
        this.parent = parent;
        if (this.backward)
          this.runSync = false;
      };
      this.setChildren = (children) => {
        this.children = children;
        if (this.forward)
          this.runSync = false;
      };
      this.add = (node = {}) => {
        if (typeof node === "function")
          node = { operator: node };
        if (!(node instanceof GraphNode))
          node = new GraphNode(node, this, this.graph);
        this.nodes.set(node.tag, node);
        if (this.graph) {
          this.graph.nodes.set(node.tag, node);
          this.graph.nNodes++;
        }
        return node;
      };
      this.remove = (node) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode) {
          this.nodes.delete(node.tag);
          if (this.graph) {
            this.graph.nodes.delete(node.tag);
            this.graph.nNodes--;
          }
          this.nodes.forEach((n) => {
            if (n.nodes.get(node.tag))
              n.nodes.delete(node.tag);
          });
        }
      };
      this.append = (node, parentNode = this) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode) {
          parentNode.addChildren(node);
          if (node.forward)
            node.runSync = false;
        }
      };
      this.subscribe = (callback, tag = this.tag) => {
        if (callback instanceof GraphNode) {
          return this.subscribeNode(callback);
        } else
          return this.state.subscribeTrigger(tag, callback);
      };
      this.unsubscribe = (sub, tag = this.tag) => {
        this.state.unsubscribeTrigger(tag, sub);
      };
      this.addChildren = (children) => {
        if (!this.children)
          this.children = {};
        if (typeof children === "object")
          Object.assign(this.children, children);
        this.convertChildrenToNodes();
        if (this.forward)
          this.runSync = false;
      };
      this.callParent = (...args) => {
        const origin = this;
        if (typeof this.parent === "string") {
          if (this.graph && this.graph?.get(this.parent)) {
            this.parent = this.graph;
            if (this.parent)
              this.nodes.set(this.parent.tag, this.parent);
          } else
            this.parent = this.nodes.get(this.parent);
        }
        if (typeof this.parent?.operator === "function")
          return this.parent.runOp(this.parent, origin, ...args);
      };
      this.callChildren = (idx, ...args) => {
        const origin = this;
        let result;
        if (typeof this.children === "object") {
          for (const key in this.children) {
            if (this.children[key]?.runOp)
              this.children[key].runOp(this.children[key], origin, ...args);
          }
        }
        return result;
      };
      this.getProps = (node = this) => {
        return {
          tag: node.tag,
          operator: node.operator,
          graph: node.graph,
          children: node.children,
          parent: node.parent,
          forward: node.forward,
          backward: node.bacward,
          loop: node.loop,
          animate: node.animate,
          frame: node.frame,
          delay: node.delay,
          recursive: node.recursive,
          repeat: node.repeat,
          branch: node.branch,
          oncreate: node.oncreate,
          DEBUGNODE: node.DEBUGNODE,
          ...this._initial
        };
      };
      this.setProps = (props = {}) => {
        let tmp = Object.assign({}, props);
        if (tmp.children) {
          this.addChildren(props.children);
          delete tmp.children;
        }
        if (tmp.operator) {
          this.setOperator(props.operator);
          delete tmp.operator;
        }
        Object.assign(tmp, props);
        if (!(this.children && this.forward || this.parent && this.backward || this.repeat || this.delay || this.frame || this.recursive))
          this.runSync = true;
      };
      this.removeTree = (node) => {
        if (node) {
          if (typeof node === "string")
            node = this.nodes.get(node);
        }
        if (node instanceof GraphNode) {
          const recursivelyRemove = (node2) => {
            if (typeof node2.children === "object") {
              for (const key in node2.children) {
                if (node2.children[key].stopNode)
                  node2.children[key].stopNode();
                if (node2.children[key].tag) {
                  if (this.nodes.get(node2.children[key].tag))
                    this.nodes.delete(node2.children[key].tag);
                  if (this[node2.children[key].tag] instanceof GraphNode)
                    delete this[node2.children[key].tag];
                }
                this.nodes.forEach((n) => {
                  if (n.nodes.get(node2.children[key].tag))
                    n.nodes.delete(node2.children[key].tag);
                  if (n[node2.children[key].tag] instanceof GraphNode)
                    delete n[node2.children[key].tag];
                });
                recursivelyRemove(node2.children[key]);
              }
            }
          };
          if (node.stopNode)
            node.stopNode();
          if (node.tag) {
            this.nodes.delete(node.tag);
            if (this[node.tag] instanceof GraphNode)
              delete this[node.tag];
            this.nodes.forEach((n) => {
              if (node?.tag) {
                if (n.nodes.get(node.tag))
                  n.nodes.delete(node.tag);
                if (n[node.tag] instanceof GraphNode)
                  delete n[node.tag];
              }
            });
            recursivelyRemove(node);
            if (this.graph)
              this.graph.removeTree(node);
          }
        }
      };
      this.checkNodesHaveChildMapped = (node, child, checked = {}) => {
        let tag = node.tag;
        if (!tag)
          tag = node.name;
        if (!checked[tag]) {
          checked[tag] = true;
          if (node.children) {
            if (child.tag in node.children) {
              if (node.children[child.tag] instanceof GraphNode) {
                if (!node.nodes.get(child.tag))
                  node.nodes.set(child.tag, child);
                node.children[child.tag] = child;
                if (!node.firstRun)
                  node.firstRun = true;
              }
            }
          }
          if (node.parent instanceof GraphNode) {
            if (node.nodes.get(child.tag) && !node.parent.nodes.get(child.tag))
              node.parent.nodes.set(child.tag, child);
            if (node.parent.children) {
              this.checkNodesHaveChildMapped(node.parent, child, checked);
            } else if (node.nodes) {
              node.nodes.forEach((n) => {
                if (!checked[n.tag]) {
                  this.checkNodesHaveChildMapped(n, child, checked);
                }
              });
            }
          }
          if (node.graph) {
            if (node.parent && node.parent.name !== node.graph.name) {
              node.graph.nodes.forEach((n) => {
                if (!checked[n.tag]) {
                  this.checkNodesHaveChildMapped(n, child, checked);
                }
              });
            }
          }
        }
      };
      this.convertChildrenToNodes = (n = this) => {
        if (n?.children) {
          for (const key in n.children) {
            if (!(n.children[key] instanceof GraphNode)) {
              if (typeof n.children[key] === "object") {
                if (!n.children[key].tag)
                  n.children[key].tag = key;
                if (!n.nodes.get(n.children[key].tag)) {
                  n.children[key] = new GraphNode(n.children[key], n, n.graph);
                  this.checkNodesHaveChildMapped(n, n.children[key]);
                }
              } else {
                if (typeof n.children[key] === "undefined" || n.children[key] == true) {
                  n.children[key] = n.graph.get(key);
                  if (!n.children[key])
                    n.children[key] = n.nodes.get(key);
                } else if (typeof n.children[key] === "string") {
                  let k = n.children[key];
                  n.children[key] = n.graph.get(k);
                  if (!n.children[key])
                    n.children[key] = n.nodes.get(key);
                }
                if (n.children[key] instanceof GraphNode) {
                  if (n.graph && n.children[key].parent.tag !== this.tag) {
                    let props = n.children[key].getProps();
                    delete props.parent;
                    delete props.graph;
                    if (n.source instanceof Graph)
                      n.children[key] = new GraphNode(props, n, n.source);
                    else {
                      n.children[key] = new GraphNode(props, n, n.graph);
                    }
                  }
                  n.nodes.set(n.children[key].tag, n.children[key]);
                  this.checkNodesHaveChildMapped(n, n.children[key]);
                  if (!(n.children[key].tag in n))
                    n[n.children[key].tag] = n.children[key];
                }
              }
            }
          }
        }
        return n.children;
      };
      this.stopLooping = (node = this) => {
        node.isLooping = false;
      };
      this.stopAnimating = (node = this) => {
        node.isAnimating = false;
      };
      this.stopNode = (node = this) => {
        node.stopAnimating(node);
        node.stopLooping(node);
      };
      this.subscribeNode = (node) => {
        if (node.tag)
          this.nodes.set(node.tag, node);
        return this.state.subscribeTrigger(this.tag, (res) => {
          node._run(node, this, res);
        });
      };
      this.print = (node = this, printChildren = true, nodesPrinted = []) => {
        let dummyNode = new GraphNode();
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode) {
          nodesPrinted.push(node.tag);
          let jsonToPrint = {
            tag: node.tag,
            operator: node.operator.toString()
          };
          if (node.parent)
            jsonToPrint.parent = node.parent.tag;
          if (typeof node.children === "object") {
            for (const key in node.children) {
              if (typeof node.children[key] === "string")
                return node.children[key];
              if (nodesPrinted.includes(node.children[key].tag))
                return node.children[key].tag;
              else if (!printChildren) {
                return node.children[key].tag;
              } else
                return node.children[key].print(node.children[key], printChildren, nodesPrinted);
            }
          }
          for (const prop in node) {
            if (prop === "parent" || prop === "children")
              continue;
            if (typeof dummyNode[prop] === "undefined") {
              if (typeof node[prop] === "function") {
                jsonToPrint[prop] = node[prop].toString();
              } else if (typeof node[prop] === "object") {
                jsonToPrint[prop] = JSON.stringifyWithCircularRefs(node[prop]);
              } else {
                jsonToPrint[prop] = node[prop];
              }
            }
          }
          return JSON.stringify(jsonToPrint);
        }
      };
      this.reconstruct = (json) => {
        let parsed = reconstructObject(json);
        if (parsed)
          return this.add(parsed);
      };
      this.setState = this.state.setState;
      this.DEBUGNODES = (debugging = true) => {
        this.DEBUGNODE = debugging;
        this.nodes.forEach((n) => {
          if (debugging)
            n.DEBUGNODE = true;
          else
            n.DEBUGNODE = false;
        });
      };
      if (typeof properties === "function") {
        properties = { operator: properties };
      }
      if (typeof properties === "object") {
        if (properties instanceof GraphNode && properties._initial)
          Object.assign(properties, properties._initial);
        if (properties instanceof Graph) {
          let source = properties;
          properties = {
            source,
            operator: (input) => {
              if (typeof input === "object") {
                let result = {};
                for (const key in input) {
                  if (typeof source[key] === "function") {
                    if (Array.isArray(input[key]))
                      result[key] = source[key](...input[key]);
                    else
                      result[key] = source[key](input[key]);
                  } else {
                    source[key] = input[key];
                    result[key] = source[key];
                  }
                }
                return result;
              }
              return source;
            }
          };
          if (source.operator)
            properties.operator = source.operator;
          if (source.children)
            properties.children = source.children;
          if (source.forward)
            properties.forward = source.forward;
          if (source.backward)
            properties.backward = source.backward;
          if (source.repeat)
            properties.repeat = source.repeat;
          if (source.recursive)
            properties.recursive = source.recursive;
          if (source.loop)
            properties.loop = source.loop;
          if (source.animate)
            properties.animate = source.animate;
          if (source.looper)
            properties.looper = source.looper;
          if (source.animation)
            properties.animation = source.animation;
          if (source.delay)
            properties.delay = source.delay;
          if (source.tag)
            properties.tag = source.tag;
          if (source.oncreate)
            properties.oncreate = source.oncreate;
          if (source.node) {
            if (source.node._initial)
              Object.assign(properties, source.node._initial);
          }
          if (source._initial)
            Object.assign(properties, source._initial);
          this.nodes = source.nodes;
          source.node = this;
          if (graph) {
            source.nodes.forEach((n) => {
              if (!graph.nodes.get(n.tag)) {
                graph.nodes.set(n.tag, n);
                graph.nNodes++;
              }
            });
          }
        }
        if (properties.tag && (graph || parentNode)) {
          let hasnode;
          if (graph?.nodes) {
            hasnode = graph.nodes.get(properties.tag);
          }
          if (!hasnode && parentNode?.nodes) {
            hasnode = parentNode.nodes.get(properties.tag);
          }
          if (hasnode) {
            Object.assign(this, hasnode);
            if (!this.source)
              this.source = hasnode;
            let props = hasnode.getProps();
            delete props.graph;
            delete props.parent;
            Object.assign(properties, props);
          }
        }
        if (properties?.operator) {
          properties.operator = this.setOperator(properties.operator);
        }
        if (!properties.tag && graph) {
          properties.tag = \`node\${graph.nNodes}\`;
        } else if (!properties.tag) {
          properties.tag = \`node\${Math.floor(Math.random() * 1e10)}\`;
        }
        if ("arguments" in properties) {
          if (properties.arguments) {
            for (let key in properties.arguments) {
              this.arguments.set(key, properties.arguments[key]);
            }
          }
          properties.arguments = this.arguments;
        }
        let keys = Object.getOwnPropertyNames(this);
        for (const key in properties) {
          if (!keys.includes(key))
            this._initial[key] = properties[key];
        }
        if (properties.children)
          this._initial.children = Object.assign({}, properties.children);
        Object.assign(this, properties);
        if (!this.tag) {
          if (graph) {
            this.tag = \`node\${graph.nNodes}\`;
          } else {
            this.tag = \`node\${Math.floor(Math.random() * 1e10)}\`;
          }
        }
        if (parentNode) {
          this.parent = parentNode;
          if (parentNode instanceof GraphNode || parentNode instanceof Graph)
            parentNode.nodes.set(this.tag, this);
        }
        if (graph) {
          this.graph = graph;
          if (graph.nodes.get(this.tag)) {
            this.tag = \`\${this.tag}\${graph.nNodes + 1}\`;
          }
          graph.nodes.set(this.tag, this);
          graph.nNodes++;
        }
        if (typeof properties.tree === "object") {
          for (const key in properties.tree) {
            if (typeof properties.tree[key] === "object") {
              if ((!properties.tree[key]).tag) {
                properties.tree[key].tag = key;
              }
            }
            let node = new GraphNode(properties.tree[key], this, graph);
            this.nodes.set(node.tag, node);
          }
        }
        if (this.children)
          this.convertChildrenToNodes(this);
        if (this.parent instanceof GraphNode || this.parent instanceof Graph)
          this.checkNodesHaveChildMapped(this.parent, this);
        if (typeof this.oncreate === "function")
          this.oncreate(this);
        if (!this.firstRun)
          this.firstRun = true;
      } else
        return properties;
    }
  };
  var Graph = class {
    constructor(tree, tag, props) {
      this.nNodes = 0;
      this.nodes = /* @__PURE__ */ new Map();
      this.state = state;
      this.tree = {};
      this.add = (node = {}) => {
        let props = node;
        if (!(node instanceof GraphNode))
          node = new GraphNode(props, this, this);
        else
          this.nNodes++;
        if (node.tag)
          this.tree[node.tag] = props;
        this.nodes.set(node.tag, node);
        return node;
      };
      this.setTree = (tree = this.tree) => {
        if (!tree)
          return;
        for (const node in tree) {
          if (!this.nodes.get(node)) {
            if (typeof tree[node] === "function") {
              this.add({ tag: node, operator: tree[node] });
            } else if (typeof tree[node] === "object" && !Array.isArray(tree[node])) {
              if (!tree[node].tag)
                tree[node].tag = node;
              let newNode = this.add(tree[node]);
              if (tree[node].aliases) {
                tree[node].aliases.forEach((a) => {
                  this.nodes.set(a, newNode);
                });
              }
            } else {
              this.add({ tag: node, operator: (self2, origin, ...args) => {
                return tree[node];
              } });
            }
          } else {
            let n = this.nodes.get(node);
            if (typeof tree[node] === "function") {
              n.setOperator(tree[node]);
            } else if (typeof tree[node] === "object") {
              if (tree[node] instanceof GraphNode) {
                if (n.tag !== tree[node].tag)
                  this.add(tree[node]);
              } else if (tree[node] instanceof Graph) {
                let source = tree[node];
                let properties = {};
                if (source.operator)
                  properties.operator = source.operator;
                if (source.children)
                  properties.children = source.children;
                if (source.forward)
                  properties.forward = source.forward;
                if (source.backward)
                  properties.backward = source.backward;
                if (source.repeat)
                  properties.repeat = source.repeat;
                if (source.recursive)
                  properties.recursive = source.recursive;
                if (source.loop)
                  properties.loop = source.loop;
                if (source.animate)
                  properties.animate = source.animate;
                if (source.looper)
                  properties.looper = source.looper;
                if (source.animation)
                  properties.animation = source.animation;
                if (source.delay)
                  properties.delay = source.delay;
                if (source.tag)
                  properties.tag = source.tag;
                if (source.oncreate)
                  properties.oncreate = source.oncreate;
                if (source.node?._initial)
                  Object.assign(properties, source.node._initial);
                properties.nodes = source.nodes;
                properties.source = source;
                n.setProps(properties);
              } else {
                n.setProps(tree[node]);
              }
            }
          }
        }
        this.nodes.forEach((node) => {
          if (typeof node.children === "object") {
            for (const key in node.children) {
              if (typeof node.children[key] === "string") {
                if (this.nodes.get(node.children[key])) {
                  node.children[key] = this.nodes.get(node.children[key]);
                }
              } else if (node.children[key] === true || typeof node.children[key] === "undefined") {
                if (this.nodes.get(key)) {
                  node.children[key] = this.nodes.get(key);
                }
              }
              if (node.children[key] instanceof GraphNode) {
                node.checkNodesHaveChildMapped(node, node.children[key]);
              }
            }
          }
          if (typeof node.parent === "string") {
            if (this.nodes.get(node.parent)) {
              node.parent = this.nodes.get(node.parent);
              node.nodes.set(node.parent.tag, node.parent);
            }
          }
        });
      };
      this.get = (tag) => {
        return this.nodes.get(tag);
      };
      this.set = (node) => {
        return this.nodes.set(node.tag, node);
      };
      this.run = (node, ...args) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode)
          return node._run(node, this, ...args);
        else
          return void 0;
      };
      this.runAsync = (node, ...args) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode)
          return new Promise((res, rej) => {
            res(node._run(node, this, ...args));
          });
        else
          return new Promise((res, rej) => {
            res(void 0);
          });
      };
      this._run = (node, origin = this, ...args) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode)
          return node._run(node, origin, ...args);
        else
          return void 0;
      };
      this.removeTree = (node) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node instanceof GraphNode) {
          const recursivelyRemove = (node2) => {
            if (node2.children) {
              if (Array.isArray(node2.children)) {
                node2.children.forEach((c) => {
                  if (c.stopNode)
                    c.stopNode();
                  if (c.tag) {
                    if (this.nodes.get(c.tag))
                      this.nodes.delete(c.tag);
                  }
                  this.nodes.forEach((n) => {
                    if (n.nodes.get(c.tag))
                      n.nodes.delete(c.tag);
                  });
                  recursivelyRemove(c);
                });
              } else if (typeof node2.children === "object") {
                if (node2.stopNode)
                  node2.stopNode();
                if (node2.tag) {
                  if (this.nodes.get(node2.tag))
                    this.nodes.delete(node2.tag);
                }
                this.nodes.forEach((n) => {
                  if (n.nodes.get(node2.tag))
                    n.nodes.delete(node2.tag);
                });
                recursivelyRemove(node2);
              }
            }
          };
          if (node.stopNode)
            node.stopNode();
          if (node.tag) {
            this.nodes.delete(node.tag);
            this.nodes.forEach((n) => {
              if (n.nodes.get(node.tag))
                n.nodes.delete(node.tag);
            });
            this.nNodes--;
            recursivelyRemove(node);
          }
        }
        return node;
      };
      this.remove = (node) => {
        if (typeof node === "string")
          node = this.nodes.get(node);
        if (node?.tag) {
          node.stopNode();
          if (node?.tag) {
            if (this.nodes.get(node.tag)) {
              this.nodes.delete(node.tag);
              this.nodes.forEach((n) => {
                if (n.nodes.get(node.tag))
                  n.nodes.delete(node.tag);
              });
            }
          }
        }
        return node;
      };
      this.append = (node, parentNode) => {
        parentNode.addChildren(node);
      };
      this.callParent = async (node, origin = node, ...args) => {
        if (node?.parent) {
          return await node.callParent(node, origin, ...args);
        }
      };
      this.callChildren = async (node, idx, ...args) => {
        if (node?.children) {
          return await node.callChildren(idx, ...args);
        }
      };
      this.subscribe = (node, callback) => {
        if (!callback)
          return;
        if (node instanceof GraphNode) {
          return node.subscribe(callback);
        } else if (typeof node == "string")
          return this.state.subscribeTrigger(node, callback);
      };
      this.unsubscribe = (tag, sub) => {
        this.state.unsubscribeTrigger(tag, sub);
      };
      this.subscribeNode = (inputNode, outputNode) => {
        let tag;
        if (inputNode?.tag)
          tag = inputNode.tag;
        else if (typeof inputNode === "string")
          tag = inputNode;
        return this.state.subscribeTrigger(tag, (res) => {
          this.run(outputNode, inputNode, ...res);
        });
      };
      this.stopNode = (node) => {
        if (typeof node === "string") {
          node = this.nodes.get(node);
        }
        if (node instanceof GraphNode) {
          node.stopNode();
        }
      };
      this.print = (node = void 0, printChildren = true) => {
        if (node instanceof GraphNode)
          return node.print(node, printChildren);
        else {
          let printed = \`{\`;
          this.nodes.forEach((n) => {
            printed += \`
"\${n.tag}:\${n.print(n, printChildren)}"\`;
          });
          return printed;
        }
      };
      this.reconstruct = (json) => {
        let parsed = reconstructObject(json);
        if (parsed)
          return this.add(parsed);
      };
      this.create = (operator, parentNode, props) => {
        return createNode(operator, parentNode, props, this);
      };
      this.setState = this.state.setState;
      this.DEBUGNODES = (debugging = true) => {
        this.nodes.forEach((n) => {
          if (debugging)
            n.DEBUGNODE = true;
          else
            n.DEBUGNODE = false;
        });
      };
      this.tag = tag ? tag : \`graph\${Math.floor(Math.random() * 1e11)}\`;
      if (props) {
        Object.assign(this, props);
        this._initial = props;
      }
      if (tree || Object.keys(this.tree).length > 0)
        this.setTree(tree);
    }
  };
  function reconstructObject(json = "{}") {
    try {
      let parsed = typeof json === "string" ? JSON.parse(json) : json;
      const parseObj = (obj) => {
        for (const prop in obj) {
          if (typeof obj[prop] === "string") {
            let funcParsed = parseFunctionFromText(obj[prop]);
            if (typeof funcParsed === "function") {
              obj[prop] = funcParsed;
            }
          } else if (typeof obj[prop] === "object") {
            parseObj(obj[prop]);
          }
        }
        return obj;
      };
      return parseObj(parsed);
    } catch (err) {
      console.error(err);
      return void 0;
    }
  }
  var stringifyWithCircularRefs = function() {
    const refs = /* @__PURE__ */ new Map();
    const parents = [];
    const path = ["this"];
    function clear() {
      refs.clear();
      parents.length = 0;
      path.length = 1;
    }
    function updateParents(key, value2) {
      var idx = parents.length - 1;
      var prev = parents[idx];
      if (typeof prev === "object") {
        if (prev[key] === value2 || idx === 0) {
          path.push(key);
          parents.push(value2.pushed);
        } else {
          while (idx-- >= 0) {
            prev = parents[idx];
            if (typeof prev === "object") {
              if (prev[key] === value2) {
                idx += 2;
                parents.length = idx;
                path.length = idx;
                --idx;
                parents[idx] = value2;
                path[idx] = key;
                break;
              }
            }
            idx--;
          }
        }
      }
    }
    function checkCircular(key, value2) {
      if (value2 != null) {
        if (typeof value2 === "object") {
          if (key) {
            updateParents(key, value2);
          }
          let other = refs.get(value2);
          if (other) {
            return "[Circular Reference]" + other;
          } else {
            refs.set(value2, path.join("."));
          }
        }
      }
      return value2;
    }
    return function stringifyWithCircularRefs2(obj, space) {
      try {
        parents.push(obj);
        return JSON.stringify(obj, checkCircular, space);
      } finally {
        clear();
      }
    };
  }();
  if (JSON.stringifyWithCircularRefs === void 0) {
    JSON.stringifyWithCircularRefs = stringifyWithCircularRefs;
  }
  var stringifyFast = function() {
    const refs = /* @__PURE__ */ new Map();
    const parents = [];
    const path = ["this"];
    function clear() {
      refs.clear();
      parents.length = 0;
      path.length = 1;
    }
    function updateParents(key, value2) {
      var idx = parents.length - 1;
      if (parents[idx]) {
        var prev = parents[idx];
        if (typeof prev === "object") {
          if (prev[key] === value2 || idx === 0) {
            path.push(key);
            parents.push(value2.pushed);
          } else {
            while (idx-- >= 0) {
              prev = parents[idx];
              if (typeof prev === "object") {
                if (prev[key] === value2) {
                  idx += 2;
                  parents.length = idx;
                  path.length = idx;
                  --idx;
                  parents[idx] = value2;
                  path[idx] = key;
                  break;
                }
              }
              idx++;
            }
          }
        }
      }
    }
    function checkValues(key, value2) {
      let val;
      if (value2 != null) {
        if (typeof value2 === "object") {
          let c = value2.constructor.name;
          if (key && c === "Object") {
            updateParents(key, value2);
          }
          let other = refs.get(value2);
          if (other) {
            return "[Circular Reference]" + other;
          } else {
            refs.set(value2, path.join("."));
          }
          if (c === "Array") {
            if (value2.length > 20) {
              val = value2.slice(value2.length - 20);
            } else
              val = value2;
          } else if (c.includes("Set")) {
            val = Array.from(value2);
          } else if (c !== "Object" && c !== "Number" && c !== "String" && c !== "Boolean") {
            val = "instanceof_" + c;
          } else if (c === "Object") {
            let obj = {};
            for (const prop in value2) {
              if (value2[prop] == null) {
                obj[prop] = value2[prop];
              } else if (Array.isArray(value2[prop])) {
                if (value2[prop].length > 20)
                  obj[prop] = value2[prop].slice(value2[prop].length - 20);
                else
                  obj[prop] = value2[prop];
              } else if (value2[prop].constructor.name === "Object") {
                obj[prop] = {};
                for (const p in value2[prop]) {
                  if (Array.isArray(value2[prop][p])) {
                    if (value2[prop][p].length > 20)
                      obj[prop][p] = value2[prop][p].slice(value2[prop][p].length - 20);
                    else
                      obj[prop][p] = value2[prop][p];
                  } else {
                    if (value2[prop][p] != null) {
                      let con = value2[prop][p].constructor.name;
                      if (con.includes("Set")) {
                        obj[prop][p] = Array.from(value2[prop][p]);
                      } else if (con !== "Number" && con !== "String" && con !== "Boolean") {
                        obj[prop][p] = "instanceof_" + con;
                      } else {
                        obj[prop][p] = value2[prop][p];
                      }
                    } else {
                      obj[prop][p] = value2[prop][p];
                    }
                  }
                }
              } else {
                let con = value2[prop].constructor.name;
                if (con.includes("Set")) {
                  obj[prop] = Array.from(value2[prop]);
                } else if (con !== "Number" && con !== "String" && con !== "Boolean") {
                  obj[prop] = "instanceof_" + con;
                } else {
                  obj[prop] = value2[prop];
                }
              }
            }
            val = obj;
          } else {
            val = value2;
          }
        } else {
          val = value2;
        }
      }
      return val;
    }
    return function stringifyFast2(obj, space) {
      parents.push(obj);
      let res = JSON.stringify(obj, checkValues, space);
      clear();
      return res;
    };
  }();
  if (JSON.stringifyFast === void 0) {
    JSON.stringifyFast = stringifyFast;
  }
  function createNode(operator, parentNode, props, graph) {
    if (typeof props === "object") {
      props.operator = operator;
      return new GraphNode(props, parentNode, graph);
    }
    return new GraphNode({ operator }, parentNode, graph);
  }

  // ../GraphServiceRouter/services/Service.ts
  var Service = class extends Graph {
    constructor(options = {}) {
      super(void 0, options.name, options.props);
      this.routes = {};
      this.loadDefaultRoutes = false;
      this.name = \`service\${Math.floor(Math.random() * 1e14)}\`;
      this.keepState = true;
      this.firstLoad = true;
      this.init = (options) => {
        options = Object.assign({}, options);
        if ("loadDefaultRoutes" in options)
          this.loadDefaultRoutes = options.loadDefaultRoutes;
        if (options.customRoutes)
          Object.assign(options.customRoutes, this.customRoutes);
        else
          options.customRoutes = this.customRoutes;
        if (options.customChildren)
          Object.assign(options.customChildren, this.customChildren);
        else
          options.customChildren = this.customChildren;
        if (Array.isArray(options.routes)) {
          options.routes.forEach((r) => {
            this.load(r, options.includeClassName, options.routeFormat, options.customRoutes, options.customChildren);
          });
        } else if (options.routes || Object.keys(this.routes).length > 0 && this.firstLoad)
          this.load(options.routes, options.includeClassName, options.routeFormat, options.customRoutes, options.customChildren);
      };
      this.load = (routes, includeClassName = true, routeFormat = ".", customRoutes, customChildren) => {
        if (!routes && !this.loadDefaultRoutes && (Object.keys(this.routes).length > 0 || this.firstLoad))
          return;
        if (this.firstLoad)
          this.firstLoad = false;
        let service;
        if (routes) {
          if (!(routes instanceof Graph) && routes?.name) {
            if (routes.module) {
              let mod = routes;
              routes = {};
              Object.getOwnPropertyNames(routes.module).forEach((prop) => {
                if (includeClassName)
                  routes[mod.name + routeFormat + prop] = routes.module[prop];
                else
                  routes[prop] = routes.module[prop];
              });
            } else if (typeof routes === "function") {
              service = new routes({ loadDefaultRoutes: this.loadDefaultRoutes });
              service.load();
              routes = service.routes;
            }
          } else if (routes instanceof Graph || routes.source instanceof Graph) {
            service = routes;
            routes = {};
            let name2;
            if (includeClassName) {
              name2 = service.name;
              if (!name2) {
                name2 = service.tag;
                service.name = name2;
              }
              if (!name2) {
                name2 = \`graph\${Math.floor(Math.random() * 1e15)}\`;
                service.name = name2;
                service.tag = name2;
              }
            }
            service.nodes.forEach((node) => {
              routes[node.tag] = node;
              let checked = {};
              let checkChildGraphNodes = (nd, par) => {
                if (!checked[nd.tag] || par && includeClassName && !checked[par?.tag + routeFormat + nd.tag]) {
                  if (!par)
                    checked[nd.tag] = true;
                  else
                    checked[par.tag + routeFormat + nd.tag] = true;
                  if (nd instanceof Graph || nd.source instanceof Graph) {
                    if (includeClassName) {
                      let nm = nd.name;
                      if (!nm) {
                        nm = nd.tag;
                        nd.name = nm;
                      }
                      if (!nm) {
                        nm = \`graph\${Math.floor(Math.random() * 1e15)}\`;
                        nd.name = nm;
                        nd.tag = nm;
                      }
                    }
                    nd.nodes.forEach((n) => {
                      if (includeClassName)
                        routes[nd.tag + routeFormat + n.tag] = n;
                      else if (!routes[n.tag])
                        routes[n.tag] = n;
                      checkChildGraphNodes(n, nd);
                    });
                  }
                }
              };
              checkChildGraphNodes(node);
            });
          } else if (typeof routes === "object") {
            let name2 = routes.constructor.name;
            if (name2 === "Object") {
              name2 = Object.prototype.toString.call(routes);
              if (name2)
                name2 = name2.split(" ")[1];
              if (name2)
                name2 = name2.split("]")[0];
            }
            if (name2 && name2 !== "Object") {
              let module = routes;
              routes = {};
              Object.getOwnPropertyNames(module).forEach((route) => {
                if (includeClassName)
                  routes[name2 + routeFormat + route] = module[route];
                else
                  routes[route] = module[route];
              });
            }
          }
          if (service instanceof Graph && service.name && includeClassName) {
            routes = Object.assign({}, routes);
            for (const prop in routes) {
              let route = routes[prop];
              delete routes[prop];
              routes[service.name + routeFormat + prop] = route;
            }
          }
        }
        if (this.loadDefaultRoutes) {
          let rts = Object.assign({}, this.defaultRoutes);
          if (routes) {
            Object.assign(rts, this.routes);
            routes = Object.assign(rts, routes);
          } else
            routes = Object.assign(rts, this.routes);
          this.loadDefaultRoutes = false;
        }
        if (!routes)
          routes = this.routes;
        for (const tag in routes) {
          let childrenIter = (route, routeKey) => {
            if (!route.tag)
              route.tag = routeKey;
            if (typeof route?.children === "object") {
              nested:
                for (const key in route.children) {
                  if (typeof route.children[key] === "object") {
                    let rt = route.children[key];
                    if (rt.tag && routes[rt.tag])
                      continue;
                    if (customChildren) {
                      for (const k in customChildren) {
                        rt = customChildren[k](rt, key, route, routes);
                        if (!rt)
                          continue nested;
                      }
                    }
                    if (rt.tag) {
                      routes[rt.tag] = route.children[key];
                      childrenIter(routes[rt.tag], key);
                    } else if (rt.id) {
                      rt.tag = rt.id;
                      routes[rt.tag] = route.children[key];
                      childrenIter(routes[rt.tag], key);
                    } else {
                      routes[key] = route.children[key];
                      childrenIter(routes[key], key);
                    }
                  }
                }
            }
          };
          childrenIter(routes[tag], tag);
        }
        top:
          for (const route in routes) {
            if (typeof routes[route] === "object") {
              let r = routes[route];
              if (typeof r === "object") {
                if (customRoutes) {
                  for (const key in customRoutes) {
                    r = customRoutes[key](r, route, routes);
                    if (!r)
                      continue top;
                  }
                }
                if (r.get) {
                  if (typeof r.get == "object") {
                  }
                }
                if (r.post) {
                }
                if (r.delete) {
                }
                if (r.put) {
                }
                if (r.head) {
                }
                if (r.patch) {
                }
                if (r.options) {
                }
                if (r.connect) {
                }
                if (r.trace) {
                }
                if (r.post && !r.operator) {
                  routes[route].operator = r.post;
                } else if (!r.operator && typeof r.get == "function") {
                  routes[route].operator = r.get;
                }
              }
              if (this.routes[route]) {
                if (typeof this.routes[route] === "object")
                  Object.assign(this.routes[route], routes[route]);
                else
                  this.routes[route] = routes[route];
              } else
                this.routes[route] = routes[route];
            } else if (this.routes[route]) {
              if (typeof this.routes[route] === "object")
                Object.assign(this.routes[route], routes[route]);
              else
                this.routes[route] = routes[route];
            } else
              this.routes[route] = routes[route];
          }
        this.setTree(this.routes);
        for (const prop in this.routes) {
          if (this.routes[prop]?.aliases) {
            let aliases = this.routes[prop].aliases;
            aliases.forEach((a) => {
              if (service?.name && includeClassName)
                routes[service.name + routeFormat + a] = this.routes[prop];
              else
                routes[a] = this.routes[prop];
            });
          }
        }
        return this.routes;
      };
      this.unload = (routes = this.routes) => {
        if (!routes)
          return;
        let service;
        if (!(routes instanceof Service) && typeof routes === "function") {
          service = new Service();
          routes = service.routes;
        } else if (routes instanceof Service) {
          routes = routes.routes;
        }
        for (const r in routes) {
          delete this.routes[r];
          if (this.nodes.get(r))
            this.remove(r);
        }
        return this.routes;
      };
      this.handleMethod = (route, method, args, origin) => {
        let m = method.toLowerCase();
        if (m === "get" && this.routes[route]?.get?.transform instanceof Function) {
          if (Array.isArray(args))
            return this.routes[route].get.transform(...args);
          else
            return this.routes[route].get.transform(args);
        }
        if (this.routes[route]?.[m]) {
          if (!(this.routes[route][m] instanceof Function)) {
            if (args)
              this.routes[route][m] = args;
            return this.routes[route][m];
          } else
            return this.routes[route][m](args);
        } else
          return this.handleServiceMessage({ route, args, method, origin });
      };
      this.transmit = (...args) => {
        if (typeof args[0] === "object") {
          if (args[0].method) {
            return this.handleMethod(args[0].route, args[0].method, args[0].args);
          } else if (args[0].route) {
            return this.handleServiceMessage(args[0]);
          } else if (args[0].node) {
            return this.handleGraphNodeCall(args[0].node, args[0].args, args[0].origin);
          } else if (this.keepState) {
            if (args[0].route)
              this.setState({ [args[0].route]: args[0].args });
            if (args[0].node)
              this.setState({ [args[0].node]: args[0].args });
          }
        } else
          return args;
      };
      this.receive = (...args) => {
        if (args[0]) {
          if (typeof args[0] === "string") {
            let substr = args[0].substring(0, 8);
            if (substr.includes("{") || substr.includes("[")) {
              if (substr.includes("\\\\"))
                args[0] = args[0].replace(/\\\\/g, "");
              if (args[0][0] === '"') {
                args[0] = args[0].substring(1, args[0].length - 1);
              }
              ;
              args[0] = JSON.parse(args[0]);
            }
          }
        }
        if (typeof args[0] === "object") {
          if (args[0].method) {
            return this.handleMethod(args[0].route, args[0].method, args[0].args);
          } else if (args[0].route) {
            return this.handleServiceMessage(args[0]);
          } else if (args[0].node) {
            return this.handleGraphNodeCall(args[0].node, args[0].args, args[0].origin);
          } else if (this.keepState) {
            if (args[0].route)
              this.setState({ [args[0].route]: args[0].args });
            if (args[0].node)
              this.setState({ [args[0].node]: args[0].args });
          }
        } else
          return args;
      };
      this.pipe = (source, destination, endpoint, origin, method, callback) => {
        if (source instanceof GraphNode) {
          if (callback)
            return source.subscribe((res) => {
              let mod = callback(res);
              if (mod !== void 0)
                this.transmit({ route: destination, args: mod, origin, method });
              else
                this.transmit({ route: destination, args: res, origin, method }, endpoint);
            });
          else
            return this.subscribe(source, (res) => {
              this.transmit({ route: destination, args: res, origin, method }, endpoint);
            });
        } else if (typeof source === "string")
          return this.subscribe(source, (res) => {
            this.transmit({ route: destination, args: res, origin, method }, endpoint);
          });
      };
      this.pipeOnce = (source, destination, endpoint, origin, method, callback) => {
        if (source instanceof GraphNode) {
          if (callback)
            return source.state.subscribeTriggerOnce(source.tag, (res) => {
              let mod = callback(res);
              if (mod !== void 0)
                this.transmit({ route: destination, args: mod, origin, method });
              else
                this.transmit({ route: destination, args: res, origin, method }, endpoint);
            });
          else
            return this.state.subscribeTriggerOnce(source.tag, (res) => {
              this.transmit({ route: destination, args: res, origin, method }, endpoint);
            });
        } else if (typeof source === "string")
          return this.state.subscribeTriggerOnce(source, (res) => {
            this.transmit({ route: destination, args: res, origin, method }, endpoint);
          });
      };
      this.terminate = (...args) => {
        this.nodes.forEach((n) => {
          n.stopNode();
        });
      };
      this.recursivelyAssign = (target, obj) => {
        for (const key in obj) {
          if (typeof obj[key] === "object") {
            if (typeof target[key] === "object")
              this.recursivelyAssign(target[key], obj[key]);
            else
              target[key] = this.recursivelyAssign({}, obj[key]);
          } else
            target[key] = obj[key];
        }
        return target;
      };
      this.defaultRoutes = {
        "/": {
          get: () => {
            return this.print();
          },
          aliases: [""]
        },
        ping: () => {
          console.log("ping");
          return "pong";
        },
        echo: (...args) => {
          this.transmit(...args);
          return args;
        },
        assign: (source) => {
          if (typeof source === "object") {
            Object.assign(this, source);
            return true;
          }
          return false;
        },
        recursivelyAssign: (source) => {
          if (typeof source === "object") {
            this.recursivelyAssign(this, source);
            return true;
          }
          return false;
        },
        log: {
          post: (...args) => {
            console.log("Log: ", ...args);
          },
          aliases: ["info"]
        },
        error: (message) => {
          let er = new Error(message);
          console.error(message);
          return er;
        },
        state: (key) => {
          if (key) {
            return this.state.data[key];
          } else
            return this.state.data;
        },
        printState: (key) => {
          if (key) {
            return stringifyWithCircularRefs(this.state.data[key]);
          } else
            return stringifyWithCircularRefs(this.state.data);
        },
        transmit: this.transmit,
        receive: this.receive,
        load: this.load,
        unload: this.unload,
        pipe: this.pipe,
        terminate: this.terminate,
        run: this.run,
        _run: this._run,
        subscribe: this.subscribe,
        unsubscribe: this.unsubscribe,
        stopNode: this.stopNode,
        get: this.get,
        add: this.add,
        remove: this.remove,
        setTree: this.setTree,
        setState: this.setState,
        print: this.print,
        reconstruct: this.reconstruct,
        handleMethod: this.handleMethod,
        handleServiceMessage: this.handleServiceMessage,
        handleGraphNodeCall: this.handleGraphNodeCall
      };
      if (options.name)
        this.name = options.name;
      if (options.routes || Object.keys(this.routes).length > 0)
        this.init(options);
    }
    handleServiceMessage(message) {
      let call;
      if (typeof message === "object") {
        if (message.route)
          call = message.route;
        else if (message.node)
          call = message.node;
      }
      if (call) {
        if (message.origin) {
          if (Array.isArray(message.args))
            return this._run(call, message.origin, ...message.args);
          else
            return this._run(call, message.origin, message.args);
        } else {
          if (Array.isArray(message.args))
            return this.run(call, ...message.args);
          else
            return this.run(call, message.args);
        }
      } else
        return message;
    }
    handleGraphNodeCall(route, args, origin) {
      if (!route)
        return args;
      if (args?.args) {
        this.handleServiceMessage(args);
      } else if (origin) {
        if (Array.isArray(args))
          return this._run(route, origin, ...args);
        else
          return this._run(route, origin, args);
      } else if (Array.isArray(args))
        return this.run(route, ...args);
      else
        return this.run(route, args);
    }
    isTypedArray(x2) {
      return ArrayBuffer.isView(x2) && Object.prototype.toString.call(x2) !== "[object DataView]";
    }
  };

  // ../GraphServiceRouter/routers/Router.ts
  var Router = class {
    constructor(services, options) {
      this.id = \`router\${Math.floor(Math.random() * 1e15)}\`;
      this.service = new Service();
      this.nodes = this.service.nodes;
      this.run = this.service.run;
      this._run = this.service._run;
      this.add = this.service.add;
      this.remove = this.service.remove;
      this.stopNode = this.service.stopNode;
      this.subscribe = this.service.subscribe;
      this.unsubscribe = this.service.unsubscribe;
      this.get = this.service.get;
      this.reconstruct = this.service.reconstruct;
      this.setState = this.service.setState;
      this.recursivelyAssign = this.service.recursivelyAssign;
      this.state = this.service.state;
      this.routes = this.service.routes;
      this.services = {};
      this.loadDefaultRoutes = false;
      this.load = (service, linkServices = true, includeClassName = true) => {
        if (!(service instanceof Graph) && typeof service === "function") {
          service = new service({ loadDefaultRoutes: this.loadDefaultRoutes }, service.name);
          service.load();
        } else if (!service)
          return;
        if (service instanceof Graph && service.name) {
          this.services[service.name] = service;
        } else {
          if (service.constructor.name === "Object") {
            let name2 = Object.prototype.toString.call(service);
            if (name2)
              name2 = name2.split(" ")[1];
            if (name2)
              name2 = name2.split("]")[0];
            if (name2 && name2 !== "Object" && name2 !== "Function") {
              this.services[name2] = service;
            }
          } else
            this.services[service.constructor.name] = service;
        }
        this.service.load(service, includeClassName);
        if (linkServices) {
          for (const name2 in this.services) {
            this.service.nodes.forEach((n) => {
              if (this.services[name2]?.nodes) {
                if (!this.services[name2].nodes.get(n.tag)) {
                  this.services[name2].nodes.set(n.tag, n);
                }
              }
            });
          }
        }
        return this.services[service.name];
      };
      this.pipe = (source, destination, transmitter, origin, method, callback) => {
        if (!transmitter && source && destination) {
          if (callback)
            return this.subscribe(source, (res) => {
              let mod = callback(res);
              if (mod)
                res = mod;
              this.run(destination, res);
            });
          return this.subscribe(source, (res) => {
            this.run(destination, res);
          });
        }
        if (transmitter) {
          if (transmitter === "sockets")
            transmitter = "wss";
          const radio = this.services[transmitter];
          if (radio) {
            if (callback) {
              return this.subscribe(source, (res) => {
                let mod = callback(res);
                if (mod)
                  res = mod;
                radio.transmit({ route: destination, args: res, origin, method });
              });
            } else
              return this.subscribe(source, (res) => {
                radio.transmit({ route: destination, args: res, origin, method });
              });
          } else {
            let endpoint = this.getEndpointInfo(transmitter);
            if (endpoint) {
              return this.services[endpoint.service].pipe(source, destination, transmitter, origin, method, callback);
            }
          }
        }
        return false;
      };
      this.pipeOnce = (source, destination, transmitter, origin, method, callback) => {
        if (source instanceof GraphNode)
          source = source.tag;
        if (!transmitter && typeof source === "string" && destination) {
          if (callback)
            return this.state.subscribeTriggerOnce(source, (res) => {
              let mod = callback(res);
              if (mod)
                res = mod;
              this.run(destination, res);
            });
          return this.state.subscribeTriggerOnce(source, (res) => {
            this.run(destination, res);
          });
        }
        if (transmitter) {
          if (transmitter === "sockets")
            transmitter = "wss";
          const radio = this.services[transmitter];
          if (radio) {
            if (callback) {
              return this.state.subscribeTriggerOnce(source, (res) => {
                let mod = callback(res);
                if (mod)
                  res = mod;
                radio.transmit({ route: destination, args: res, origin, method });
              });
            } else
              return this.state.subscribeTriggerOnce(source, (res) => {
                radio.transmit({ route: destination, args: res, origin, method });
              });
          } else {
            let endpoint = this.getEndpointInfo(transmitter);
            if (endpoint) {
              return this.services[endpoint.service].pipeOnce(source, destination, transmitter, origin, method, callback);
            }
          }
        }
        return false;
      };
      this.sendAll = (message, connections, channel) => {
        let sent = false;
        if (typeof connections === "object") {
          for (const protocol in connections) {
            for (const info in connections[protocol]) {
              let obj = connections[protocol][info];
              if (obj.socket) {
                if (obj.socket.readyState === 1) {
                  obj.socket.send(message);
                  sent = true;
                } else
                  delete connections[protocol][info];
              } else if (obj.wss) {
                obj.wss.clients.forEach((c) => {
                  c.send(message);
                });
                sent = true;
              } else if (obj.sessions) {
                if (channel) {
                  obj.channel.broadcast(message, channel);
                  sent = true;
                } else
                  for (const s in obj.sessions) {
                    if (obj.sessions[s].isConnected) {
                      obj.sessions[s].push(message);
                      sent = true;
                    }
                  }
              } else if (obj.session) {
                if (channel) {
                  obj.served.channel.broadcast(message, channel);
                  sent = true;
                } else if (obj.session.isConnected) {
                  obj.session.push(message);
                  sent = true;
                } else
                  delete connections[protocol][info];
              } else if (obj.rtc) {
                if (channel && obj.channels[channel]) {
                  obj.channels[channel].send(message);
                  sent = true;
                } else if (obj.channels.data) {
                  obj.channels.data.send(message);
                  sent = true;
                } else {
                  let firstchannel = Object.keys(obj.channels)[0];
                  obj.channels[firstchannel].send(message);
                  sent = true;
                }
              } else if (obj.server) {
                if (this.services.http) {
                  this.services.http.transmit(message, channel);
                  sent = true;
                }
              }
            }
          }
        }
        return sent;
      };
      this.getEndpointInfo = (path, service) => {
        if (!path)
          return void 0;
        let testpath = (path2, service2) => {
          if (this.services[service2]) {
            if (this.services[service2].rtc?.[path2]) {
              return this.services[service2].rtc[path2];
            } else if (this.services[service2].servers?.[path2]) {
              return this.services[service2].servers[path2];
            } else if (this.services[service2].sockets?.[path2]) {
              return this.services[service2].sockets[path2];
            } else if (this.services[service2].eventsources?.[path2]) {
              return this.services[service2].eventsources[path2];
            } else if (this.services[service2].workers?.[path2]) {
              return this.services[service2].workers[path2];
            }
          }
          return void 0;
        };
        if (service) {
          let found = testpath(path, service);
          if (found)
            return {
              endpoint: found,
              service
            };
        }
        for (const s in this.services) {
          let found = testpath(path, s);
          if (found)
            return {
              endpoint: found,
              service: s
            };
        }
        return void 0;
      };
      this.pipeFastest = (source, destination, origin, method, callback, services = this.services) => {
        for (const service in services) {
          if (services[service].rtc) {
            return this.pipe(source, destination, "webrtc", origin, method, callback);
          }
          if (services[service].eventsources) {
            let keys = Object.keys(services[service].eventsources);
            if (keys[0]) {
              if (this.services[service].eventsources[keys[0]].sessions)
                return this.pipe(source, destination, "sse", origin, method, callback);
            }
          }
          if (services[service].sockets) {
            return this.pipe(source, destination, "wss", origin, method, callback);
          }
          if (services[service].servers) {
            return this.pipe(source, destination, "http", origin, method, callback);
          }
          if (services[service].workers) {
            return this.pipe(source, destination, "worker", origin, method, callback);
          }
        }
        return false;
      };
      this.getFirstRemoteEndpoint = (services = this.services) => {
        let serviceInfo;
        for (const service in services) {
          if (services[service].rtc) {
            serviceInfo = services[service].rtc;
          }
          if (services[service].eventsources && !serviceInfo) {
            let keys2 = Object.keys(services[service].eventsources);
            if (keys2[0]) {
              if (this.services[service].eventsources[keys2[0]]?.sessions)
                serviceInfo = services[service].eventsources;
            }
          }
          if (services[service].sockets && !serviceInfo) {
            serviceInfo = services[service].sockets;
          }
          if (services[service].servers && !serviceInfo) {
            serviceInfo = services[service].servers;
          }
          if (services[service].workers && !serviceInfo) {
            serviceInfo = services[service].workers;
          }
        }
        let keys = Object.keys(serviceInfo);
        if (keys[0])
          return serviceInfo[keys[0]];
        return false;
      };
      this.STREAMLATEST = 0;
      this.STREAMALLLATEST = 1;
      this.streamSettings = {};
      this.streamFunctions = {
        allLatestValues: (prop, setting) => {
          let result = void 0;
          if (Array.isArray(prop)) {
            if (prop.length !== setting.lastRead) {
              result = prop.slice(setting.lastRead);
              setting.lastRead = prop.length;
            }
          } else if (typeof prop === "object") {
            result = {};
            for (const p in prop) {
              if (Array.isArray(prop[p])) {
                if (typeof setting === "number")
                  setting = { [p]: { lastRead: void 0 } };
                else if (!setting[p])
                  setting[p] = { lastRead: void 0 };
                if (prop[p].length !== setting[p].lastRead) {
                  result[p] = prop[p].slice(setting[p].lastRead);
                  setting[p].lastRead = prop[p].length;
                }
              } else {
                if (typeof setting === "number")
                  setting = { [p]: { lastRead: void 0 } };
                else if (!setting[p])
                  setting[p] = { lastRead: void 0 };
                if (setting[p].lastRead !== prop[p]) {
                  result[p] = prop[p];
                  setting[p].lastRead = prop[p];
                }
              }
            }
            if (Object.keys(result).length === 0)
              result = void 0;
          } else {
            if (setting.lastRead !== prop) {
              result = prop;
              setting.lastRead = prop;
            }
          }
          return result;
        },
        latestValue: (prop, setting) => {
          let result = void 0;
          if (Array.isArray(prop)) {
            if (prop.length !== setting.lastRead) {
              result = prop[prop.length - 1];
              setting.lastRead = prop.length;
            }
          } else if (typeof prop === "object") {
            result = {};
            for (const p in prop) {
              if (Array.isArray(prop[p])) {
                if (typeof setting === "number")
                  setting = { [p]: { lastRead: void 0 } };
                else if (!setting[p])
                  setting[p] = { lastRead: void 0 };
                if (prop[p].length !== setting[p].lastRead) {
                  result[p] = prop[p][prop[p].length - 1];
                  setting[p].lastRead = prop[p].length;
                }
              } else {
                if (typeof setting === "number")
                  setting = { [p]: { lastRead: void 0 } };
                else if (!setting[p])
                  setting[p] = { lastRead: void 0 };
                if (setting[p].lastRead !== prop[p]) {
                  result[p] = prop[p];
                  setting[p].lastRead = prop[p];
                }
              }
            }
          } else {
            if (setting.lastRead !== prop) {
              result = prop;
              setting.lastRead = prop;
            }
          }
          return result;
        }
      };
      this.setStreamFunc = (name2, key, callback = this.streamFunctions.allLatestValues) => {
        if (!this.streamSettings[name2].settings[key])
          this.streamSettings[name2].settings[key] = { lastRead: 0 };
        if (callback === this.STREAMLATEST)
          this.streamSettings[name2].settings[key].callback = this.streamFunctions.latestValue;
        else if (callback === this.STREAMALLLATEST)
          this.streamSettings[name2].settings[key].callback = this.streamFunctions.allLatestValues;
        else if (typeof callback === "string")
          this.streamSettings[name2].settings[key].callback = this.streamFunctions[callback];
        else if (typeof callback === "function")
          this.streamSettings[name2].settings[key].callback = callback;
        if (!this.streamSettings[name2].settings[key].callback)
          this.streamSettings[name2].settings[key].callback = this.streamFunctions.allLatestValues;
        return true;
      };
      this.addStreamFunc = (name2, callback = (data) => {
      }) => {
        this.streamFunctions[name2] = callback;
      };
      this.setStream = (object = {}, settings = {}, streamName = \`stream\${Math.floor(Math.random() * 1e10)}\`) => {
        if (settings.keys) {
          if (settings.keys.length === 0) {
            let k = Object.keys(object);
            if (k.length > 0) {
              settings.keys = Array.from(k);
            }
          }
        } else {
          settings.keys = Array.from(Object.keys(object));
        }
        this.streamSettings[streamName] = {
          object,
          settings
        };
        settings.keys.forEach((prop) => {
          if (settings[prop]?.callback)
            this.setStreamFunc(streamName, prop, settings[prop].callback);
          else
            this.setStreamFunc(streamName, prop, settings.callback);
        });
        return this.streamSettings[streamName];
      };
      this.removeStream = (streamName, key) => {
        if (streamName && !key)
          delete this.streamSettings[streamName];
        else if (key && this.streamSettings[streamName]?.settings?.keys) {
          let idx = this.streamSettings[streamName].settings.keys.indexOf(key);
          if (idx > -1)
            this.streamSettings[streamName].settings.keys.splice(idx, 1);
          if (this.streamSettings[streamName].settings[key])
            delete this.streamSettings[streamName].settings[key];
          return true;
        }
        return false;
      };
      this.updateStreamData = (streamName, data = {}) => {
        if (this.streamSettings[streamName]) {
          Object.assign(this.streamSettings[streamName].object, data);
          return this.streamSettings[streamName].object;
        }
        return false;
      };
      this.streamLoop = (connections, channel) => {
        let updateObj = {};
        for (const prop in this.streamSettings) {
          this.streamSettings[prop].settings.keys.forEach((key) => {
            if (this.streamSettings[prop].settings[key]) {
              let data = this.streamSettings[prop].settings[key].callback(this.streamSettings[prop].object[key], this.streamSettings[prop].settings[key]);
              if (data !== void 0)
                updateObj[key] = data;
            }
          });
        }
        if (connections) {
          this.sendAll(updateObj, connections, channel);
        }
        return updateObj;
      };
      this.receive = (message, service, ...args) => {
        if (service)
          for (const key in this.services) {
            if (key === service || this.services[key].name === service) {
              return this.services[key].receive(message, ...args);
            }
          }
        return this.service.receive(message, ...args);
      };
      this.transmit = (message, service, ...args) => {
        if (service)
          for (const key in this.services) {
            if (key === service || this.services[key].name === service) {
              return this.services[key].transmit(message, ...args);
            }
          }
        return this.service.transmit(message, ...args);
      };
      this.defaultRoutes = {
        getEndpointInfo: this.getEndpointInfo,
        pipeOnce: this.pipeOnce,
        pipeFastest: this.pipeFastest,
        setStream: this.setStream,
        removeStream: this.removeStream,
        updateStreamData: this.updateStreamData,
        addStreamFunc: this.addStreamFunc,
        setStreamFunc: this.setStreamFunc,
        sendAll: this.sendAll,
        streamLoop: {
          operator: this.streamLoop,
          loop: 10
        }
      };
      if (options && "loadDefaultRoutes" in options) {
        this.loadDefaultRoutes = options.loadDefaultRoutes;
      }
      if (this.loadDefaultRoutes)
        this.load(this.defaultRoutes, options?.linkServices, options?.includeClassName);
      if (Array.isArray(services)) {
        services.forEach((s) => this.load(s, options?.linkServices, options?.includeClassName));
      } else if (typeof services === "object") {
        Object.keys(services).forEach((s) => this.load(services[s], options?.linkServices, options?.includeClassName));
      }
    }
  };

  // ../GraphServiceRouter/services/worker/Worker.service.ts
  var import_web_worker = __toESM(require_browser());
  var WorkerService = class extends Service {
    constructor(options) {
      super(options);
      this.name = "worker";
      this.workers = {};
      this.threadRot = 0;
      this.addWorker = (options) => {
        let worker;
        if (options.url)
          worker = new import_web_worker.default(options.url);
        else
          worker = new import_web_worker.default(import_web_worker.default);
        if (!options._id)
          options._id = \`worker\${Math.floor(Math.random() * 1e15)}\`;
        let send = (message, transfer) => {
          return this.transmit(message, worker, transfer);
        };
        let request = (message, transfer, origin, method) => {
          return new Promise((res, rej) => {
            let callbackId = Math.random();
            let req = { route: "runRequest", args: [message, options._id, callbackId] };
            if (origin)
              req.origin = origin;
            if (method)
              req.method = method;
            let onmessage = (ev2) => {
              if (typeof ev2.data === "object") {
                if (ev2.data.callbackId === callbackId) {
                  worker.removeEventListener("message", onmessage);
                  res(ev2.data);
                }
              }
            };
            worker.addEventListener("message", onmessage);
            this.transmit(req, worker, transfer);
          });
        };
        if (!options.onmessage)
          options.onmessage = (ev2) => {
            let res = this.receive(ev2.data);
            this.setState({ [options._id]: res });
          };
        if (!options.onerror) {
          options.onerror = (ev2) => {
            console.error(ev2.data);
          };
        }
        worker.onmessage = options.onmessage;
        worker.onerror = options.onerror;
        this.workers[options._id] = {
          worker,
          send,
          request,
          ...options
        };
        return this.workers[options._id];
      };
      this.toObjectURL = (scriptTemplate) => {
        let blob = new Blob([scriptTemplate], { type: "text/javascript" });
        return URL.createObjectURL(blob);
      };
      this.transmit = (message, worker, transfer) => {
        if (worker instanceof import_web_worker.default || worker instanceof MessagePort) {
          worker.postMessage(message, transfer);
        } else if (typeof worker === "string") {
          if (this.workers[worker]) {
            if (this.workers[worker].port)
              this.workers[worker].port.postMessage(message, transfer);
            else if (this.workers[worker].worker)
              this.workers[worker].worker.postMessage(message, transfer);
          }
        } else {
          let keys = Object.keys(this.workers);
          this.workers[keys[this.threadRot]].worker.postMessage(message, transfer);
          this.threadRot++;
          if (this.threadRot === keys.length)
            this.threadRot = 0;
        }
        return message;
      };
      this.terminate = (worker) => {
        if (typeof worker === "string") {
          let obj = this.workers[worker];
          if (obj)
            delete this.workers[worker];
          worker = obj.worker;
        }
        if (worker instanceof import_web_worker.default) {
          worker.terminate();
          return true;
        }
        if (worker instanceof MessagePort) {
          worker.close();
          return true;
        }
        return false;
      };
      this.establishMessageChannel = (worker, worker2) => {
        if (typeof worker === "string") {
          if (this.workers[worker]) {
            worker = this.workers[worker].worker;
          }
        }
        if (typeof worker2 === "string") {
          if (this.workers[worker2]) {
            worker2 = this.workers[worker2].worker;
          }
        }
        if (worker instanceof import_web_worker.default) {
          let channel = new MessageChannel();
          let port1 = channel.port1;
          let port2 = channel.port2;
          let portId = \`port\${Math.floor(Math.random() * 1e15)}\`;
          worker.postMessage({ route: "recursivelyAssign", args: { workers: { _id: portId, port: port1 } } }, [port1]);
          if (worker2 instanceof import_web_worker.default) {
            worker2.postMessage({ route: "recursivelyAssign", args: { workers: { _id: portId, port: port2 } } }, [port2]);
          }
          return channel;
        }
        return false;
      };
      this.request = (message, worker, transfer, origin, method) => {
        return new Promise((res, rej) => {
          let callbackId = Math.random();
          let req = { route: "runRequest", args: message, callbackId };
          if (origin)
            req.origin = origin;
          if (method)
            req.method = method;
          let onmessage = (ev2) => {
            if (typeof ev2.data === "object") {
              if (ev2.data.callbackId === callbackId) {
                worker.removeEventListener("message", onmessage);
                res(ev2.data);
              }
            }
          };
          worker.addEventListener("message", onmessage);
          this.transmit(req, worker, transfer);
        });
      };
      this.runRequest = (message, worker, callbackId) => {
        let res = this.receive(message);
        if (typeof worker === "string" && this.workers[worker]) {
          if (this.workers[worker].port)
            worker = this.workers[worker].port;
          else
            worker = this.workers[worker].worker;
        }
        if (res instanceof Promise) {
          res.then((r) => {
            if (worker instanceof import_web_worker.default || worker instanceof MessagePort)
              worker.postMessage({ args: res, callbackId });
            else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope)
              globalThis.postMessage({ args: res, callbackId });
          });
        } else {
          if (worker instanceof import_web_worker.default || worker instanceof MessagePort)
            worker.postMessage({ args: res, callbackId });
          else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope)
            globalThis.postMessage({ args: res, callbackId });
        }
        return res;
      };
      this.routes = {
        addWorker: this.addWorker,
        toObjectURL: this.toObjectURL,
        request: this.request,
        runRequest: this.runRequest,
        establishMessageChannel: this.establishMessageChannel
      };
    }
  };

  // ../GraphServiceRouter/node_modules/gpujsutils/dist/index.esm.js
  var Xt = Object.create;
  var vt = Object.defineProperty;
  var Yt = Object.getOwnPropertyDescriptor;
  var Zt = Object.getOwnPropertyNames;
  var Jt = Object.getPrototypeOf;
  var Qt = Object.prototype.hasOwnProperty;
  var Re = ((M) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(M, { get: (I, $) => (typeof __require != "undefined" ? __require : I)[$] }) : M)(function(M) {
    if (typeof __require != "undefined")
      return __require.apply(this, arguments);
    throw new Error('Dynamic require of "' + M + '" is not supported');
  });
  var qt = (M, I) => () => (I || M((I = { exports: {} }).exports, I), I.exports);
  var ei = (M, I, $, o) => {
    if (I && typeof I == "object" || typeof I == "function")
      for (let y of Zt(I))
        !Qt.call(M, y) && y !== $ && vt(M, y, { get: () => I[y], enumerable: !(o = Yt(I, y)) || o.enumerable });
    return M;
  };
  var ti = (M, I, $) => ($ = M != null ? Xt(Jt(M)) : {}, ei(I || !M || !M.__esModule ? vt($, "default", { value: M, enumerable: true }) : $, M));
  var _t = qt((St, Ze) => {
    (function(M) {
      if (typeof St == "object" && typeof Ze < "u")
        Ze.exports = M();
      else if (typeof define == "function" && define.amd)
        define([], M);
      else {
        var I;
        typeof window < "u" ? I = window : typeof global < "u" ? I = global : typeof self < "u" ? I = self : I = this, M();
      }
    })(function() {
      var M, I, $;
      return function() {
        function o(y, E, p) {
          function g(n, s) {
            if (!E[n]) {
              if (!y[n]) {
                var t = typeof Re == "function" && Re;
                if (!s && t)
                  return t(n, true);
                if (f)
                  return f(n, true);
                var i = new Error("Cannot find module '" + n + "'");
                throw i.code = "MODULE_NOT_FOUND", i;
              }
              var u = E[n] = { exports: {} };
              y[n][0].call(u.exports, function(x2) {
                var w = y[n][1][x2];
                return g(w || x2);
              }, u, u.exports, o, y, E, p);
            }
            return E[n].exports;
          }
          for (var f = typeof Re == "function" && Re, l = 0; l < p.length; l++)
            g(p[l]);
          return g;
        }
        return o;
      }()({ 1: [function(o, y, E) {
        (function(p, g) {
          typeof E == "object" && typeof y < "u" ? g(E) : typeof M == "function" && M.amd ? M(["exports"], g) : (p = p || self, g(p.acorn = {}));
        })(this, function(p) {
          "use strict";
          var g = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, f = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", l = { 5: f, "5module": f + " export import", 6: f + " const class extends export import super" }, n = /^in(stanceof)?$/, s = "\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC", t = "\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F", i = new RegExp("[" + s + "]"), u = new RegExp("[" + s + t + "]");
          s = t = null;
          var x2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541], w = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];
          function m(e, r) {
            for (var d = 65536, _ = 0; _ < r.length; _ += 2) {
              if (d += r[_], d > e)
                return false;
              if (d += r[_ + 1], d >= e)
                return true;
            }
          }
          function S(e, r) {
            return e < 65 ? e === 36 : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && i.test(String.fromCharCode(e)) : r === false ? false : m(e, x2);
          }
          function v(e, r) {
            return e < 48 ? e === 36 : e < 58 ? true : e < 65 ? false : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && u.test(String.fromCharCode(e)) : r === false ? false : m(e, x2) || m(e, w);
          }
          var h = function(r, d) {
            d === void 0 && (d = {}), this.label = r, this.keyword = d.keyword, this.beforeExpr = !!d.beforeExpr, this.startsExpr = !!d.startsExpr, this.isLoop = !!d.isLoop, this.isAssign = !!d.isAssign, this.prefix = !!d.prefix, this.postfix = !!d.postfix, this.binop = d.binop || null, this.updateContext = null;
          };
          function b(e, r) {
            return new h(e, { beforeExpr: true, binop: r });
          }
          var T = { beforeExpr: true }, C = { startsExpr: true }, V = {};
          function c(e, r) {
            return r === void 0 && (r = {}), r.keyword = e, V[e] = new h(e, r);
          }
          var a = { num: new h("num", C), regexp: new h("regexp", C), string: new h("string", C), name: new h("name", C), eof: new h("eof"), bracketL: new h("[", { beforeExpr: true, startsExpr: true }), bracketR: new h("]"), braceL: new h("{", { beforeExpr: true, startsExpr: true }), braceR: new h("}"), parenL: new h("(", { beforeExpr: true, startsExpr: true }), parenR: new h(")"), comma: new h(",", T), semi: new h(";", T), colon: new h(":", T), dot: new h("."), question: new h("?", T), arrow: new h("=>", T), template: new h("template"), invalidTemplate: new h("invalidTemplate"), ellipsis: new h("...", T), backQuote: new h("\`", C), dollarBraceL: new h("\${", { beforeExpr: true, startsExpr: true }), eq: new h("=", { beforeExpr: true, isAssign: true }), assign: new h("_=", { beforeExpr: true, isAssign: true }), incDec: new h("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new h("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: b("||", 1), logicalAND: b("&&", 2), bitwiseOR: b("|", 3), bitwiseXOR: b("^", 4), bitwiseAND: b("&", 5), equality: b("==/!=/===/!==", 6), relational: b("</>/<=/>=", 7), bitShift: b("<</>>/>>>", 8), plusMin: new h("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: b("%", 10), star: b("*", 10), slash: b("/", 10), starstar: new h("**", { beforeExpr: true }), _break: c("break"), _case: c("case", T), _catch: c("catch"), _continue: c("continue"), _debugger: c("debugger"), _default: c("default", T), _do: c("do", { isLoop: true, beforeExpr: true }), _else: c("else", T), _finally: c("finally"), _for: c("for", { isLoop: true }), _function: c("function", C), _if: c("if"), _return: c("return", T), _switch: c("switch"), _throw: c("throw", T), _try: c("try"), _var: c("var"), _const: c("const"), _while: c("while", { isLoop: true }), _with: c("with"), _new: c("new", { beforeExpr: true, startsExpr: true }), _this: c("this", C), _super: c("super", C), _class: c("class", C), _extends: c("extends", T), _export: c("export"), _import: c("import", C), _null: c("null", C), _true: c("true", C), _false: c("false", C), _in: c("in", { beforeExpr: true, binop: 7 }), _instanceof: c("instanceof", { beforeExpr: true, binop: 7 }), _typeof: c("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: c("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: c("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, k = /\\r\\n?|\\n|\\u2028|\\u2029/, A = new RegExp(k.source, "g");
          function N(e, r) {
            return e === 10 || e === 13 || !r && (e === 8232 || e === 8233);
          }
          var F = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/, L = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g, K = Object.prototype, O = K.hasOwnProperty, X = K.toString;
          function B(e, r) {
            return O.call(e, r);
          }
          var P = Array.isArray || function(e) {
            return X.call(e) === "[object Array]";
          };
          function Y(e) {
            return new RegExp("^(?:" + e.replace(/ /g, "|") + ")$");
          }
          var J = function(r, d) {
            this.line = r, this.column = d;
          };
          J.prototype.offset = function(r) {
            return new J(this.line, this.column + r);
          };
          var q = function(r, d, _) {
            this.start = d, this.end = _, r.sourceFile !== null && (this.source = r.sourceFile);
          };
          function j(e, r) {
            for (var d = 1, _ = 0; ; ) {
              A.lastIndex = _;
              var D = A.exec(e);
              if (D && D.index < r)
                ++d, _ = D.index + D[0].length;
              else
                return new J(d, r - _);
            }
          }
          var U = { ecmaVersion: 10, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: false, allowHashBang: false, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false };
          function oe(e) {
            var r = {};
            for (var d in U)
              r[d] = e && B(e, d) ? e[d] : U[d];
            if (r.ecmaVersion >= 2015 && (r.ecmaVersion -= 2009), r.allowReserved == null && (r.allowReserved = r.ecmaVersion < 5), P(r.onToken)) {
              var _ = r.onToken;
              r.onToken = function(D) {
                return _.push(D);
              };
            }
            return P(r.onComment) && (r.onComment = Z(r, r.onComment)), r;
          }
          function Z(e, r) {
            return function(d, _, D, R, z, G) {
              var H = { type: d ? "Block" : "Line", value: _, start: D, end: R };
              e.locations && (H.loc = new q(this, z, G)), e.ranges && (H.range = [D, R]), r.push(H);
            };
          }
          var ee = 1, be = 2, Q = ee | be, ue = 4, he = 8, pe = 16, te = 32, re = 64, de = 128;
          function Te(e, r) {
            return be | (e ? ue : 0) | (r ? he : 0);
          }
          var Se = 0, Ce = 1, _e = 2, tt = 3, it = 4, nt = 5, le = function(r, d, _) {
            this.options = r = oe(r), this.sourceFile = r.sourceFile, this.keywords = Y(l[r.ecmaVersion >= 6 ? 6 : r.sourceType === "module" ? "5module" : 5]);
            var D = "";
            if (r.allowReserved !== true) {
              for (var R = r.ecmaVersion; !(D = g[R]); R--)
                ;
              r.sourceType === "module" && (D += " await");
            }
            this.reservedWords = Y(D);
            var z = (D ? D + " " : "") + g.strict;
            this.reservedWordsStrict = Y(z), this.reservedWordsStrictBind = Y(z + " " + g.strictBind), this.input = String(d), this.containsEsc = false, _ ? (this.pos = _, this.lineStart = this.input.lastIndexOf(\`
\`, _ - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(k).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = a.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = r.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && r.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(ee), this.regexpState = null;
          }, Ae = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true } };
          le.prototype.parse = function() {
            var r = this.options.program || this.startNode();
            return this.nextToken(), this.parseTopLevel(r);
          }, Ae.inFunction.get = function() {
            return (this.currentVarScope().flags & be) > 0;
          }, Ae.inGenerator.get = function() {
            return (this.currentVarScope().flags & he) > 0;
          }, Ae.inAsync.get = function() {
            return (this.currentVarScope().flags & ue) > 0;
          }, Ae.allowSuper.get = function() {
            return (this.currentThisScope().flags & re) > 0;
          }, Ae.allowDirectSuper.get = function() {
            return (this.currentThisScope().flags & de) > 0;
          }, Ae.treatFunctionsAsVar.get = function() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }, le.prototype.inNonArrowFunction = function() {
            return (this.currentThisScope().flags & be) > 0;
          }, le.extend = function() {
            for (var r = [], d = arguments.length; d--; )
              r[d] = arguments[d];
            for (var _ = this, D = 0; D < r.length; D++)
              _ = r[D](_);
            return _;
          }, le.parse = function(r, d) {
            return new this(d, r).parse();
          }, le.parseExpressionAt = function(r, d, _) {
            var D = new this(_, r, d);
            return D.nextToken(), D.parseExpression();
          }, le.tokenizer = function(r, d) {
            return new this(d, r);
          }, Object.defineProperties(le.prototype, Ae);
          var ge = le.prototype, Dt = /^(?:'((?:\\\\.|[^'])*?)'|"((?:\\\\.|[^"])*?)")/;
          ge.strictDirective = function(e) {
            for (; ; ) {
              L.lastIndex = e, e += L.exec(this.input)[0].length;
              var r = Dt.exec(this.input.slice(e));
              if (!r)
                return false;
              if ((r[1] || r[2]) === "use strict")
                return true;
              e += r[0].length, L.lastIndex = e, e += L.exec(this.input)[0].length, this.input[e] === ";" && e++;
            }
          }, ge.eat = function(e) {
            return this.type === e ? (this.next(), true) : false;
          }, ge.isContextual = function(e) {
            return this.type === a.name && this.value === e && !this.containsEsc;
          }, ge.eatContextual = function(e) {
            return this.isContextual(e) ? (this.next(), true) : false;
          }, ge.expectContextual = function(e) {
            this.eatContextual(e) || this.unexpected();
          }, ge.canInsertSemicolon = function() {
            return this.type === a.eof || this.type === a.braceR || k.test(this.input.slice(this.lastTokEnd, this.start));
          }, ge.insertSemicolon = function() {
            if (this.canInsertSemicolon())
              return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
          }, ge.semicolon = function() {
            !this.eat(a.semi) && !this.insertSemicolon() && this.unexpected();
          }, ge.afterTrailingComma = function(e, r) {
            if (this.type === e)
              return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), r || this.next(), true;
          }, ge.expect = function(e) {
            this.eat(e) || this.unexpected();
          }, ge.unexpected = function(e) {
            this.raise(e ?? this.start, "Unexpected token");
          };
          function Ve() {
            this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
          }
          ge.checkPatternErrors = function(e, r) {
            if (!!e) {
              e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
              var d = r ? e.parenthesizedAssign : e.parenthesizedBind;
              d > -1 && this.raiseRecoverable(d, "Parenthesized pattern");
            }
          }, ge.checkExpressionErrors = function(e, r) {
            if (!e)
              return false;
            var d = e.shorthandAssign, _ = e.doubleProto;
            if (!r)
              return d >= 0 || _ >= 0;
            d >= 0 && this.raise(d, "Shorthand property assignments are valid only in destructuring patterns"), _ >= 0 && this.raiseRecoverable(_, "Redefinition of __proto__ property");
          }, ge.checkYieldAwaitInDefaultParams = function() {
            this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
          }, ge.isSimpleAssignTarget = function(e) {
            return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
          };
          var ie = le.prototype;
          ie.parseTopLevel = function(e) {
            var r = {};
            for (e.body || (e.body = []); this.type !== a.eof; ) {
              var d = this.parseStatement(null, true, r);
              e.body.push(d);
            }
            if (this.inModule)
              for (var _ = 0, D = Object.keys(this.undefinedExports); _ < D.length; _ += 1) {
                var R = D[_];
                this.raiseRecoverable(this.undefinedExports[R].start, "Export '" + R + "' is not defined");
              }
            return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
          };
          var je = { kind: "loop" }, Ct = { kind: "switch" };
          ie.isLet = function(e) {
            if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
              return false;
            L.lastIndex = this.pos;
            var r = L.exec(this.input), d = this.pos + r[0].length, _ = this.input.charCodeAt(d);
            if (_ === 91)
              return true;
            if (e)
              return false;
            if (_ === 123)
              return true;
            if (S(_, true)) {
              for (var D = d + 1; v(this.input.charCodeAt(D), true); )
                ++D;
              var R = this.input.slice(d, D);
              if (!n.test(R))
                return true;
            }
            return false;
          }, ie.isAsyncFunction = function() {
            if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
              return false;
            L.lastIndex = this.pos;
            var e = L.exec(this.input), r = this.pos + e[0].length;
            return !k.test(this.input.slice(this.pos, r)) && this.input.slice(r, r + 8) === "function" && (r + 8 === this.input.length || !v(this.input.charAt(r + 8)));
          }, ie.parseStatement = function(e, r, d) {
            var _ = this.type, D = this.startNode(), R;
            switch (this.isLet(e) && (_ = a._var, R = "let"), _) {
              case a._break:
              case a._continue:
                return this.parseBreakContinueStatement(D, _.keyword);
              case a._debugger:
                return this.parseDebuggerStatement(D);
              case a._do:
                return this.parseDoStatement(D);
              case a._for:
                return this.parseForStatement(D);
              case a._function:
                return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(D, false, !e);
              case a._class:
                return e && this.unexpected(), this.parseClass(D, true);
              case a._if:
                return this.parseIfStatement(D);
              case a._return:
                return this.parseReturnStatement(D);
              case a._switch:
                return this.parseSwitchStatement(D);
              case a._throw:
                return this.parseThrowStatement(D);
              case a._try:
                return this.parseTryStatement(D);
              case a._const:
              case a._var:
                return R = R || this.value, e && R !== "var" && this.unexpected(), this.parseVarStatement(D, R);
              case a._while:
                return this.parseWhileStatement(D);
              case a._with:
                return this.parseWithStatement(D);
              case a.braceL:
                return this.parseBlock(true, D);
              case a.semi:
                return this.parseEmptyStatement(D);
              case a._export:
              case a._import:
                if (this.options.ecmaVersion > 10 && _ === a._import) {
                  L.lastIndex = this.pos;
                  var z = L.exec(this.input), G = this.pos + z[0].length, H = this.input.charCodeAt(G);
                  if (H === 40)
                    return this.parseExpressionStatement(D, this.parseExpression());
                }
                return this.options.allowImportExportEverywhere || (r || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), _ === a._import ? this.parseImport(D) : this.parseExport(D, d);
              default:
                if (this.isAsyncFunction())
                  return e && this.unexpected(), this.next(), this.parseFunctionStatement(D, true, !e);
                var ae = this.value, ye = this.parseExpression();
                return _ === a.name && ye.type === "Identifier" && this.eat(a.colon) ? this.parseLabeledStatement(D, ae, ye, e) : this.parseExpressionStatement(D, ye);
            }
          }, ie.parseBreakContinueStatement = function(e, r) {
            var d = r === "break";
            this.next(), this.eat(a.semi) || this.insertSemicolon() ? e.label = null : this.type !== a.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
            for (var _ = 0; _ < this.labels.length; ++_) {
              var D = this.labels[_];
              if ((e.label == null || D.name === e.label.name) && (D.kind != null && (d || D.kind === "loop") || e.label && d))
                break;
            }
            return _ === this.labels.length && this.raise(e.start, "Unsyntactic " + r), this.finishNode(e, d ? "BreakStatement" : "ContinueStatement");
          }, ie.parseDebuggerStatement = function(e) {
            return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
          }, ie.parseDoStatement = function(e) {
            return this.next(), this.labels.push(je), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(a._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(a.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
          }, ie.parseForStatement = function(e) {
            this.next();
            var r = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
            if (this.labels.push(je), this.enterScope(0), this.expect(a.parenL), this.type === a.semi)
              return r > -1 && this.unexpected(r), this.parseFor(e, null);
            var d = this.isLet();
            if (this.type === a._var || this.type === a._const || d) {
              var _ = this.startNode(), D = d ? "let" : this.value;
              return this.next(), this.parseVar(_, true, D), this.finishNode(_, "VariableDeclaration"), (this.type === a._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === a._in ? r > -1 && this.unexpected(r) : e.await = r > -1), this.parseForIn(e, _)) : (r > -1 && this.unexpected(r), this.parseFor(e, _));
            }
            var R = new Ve(), z = this.parseExpression(true, R);
            return this.type === a._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === a._in ? r > -1 && this.unexpected(r) : e.await = r > -1), this.toAssignable(z, false, R), this.checkLVal(z), this.parseForIn(e, z)) : (this.checkExpressionErrors(R, true), r > -1 && this.unexpected(r), this.parseFor(e, z));
          }, ie.parseFunctionStatement = function(e, r, d) {
            return this.next(), this.parseFunction(e, Le | (d ? 0 : He), false, r);
          }, ie.parseIfStatement = function(e) {
            return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(a._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
          }, ie.parseReturnStatement = function(e) {
            return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(a.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
          }, ie.parseSwitchStatement = function(e) {
            this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(a.braceL), this.labels.push(Ct), this.enterScope(0);
            for (var r, d = false; this.type !== a.braceR; )
              if (this.type === a._case || this.type === a._default) {
                var _ = this.type === a._case;
                r && this.finishNode(r, "SwitchCase"), e.cases.push(r = this.startNode()), r.consequent = [], this.next(), _ ? r.test = this.parseExpression() : (d && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), d = true, r.test = null), this.expect(a.colon);
              } else
                r || this.unexpected(), r.consequent.push(this.parseStatement(null));
            return this.exitScope(), r && this.finishNode(r, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
          }, ie.parseThrowStatement = function(e) {
            return this.next(), k.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
          };
          var Ft = [];
          ie.parseTryStatement = function(e) {
            if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === a._catch) {
              var r = this.startNode();
              if (this.next(), this.eat(a.parenL)) {
                r.param = this.parseBindingAtom();
                var d = r.param.type === "Identifier";
                this.enterScope(d ? te : 0), this.checkLVal(r.param, d ? it : _e), this.expect(a.parenR);
              } else
                this.options.ecmaVersion < 10 && this.unexpected(), r.param = null, this.enterScope(0);
              r.body = this.parseBlock(false), this.exitScope(), e.handler = this.finishNode(r, "CatchClause");
            }
            return e.finalizer = this.eat(a._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
          }, ie.parseVarStatement = function(e, r) {
            return this.next(), this.parseVar(e, false, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
          }, ie.parseWhileStatement = function(e) {
            return this.next(), e.test = this.parseParenExpression(), this.labels.push(je), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
          }, ie.parseWithStatement = function(e) {
            return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
          }, ie.parseEmptyStatement = function(e) {
            return this.next(), this.finishNode(e, "EmptyStatement");
          }, ie.parseLabeledStatement = function(e, r, d, _) {
            for (var D = 0, R = this.labels; D < R.length; D += 1) {
              var z = R[D];
              z.name === r && this.raise(d.start, "Label '" + r + "' is already declared");
            }
            for (var G = this.type.isLoop ? "loop" : this.type === a._switch ? "switch" : null, H = this.labels.length - 1; H >= 0; H--) {
              var ae = this.labels[H];
              if (ae.statementStart === e.start)
                ae.statementStart = this.start, ae.kind = G;
              else
                break;
            }
            return this.labels.push({ name: r, kind: G, statementStart: this.start }), e.body = this.parseStatement(_ ? _.indexOf("label") === -1 ? _ + "label" : _ : "label"), this.labels.pop(), e.label = d, this.finishNode(e, "LabeledStatement");
          }, ie.parseExpressionStatement = function(e, r) {
            return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
          }, ie.parseBlock = function(e, r) {
            for (e === void 0 && (e = true), r === void 0 && (r = this.startNode()), r.body = [], this.expect(a.braceL), e && this.enterScope(0); !this.eat(a.braceR); ) {
              var d = this.parseStatement(null);
              r.body.push(d);
            }
            return e && this.exitScope(), this.finishNode(r, "BlockStatement");
          }, ie.parseFor = function(e, r) {
            return e.init = r, this.expect(a.semi), e.test = this.type === a.semi ? null : this.parseExpression(), this.expect(a.semi), e.update = this.type === a.parenR ? null : this.parseExpression(), this.expect(a.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
          }, ie.parseForIn = function(e, r) {
            var d = this.type === a._in;
            return this.next(), r.type === "VariableDeclaration" && r.declarations[0].init != null && (!d || this.options.ecmaVersion < 8 || this.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") ? this.raise(r.start, (d ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : r.type === "AssignmentPattern" && this.raise(r.start, "Invalid left-hand side in for-loop"), e.left = r, e.right = d ? this.parseExpression() : this.parseMaybeAssign(), this.expect(a.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, d ? "ForInStatement" : "ForOfStatement");
          }, ie.parseVar = function(e, r, d) {
            for (e.declarations = [], e.kind = d; ; ) {
              var _ = this.startNode();
              if (this.parseVarId(_, d), this.eat(a.eq) ? _.init = this.parseMaybeAssign(r) : d === "const" && !(this.type === a._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : _.id.type !== "Identifier" && !(r && (this.type === a._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : _.init = null, e.declarations.push(this.finishNode(_, "VariableDeclarator")), !this.eat(a.comma))
                break;
            }
            return e;
          }, ie.parseVarId = function(e, r) {
            e.id = this.parseBindingAtom(), this.checkLVal(e.id, r === "var" ? Ce : _e, false);
          };
          var Le = 1, He = 2, st = 4;
          ie.parseFunction = function(e, r, d, _) {
            this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !_) && (this.type === a.star && r & He && this.unexpected(), e.generator = this.eat(a.star)), this.options.ecmaVersion >= 8 && (e.async = !!_), r & Le && (e.id = r & st && this.type !== a.name ? null : this.parseIdent(), e.id && !(r & He) && this.checkLVal(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? Ce : _e : tt));
            var D = this.yieldPos, R = this.awaitPos, z = this.awaitIdentPos;
            return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Te(e.async, e.generator)), r & Le || (e.id = this.type === a.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, d, false), this.yieldPos = D, this.awaitPos = R, this.awaitIdentPos = z, this.finishNode(e, r & Le ? "FunctionDeclaration" : "FunctionExpression");
          }, ie.parseFunctionParams = function(e) {
            this.expect(a.parenL), e.params = this.parseBindingList(a.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
          }, ie.parseClass = function(e, r) {
            this.next();
            var d = this.strict;
            this.strict = true, this.parseClassId(e, r), this.parseClassSuper(e);
            var _ = this.startNode(), D = false;
            for (_.body = [], this.expect(a.braceL); !this.eat(a.braceR); ) {
              var R = this.parseClassElement(e.superClass !== null);
              R && (_.body.push(R), R.type === "MethodDefinition" && R.kind === "constructor" && (D && this.raise(R.start, "Duplicate constructor in the same class"), D = true));
            }
            return e.body = this.finishNode(_, "ClassBody"), this.strict = d, this.finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
          }, ie.parseClassElement = function(e) {
            var r = this;
            if (this.eat(a.semi))
              return null;
            var d = this.startNode(), _ = function(H, ae) {
              ae === void 0 && (ae = false);
              var ye = r.start, Ie = r.startLoc;
              return r.eatContextual(H) ? r.type !== a.parenL && (!ae || !r.canInsertSemicolon()) ? true : (d.key && r.unexpected(), d.computed = false, d.key = r.startNodeAt(ye, Ie), d.key.name = H, r.finishNode(d.key, "Identifier"), false) : false;
            };
            d.kind = "method", d.static = _("static");
            var D = this.eat(a.star), R = false;
            D || (this.options.ecmaVersion >= 8 && _("async", true) ? (R = true, D = this.options.ecmaVersion >= 9 && this.eat(a.star)) : _("get") ? d.kind = "get" : _("set") && (d.kind = "set")), d.key || this.parsePropertyName(d);
            var z = d.key, G = false;
            return !d.computed && !d.static && (z.type === "Identifier" && z.name === "constructor" || z.type === "Literal" && z.value === "constructor") ? (d.kind !== "method" && this.raise(z.start, "Constructor can't have get/set modifier"), D && this.raise(z.start, "Constructor can't be a generator"), R && this.raise(z.start, "Constructor can't be an async method"), d.kind = "constructor", G = e) : d.static && z.type === "Identifier" && z.name === "prototype" && this.raise(z.start, "Classes may not have a static property named prototype"), this.parseClassMethod(d, D, R, G), d.kind === "get" && d.value.params.length !== 0 && this.raiseRecoverable(d.value.start, "getter should have no params"), d.kind === "set" && d.value.params.length !== 1 && this.raiseRecoverable(d.value.start, "setter should have exactly one param"), d.kind === "set" && d.value.params[0].type === "RestElement" && this.raiseRecoverable(d.value.params[0].start, "Setter cannot use rest params"), d;
          }, ie.parseClassMethod = function(e, r, d, _) {
            return e.value = this.parseMethod(r, d, _), this.finishNode(e, "MethodDefinition");
          }, ie.parseClassId = function(e, r) {
            this.type === a.name ? (e.id = this.parseIdent(), r && this.checkLVal(e.id, _e, false)) : (r === true && this.unexpected(), e.id = null);
          }, ie.parseClassSuper = function(e) {
            e.superClass = this.eat(a._extends) ? this.parseExprSubscripts() : null;
          }, ie.parseExport = function(e, r) {
            if (this.next(), this.eat(a.star))
              return this.expectContextual("from"), this.type !== a.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
            if (this.eat(a._default)) {
              this.checkExport(r, "default", this.lastTokStart);
              var d;
              if (this.type === a._function || (d = this.isAsyncFunction())) {
                var _ = this.startNode();
                this.next(), d && this.next(), e.declaration = this.parseFunction(_, Le | st, false, d);
              } else if (this.type === a._class) {
                var D = this.startNode();
                e.declaration = this.parseClass(D, "nullableID");
              } else
                e.declaration = this.parseMaybeAssign(), this.semicolon();
              return this.finishNode(e, "ExportDefaultDeclaration");
            }
            if (this.shouldParseExportStatement())
              e.declaration = this.parseStatement(null), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(r, e.declaration.declarations) : this.checkExport(r, e.declaration.id.name, e.declaration.id.start), e.specifiers = [], e.source = null;
            else {
              if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(r), this.eatContextual("from"))
                this.type !== a.string && this.unexpected(), e.source = this.parseExprAtom();
              else {
                for (var R = 0, z = e.specifiers; R < z.length; R += 1) {
                  var G = z[R];
                  this.checkUnreserved(G.local), this.checkLocalExport(G.local);
                }
                e.source = null;
              }
              this.semicolon();
            }
            return this.finishNode(e, "ExportNamedDeclaration");
          }, ie.checkExport = function(e, r, d) {
            !e || (B(e, r) && this.raiseRecoverable(d, "Duplicate export '" + r + "'"), e[r] = true);
          }, ie.checkPatternExport = function(e, r) {
            var d = r.type;
            if (d === "Identifier")
              this.checkExport(e, r.name, r.start);
            else if (d === "ObjectPattern")
              for (var _ = 0, D = r.properties; _ < D.length; _ += 1) {
                var R = D[_];
                this.checkPatternExport(e, R);
              }
            else if (d === "ArrayPattern")
              for (var z = 0, G = r.elements; z < G.length; z += 1) {
                var H = G[z];
                H && this.checkPatternExport(e, H);
              }
            else
              d === "Property" ? this.checkPatternExport(e, r.value) : d === "AssignmentPattern" ? this.checkPatternExport(e, r.left) : d === "RestElement" ? this.checkPatternExport(e, r.argument) : d === "ParenthesizedExpression" && this.checkPatternExport(e, r.expression);
          }, ie.checkVariableExport = function(e, r) {
            if (!!e)
              for (var d = 0, _ = r; d < _.length; d += 1) {
                var D = _[d];
                this.checkPatternExport(e, D.id);
              }
          }, ie.shouldParseExportStatement = function() {
            return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
          }, ie.parseExportSpecifiers = function(e) {
            var r = [], d = true;
            for (this.expect(a.braceL); !this.eat(a.braceR); ) {
              if (d)
                d = false;
              else if (this.expect(a.comma), this.afterTrailingComma(a.braceR))
                break;
              var _ = this.startNode();
              _.local = this.parseIdent(true), _.exported = this.eatContextual("as") ? this.parseIdent(true) : _.local, this.checkExport(e, _.exported.name, _.exported.start), r.push(this.finishNode(_, "ExportSpecifier"));
            }
            return r;
          }, ie.parseImport = function(e) {
            return this.next(), this.type === a.string ? (e.specifiers = Ft, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === a.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
          }, ie.parseImportSpecifiers = function() {
            var e = [], r = true;
            if (this.type === a.name) {
              var d = this.startNode();
              if (d.local = this.parseIdent(), this.checkLVal(d.local, _e), e.push(this.finishNode(d, "ImportDefaultSpecifier")), !this.eat(a.comma))
                return e;
            }
            if (this.type === a.star) {
              var _ = this.startNode();
              return this.next(), this.expectContextual("as"), _.local = this.parseIdent(), this.checkLVal(_.local, _e), e.push(this.finishNode(_, "ImportNamespaceSpecifier")), e;
            }
            for (this.expect(a.braceL); !this.eat(a.braceR); ) {
              if (r)
                r = false;
              else if (this.expect(a.comma), this.afterTrailingComma(a.braceR))
                break;
              var D = this.startNode();
              D.imported = this.parseIdent(true), this.eatContextual("as") ? D.local = this.parseIdent() : (this.checkUnreserved(D.imported), D.local = D.imported), this.checkLVal(D.local, _e), e.push(this.finishNode(D, "ImportSpecifier"));
            }
            return e;
          }, ie.adaptDirectivePrologue = function(e) {
            for (var r = 0; r < e.length && this.isDirectiveCandidate(e[r]); ++r)
              e[r].directive = e[r].expression.raw.slice(1, -1);
          }, ie.isDirectiveCandidate = function(e) {
            return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && (this.input[e.start] === '"' || this.input[e.start] === "'");
          };
          var we = le.prototype;
          we.toAssignable = function(e, r, d) {
            if (this.options.ecmaVersion >= 6 && e)
              switch (e.type) {
                case "Identifier":
                  this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
                  break;
                case "ObjectPattern":
                case "ArrayPattern":
                case "RestElement":
                  break;
                case "ObjectExpression":
                  e.type = "ObjectPattern", d && this.checkPatternErrors(d, true);
                  for (var _ = 0, D = e.properties; _ < D.length; _ += 1) {
                    var R = D[_];
                    this.toAssignable(R, r), R.type === "RestElement" && (R.argument.type === "ArrayPattern" || R.argument.type === "ObjectPattern") && this.raise(R.argument.start, "Unexpected token");
                  }
                  break;
                case "Property":
                  e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, r);
                  break;
                case "ArrayExpression":
                  e.type = "ArrayPattern", d && this.checkPatternErrors(d, true), this.toAssignableList(e.elements, r);
                  break;
                case "SpreadElement":
                  e.type = "RestElement", this.toAssignable(e.argument, r), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
                  break;
                case "AssignmentExpression":
                  e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, r);
                case "AssignmentPattern":
                  break;
                case "ParenthesizedExpression":
                  this.toAssignable(e.expression, r, d);
                  break;
                case "MemberExpression":
                  if (!r)
                    break;
                default:
                  this.raise(e.start, "Assigning to rvalue");
              }
            else
              d && this.checkPatternErrors(d, true);
            return e;
          }, we.toAssignableList = function(e, r) {
            for (var d = e.length, _ = 0; _ < d; _++) {
              var D = e[_];
              D && this.toAssignable(D, r);
            }
            if (d) {
              var R = e[d - 1];
              this.options.ecmaVersion === 6 && r && R && R.type === "RestElement" && R.argument.type !== "Identifier" && this.unexpected(R.argument.start);
            }
            return e;
          }, we.parseSpread = function(e) {
            var r = this.startNode();
            return this.next(), r.argument = this.parseMaybeAssign(false, e), this.finishNode(r, "SpreadElement");
          }, we.parseRestBinding = function() {
            var e = this.startNode();
            return this.next(), this.options.ecmaVersion === 6 && this.type !== a.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
          }, we.parseBindingAtom = function() {
            if (this.options.ecmaVersion >= 6)
              switch (this.type) {
                case a.bracketL:
                  var e = this.startNode();
                  return this.next(), e.elements = this.parseBindingList(a.bracketR, true, true), this.finishNode(e, "ArrayPattern");
                case a.braceL:
                  return this.parseObj(true);
              }
            return this.parseIdent();
          }, we.parseBindingList = function(e, r, d) {
            for (var _ = [], D = true; !this.eat(e); )
              if (D ? D = false : this.expect(a.comma), r && this.type === a.comma)
                _.push(null);
              else {
                if (d && this.afterTrailingComma(e))
                  break;
                if (this.type === a.ellipsis) {
                  var R = this.parseRestBinding();
                  this.parseBindingListItem(R), _.push(R), this.type === a.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e);
                  break;
                } else {
                  var z = this.parseMaybeDefault(this.start, this.startLoc);
                  this.parseBindingListItem(z), _.push(z);
                }
              }
            return _;
          }, we.parseBindingListItem = function(e) {
            return e;
          }, we.parseMaybeDefault = function(e, r, d) {
            if (d = d || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(a.eq))
              return d;
            var _ = this.startNodeAt(e, r);
            return _.left = d, _.right = this.parseMaybeAssign(), this.finishNode(_, "AssignmentPattern");
          }, we.checkLVal = function(e, r, d) {
            switch (r === void 0 && (r = Se), e.type) {
              case "Identifier":
                r === _e && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (r ? "Binding " : "Assigning to ") + e.name + " in strict mode"), d && (B(d, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), d[e.name] = true), r !== Se && r !== nt && this.declareName(e.name, r, e.start);
                break;
              case "MemberExpression":
                r && this.raiseRecoverable(e.start, "Binding member expression");
                break;
              case "ObjectPattern":
                for (var _ = 0, D = e.properties; _ < D.length; _ += 1) {
                  var R = D[_];
                  this.checkLVal(R, r, d);
                }
                break;
              case "Property":
                this.checkLVal(e.value, r, d);
                break;
              case "ArrayPattern":
                for (var z = 0, G = e.elements; z < G.length; z += 1) {
                  var H = G[z];
                  H && this.checkLVal(H, r, d);
                }
                break;
              case "AssignmentPattern":
                this.checkLVal(e.left, r, d);
                break;
              case "RestElement":
                this.checkLVal(e.argument, r, d);
                break;
              case "ParenthesizedExpression":
                this.checkLVal(e.expression, r, d);
                break;
              default:
                this.raise(e.start, (r ? "Binding" : "Assigning to") + " rvalue");
            }
          };
          var ne = le.prototype;
          ne.checkPropClash = function(e, r, d) {
            if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
              var _ = e.key, D;
              switch (_.type) {
                case "Identifier":
                  D = _.name;
                  break;
                case "Literal":
                  D = String(_.value);
                  break;
                default:
                  return;
              }
              var R = e.kind;
              if (this.options.ecmaVersion >= 6) {
                D === "__proto__" && R === "init" && (r.proto && (d ? d.doubleProto < 0 && (d.doubleProto = _.start) : this.raiseRecoverable(_.start, "Redefinition of __proto__ property")), r.proto = true);
                return;
              }
              D = "$" + D;
              var z = r[D];
              if (z) {
                var G;
                R === "init" ? G = this.strict && z.init || z.get || z.set : G = z.init || z[R], G && this.raiseRecoverable(_.start, "Redefinition of property");
              } else
                z = r[D] = { init: false, get: false, set: false };
              z[R] = true;
            }
          }, ne.parseExpression = function(e, r) {
            var d = this.start, _ = this.startLoc, D = this.parseMaybeAssign(e, r);
            if (this.type === a.comma) {
              var R = this.startNodeAt(d, _);
              for (R.expressions = [D]; this.eat(a.comma); )
                R.expressions.push(this.parseMaybeAssign(e, r));
              return this.finishNode(R, "SequenceExpression");
            }
            return D;
          }, ne.parseMaybeAssign = function(e, r, d) {
            if (this.isContextual("yield")) {
              if (this.inGenerator)
                return this.parseYield(e);
              this.exprAllowed = false;
            }
            var _ = false, D = -1, R = -1;
            r ? (D = r.parenthesizedAssign, R = r.trailingComma, r.parenthesizedAssign = r.trailingComma = -1) : (r = new Ve(), _ = true);
            var z = this.start, G = this.startLoc;
            (this.type === a.parenL || this.type === a.name) && (this.potentialArrowAt = this.start);
            var H = this.parseMaybeConditional(e, r);
            if (d && (H = d.call(this, H, z, G)), this.type.isAssign) {
              var ae = this.startNodeAt(z, G);
              return ae.operator = this.value, ae.left = this.type === a.eq ? this.toAssignable(H, false, r) : H, _ || (r.parenthesizedAssign = r.trailingComma = r.doubleProto = -1), r.shorthandAssign >= ae.left.start && (r.shorthandAssign = -1), this.checkLVal(H), this.next(), ae.right = this.parseMaybeAssign(e), this.finishNode(ae, "AssignmentExpression");
            } else
              _ && this.checkExpressionErrors(r, true);
            return D > -1 && (r.parenthesizedAssign = D), R > -1 && (r.trailingComma = R), H;
          }, ne.parseMaybeConditional = function(e, r) {
            var d = this.start, _ = this.startLoc, D = this.parseExprOps(e, r);
            if (this.checkExpressionErrors(r))
              return D;
            if (this.eat(a.question)) {
              var R = this.startNodeAt(d, _);
              return R.test = D, R.consequent = this.parseMaybeAssign(), this.expect(a.colon), R.alternate = this.parseMaybeAssign(e), this.finishNode(R, "ConditionalExpression");
            }
            return D;
          }, ne.parseExprOps = function(e, r) {
            var d = this.start, _ = this.startLoc, D = this.parseMaybeUnary(r, false);
            return this.checkExpressionErrors(r) || D.start === d && D.type === "ArrowFunctionExpression" ? D : this.parseExprOp(D, d, _, -1, e);
          }, ne.parseExprOp = function(e, r, d, _, D) {
            var R = this.type.binop;
            if (R != null && (!D || this.type !== a._in) && R > _) {
              var z = this.type === a.logicalOR || this.type === a.logicalAND, G = this.value;
              this.next();
              var H = this.start, ae = this.startLoc, ye = this.parseExprOp(this.parseMaybeUnary(null, false), H, ae, R, D), Ie = this.buildBinary(r, d, e, ye, G, z);
              return this.parseExprOp(Ie, r, d, _, D);
            }
            return e;
          }, ne.buildBinary = function(e, r, d, _, D, R) {
            var z = this.startNodeAt(e, r);
            return z.left = d, z.operator = D, z.right = _, this.finishNode(z, R ? "LogicalExpression" : "BinaryExpression");
          }, ne.parseMaybeUnary = function(e, r) {
            var d = this.start, _ = this.startLoc, D;
            if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
              D = this.parseAwait(), r = true;
            else if (this.type.prefix) {
              var R = this.startNode(), z = this.type === a.incDec;
              R.operator = this.value, R.prefix = true, this.next(), R.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e, true), z ? this.checkLVal(R.argument) : this.strict && R.operator === "delete" && R.argument.type === "Identifier" ? this.raiseRecoverable(R.start, "Deleting local variable in strict mode") : r = true, D = this.finishNode(R, z ? "UpdateExpression" : "UnaryExpression");
            } else {
              if (D = this.parseExprSubscripts(e), this.checkExpressionErrors(e))
                return D;
              for (; this.type.postfix && !this.canInsertSemicolon(); ) {
                var G = this.startNodeAt(d, _);
                G.operator = this.value, G.prefix = false, G.argument = D, this.checkLVal(D), this.next(), D = this.finishNode(G, "UpdateExpression");
              }
            }
            return !r && this.eat(a.starstar) ? this.buildBinary(d, _, D, this.parseMaybeUnary(null, false), "**", false) : D;
          }, ne.parseExprSubscripts = function(e) {
            var r = this.start, d = this.startLoc, _ = this.parseExprAtom(e);
            if (_.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
              return _;
            var D = this.parseSubscripts(_, r, d);
            return e && D.type === "MemberExpression" && (e.parenthesizedAssign >= D.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= D.start && (e.parenthesizedBind = -1)), D;
          }, ne.parseSubscripts = function(e, r, d, _) {
            for (var D = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && this.input.slice(e.start, e.end) === "async"; ; ) {
              var R = this.parseSubscript(e, r, d, _, D);
              if (R === e || R.type === "ArrowFunctionExpression")
                return R;
              e = R;
            }
          }, ne.parseSubscript = function(e, r, d, _, D) {
            var R = this.eat(a.bracketL);
            if (R || this.eat(a.dot)) {
              var z = this.startNodeAt(r, d);
              z.object = e, z.property = R ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), z.computed = !!R, R && this.expect(a.bracketR), e = this.finishNode(z, "MemberExpression");
            } else if (!_ && this.eat(a.parenL)) {
              var G = new Ve(), H = this.yieldPos, ae = this.awaitPos, ye = this.awaitIdentPos;
              this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
              var Ie = this.parseExprList(a.parenR, this.options.ecmaVersion >= 8, false, G);
              if (D && !this.canInsertSemicolon() && this.eat(a.arrow))
                return this.checkPatternErrors(G, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = H, this.awaitPos = ae, this.awaitIdentPos = ye, this.parseArrowExpression(this.startNodeAt(r, d), Ie, true);
              this.checkExpressionErrors(G, true), this.yieldPos = H || this.yieldPos, this.awaitPos = ae || this.awaitPos, this.awaitIdentPos = ye || this.awaitIdentPos;
              var Fe = this.startNodeAt(r, d);
              Fe.callee = e, Fe.arguments = Ie, e = this.finishNode(Fe, "CallExpression");
            } else if (this.type === a.backQuote) {
              var De = this.startNodeAt(r, d);
              De.tag = e, De.quasi = this.parseTemplate({ isTagged: true }), e = this.finishNode(De, "TaggedTemplateExpression");
            }
            return e;
          }, ne.parseExprAtom = function(e) {
            this.type === a.slash && this.readRegexp();
            var r, d = this.potentialArrowAt === this.start;
            switch (this.type) {
              case a._super:
                return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === a.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== a.dot && this.type !== a.bracketL && this.type !== a.parenL && this.unexpected(), this.finishNode(r, "Super");
              case a._this:
                return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
              case a.name:
                var _ = this.start, D = this.startLoc, R = this.containsEsc, z = this.parseIdent(false);
                if (this.options.ecmaVersion >= 8 && !R && z.name === "async" && !this.canInsertSemicolon() && this.eat(a._function))
                  return this.parseFunction(this.startNodeAt(_, D), 0, false, true);
                if (d && !this.canInsertSemicolon()) {
                  if (this.eat(a.arrow))
                    return this.parseArrowExpression(this.startNodeAt(_, D), [z], false);
                  if (this.options.ecmaVersion >= 8 && z.name === "async" && this.type === a.name && !R)
                    return z = this.parseIdent(false), (this.canInsertSemicolon() || !this.eat(a.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(_, D), [z], true);
                }
                return z;
              case a.regexp:
                var G = this.value;
                return r = this.parseLiteral(G.value), r.regex = { pattern: G.pattern, flags: G.flags }, r;
              case a.num:
              case a.string:
                return this.parseLiteral(this.value);
              case a._null:
              case a._true:
              case a._false:
                return r = this.startNode(), r.value = this.type === a._null ? null : this.type === a._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal");
              case a.parenL:
                var H = this.start, ae = this.parseParenAndDistinguishExpression(d);
                return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(ae) && (e.parenthesizedAssign = H), e.parenthesizedBind < 0 && (e.parenthesizedBind = H)), ae;
              case a.bracketL:
                return r = this.startNode(), this.next(), r.elements = this.parseExprList(a.bracketR, true, true, e), this.finishNode(r, "ArrayExpression");
              case a.braceL:
                return this.parseObj(false, e);
              case a._function:
                return r = this.startNode(), this.next(), this.parseFunction(r, 0);
              case a._class:
                return this.parseClass(this.startNode(), false);
              case a._new:
                return this.parseNew();
              case a.backQuote:
                return this.parseTemplate();
              case a._import:
                return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
              default:
                this.unexpected();
            }
          }, ne.parseExprImport = function() {
            var e = this.startNode();
            switch (this.next(), this.type) {
              case a.parenL:
                return this.parseDynamicImport(e);
              default:
                this.unexpected();
            }
          }, ne.parseDynamicImport = function(e) {
            if (this.next(), e.source = this.parseMaybeAssign(), !this.eat(a.parenR)) {
              var r = this.start;
              this.eat(a.comma) && this.eat(a.parenR) ? this.raiseRecoverable(r, "Trailing comma is not allowed in import()") : this.unexpected(r);
            }
            return this.finishNode(e, "ImportExpression");
          }, ne.parseLiteral = function(e) {
            var r = this.startNode();
            return r.value = e, r.raw = this.input.slice(this.start, this.end), r.raw.charCodeAt(r.raw.length - 1) === 110 && (r.bigint = r.raw.slice(0, -1)), this.next(), this.finishNode(r, "Literal");
          }, ne.parseParenExpression = function() {
            this.expect(a.parenL);
            var e = this.parseExpression();
            return this.expect(a.parenR), e;
          }, ne.parseParenAndDistinguishExpression = function(e) {
            var r = this.start, d = this.startLoc, _, D = this.options.ecmaVersion >= 8;
            if (this.options.ecmaVersion >= 6) {
              this.next();
              var R = this.start, z = this.startLoc, G = [], H = true, ae = false, ye = new Ve(), Ie = this.yieldPos, Fe = this.awaitPos, De;
              for (this.yieldPos = 0, this.awaitPos = 0; this.type !== a.parenR; )
                if (H ? H = false : this.expect(a.comma), D && this.afterTrailingComma(a.parenR, true)) {
                  ae = true;
                  break;
                } else if (this.type === a.ellipsis) {
                  De = this.start, G.push(this.parseParenItem(this.parseRestBinding())), this.type === a.comma && this.raise(this.start, "Comma is not permitted after the rest element");
                  break;
                } else
                  G.push(this.parseMaybeAssign(false, ye, this.parseParenItem));
              var jt = this.start, Ht = this.startLoc;
              if (this.expect(a.parenR), e && !this.canInsertSemicolon() && this.eat(a.arrow))
                return this.checkPatternErrors(ye, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = Ie, this.awaitPos = Fe, this.parseParenArrowList(r, d, G);
              (!G.length || ae) && this.unexpected(this.lastTokStart), De && this.unexpected(De), this.checkExpressionErrors(ye, true), this.yieldPos = Ie || this.yieldPos, this.awaitPos = Fe || this.awaitPos, G.length > 1 ? (_ = this.startNodeAt(R, z), _.expressions = G, this.finishNodeAt(_, "SequenceExpression", jt, Ht)) : _ = G[0];
            } else
              _ = this.parseParenExpression();
            if (this.options.preserveParens) {
              var Tt = this.startNodeAt(r, d);
              return Tt.expression = _, this.finishNode(Tt, "ParenthesizedExpression");
            } else
              return _;
          }, ne.parseParenItem = function(e) {
            return e;
          }, ne.parseParenArrowList = function(e, r, d) {
            return this.parseArrowExpression(this.startNodeAt(e, r), d);
          };
          var $t = [];
          ne.parseNew = function() {
            this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
            var e = this.startNode(), r = this.parseIdent(true);
            if (this.options.ecmaVersion >= 6 && this.eat(a.dot)) {
              e.meta = r;
              var d = this.containsEsc;
              return e.property = this.parseIdent(true), (e.property.name !== "target" || d) && this.raiseRecoverable(e.property.start, "The only valid meta property for new is new.target"), this.inNonArrowFunction() || this.raiseRecoverable(e.start, "new.target can only be used in functions"), this.finishNode(e, "MetaProperty");
            }
            var _ = this.start, D = this.startLoc, R = this.type === a._import;
            return e.callee = this.parseSubscripts(this.parseExprAtom(), _, D, true), R && e.callee.type === "ImportExpression" && this.raise(_, "Cannot use new with import()"), this.eat(a.parenL) ? e.arguments = this.parseExprList(a.parenR, this.options.ecmaVersion >= 8, false) : e.arguments = $t, this.finishNode(e, "NewExpression");
          }, ne.parseTemplateElement = function(e) {
            var r = e.isTagged, d = this.startNode();
            return this.type === a.invalidTemplate ? (r || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), d.value = { raw: this.value, cooked: null }) : d.value = { raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \`
\`), cooked: this.value }, this.next(), d.tail = this.type === a.backQuote, this.finishNode(d, "TemplateElement");
          }, ne.parseTemplate = function(e) {
            e === void 0 && (e = {});
            var r = e.isTagged;
            r === void 0 && (r = false);
            var d = this.startNode();
            this.next(), d.expressions = [];
            var _ = this.parseTemplateElement({ isTagged: r });
            for (d.quasis = [_]; !_.tail; )
              this.type === a.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(a.dollarBraceL), d.expressions.push(this.parseExpression()), this.expect(a.braceR), d.quasis.push(_ = this.parseTemplateElement({ isTagged: r }));
            return this.next(), this.finishNode(d, "TemplateLiteral");
          }, ne.isAsyncProp = function(e) {
            return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === a.name || this.type === a.num || this.type === a.string || this.type === a.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === a.star) && !k.test(this.input.slice(this.lastTokEnd, this.start));
          }, ne.parseObj = function(e, r) {
            var d = this.startNode(), _ = true, D = {};
            for (d.properties = [], this.next(); !this.eat(a.braceR); ) {
              if (_)
                _ = false;
              else if (this.expect(a.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(a.braceR))
                break;
              var R = this.parseProperty(e, r);
              e || this.checkPropClash(R, D, r), d.properties.push(R);
            }
            return this.finishNode(d, e ? "ObjectPattern" : "ObjectExpression");
          }, ne.parseProperty = function(e, r) {
            var d = this.startNode(), _, D, R, z;
            if (this.options.ecmaVersion >= 9 && this.eat(a.ellipsis))
              return e ? (d.argument = this.parseIdent(false), this.type === a.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(d, "RestElement")) : (this.type === a.parenL && r && (r.parenthesizedAssign < 0 && (r.parenthesizedAssign = this.start), r.parenthesizedBind < 0 && (r.parenthesizedBind = this.start)), d.argument = this.parseMaybeAssign(false, r), this.type === a.comma && r && r.trailingComma < 0 && (r.trailingComma = this.start), this.finishNode(d, "SpreadElement"));
            this.options.ecmaVersion >= 6 && (d.method = false, d.shorthand = false, (e || r) && (R = this.start, z = this.startLoc), e || (_ = this.eat(a.star)));
            var G = this.containsEsc;
            return this.parsePropertyName(d), !e && !G && this.options.ecmaVersion >= 8 && !_ && this.isAsyncProp(d) ? (D = true, _ = this.options.ecmaVersion >= 9 && this.eat(a.star), this.parsePropertyName(d, r)) : D = false, this.parsePropertyValue(d, e, _, D, R, z, r, G), this.finishNode(d, "Property");
          }, ne.parsePropertyValue = function(e, r, d, _, D, R, z, G) {
            if ((d || _) && this.type === a.colon && this.unexpected(), this.eat(a.colon))
              e.value = r ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, z), e.kind = "init";
            else if (this.options.ecmaVersion >= 6 && this.type === a.parenL)
              r && this.unexpected(), e.kind = "init", e.method = true, e.value = this.parseMethod(d, _);
            else if (!r && !G && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== a.comma && this.type !== a.braceR) {
              (d || _) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(false);
              var H = e.kind === "get" ? 0 : 1;
              if (e.value.params.length !== H) {
                var ae = e.value.start;
                e.kind === "get" ? this.raiseRecoverable(ae, "getter should have no params") : this.raiseRecoverable(ae, "setter should have exactly one param");
              } else
                e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
            } else
              this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((d || _) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = D), e.kind = "init", r ? e.value = this.parseMaybeDefault(D, R, e.key) : this.type === a.eq && z ? (z.shorthandAssign < 0 && (z.shorthandAssign = this.start), e.value = this.parseMaybeDefault(D, R, e.key)) : e.value = e.key, e.shorthand = true) : this.unexpected();
          }, ne.parsePropertyName = function(e) {
            if (this.options.ecmaVersion >= 6) {
              if (this.eat(a.bracketL))
                return e.computed = true, e.key = this.parseMaybeAssign(), this.expect(a.bracketR), e.key;
              e.computed = false;
            }
            return e.key = this.type === a.num || this.type === a.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
          }, ne.initFunction = function(e) {
            e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = false), this.options.ecmaVersion >= 8 && (e.async = false);
          }, ne.parseMethod = function(e, r, d) {
            var _ = this.startNode(), D = this.yieldPos, R = this.awaitPos, z = this.awaitIdentPos;
            return this.initFunction(_), this.options.ecmaVersion >= 6 && (_.generator = e), this.options.ecmaVersion >= 8 && (_.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Te(r, _.generator) | re | (d ? de : 0)), this.expect(a.parenL), _.params = this.parseBindingList(a.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(_, false, true), this.yieldPos = D, this.awaitPos = R, this.awaitIdentPos = z, this.finishNode(_, "FunctionExpression");
          }, ne.parseArrowExpression = function(e, r, d) {
            var _ = this.yieldPos, D = this.awaitPos, R = this.awaitIdentPos;
            return this.enterScope(Te(d, false) | pe), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!d), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(r, true), this.parseFunctionBody(e, true, false), this.yieldPos = _, this.awaitPos = D, this.awaitIdentPos = R, this.finishNode(e, "ArrowFunctionExpression");
          }, ne.parseFunctionBody = function(e, r, d) {
            var _ = r && this.type !== a.braceL, D = this.strict, R = false;
            if (_)
              e.body = this.parseMaybeAssign(), e.expression = true, this.checkParams(e, false);
            else {
              var z = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
              (!D || z) && (R = this.strictDirective(this.end), R && z && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
              var G = this.labels;
              this.labels = [], R && (this.strict = true), this.checkParams(e, !D && !R && !r && !d && this.isSimpleParamList(e.params)), e.body = this.parseBlock(false), e.expression = false, this.adaptDirectivePrologue(e.body.body), this.labels = G;
            }
            this.exitScope(), this.strict && e.id && this.checkLVal(e.id, nt), this.strict = D;
          }, ne.isSimpleParamList = function(e) {
            for (var r = 0, d = e; r < d.length; r += 1) {
              var _ = d[r];
              if (_.type !== "Identifier")
                return false;
            }
            return true;
          }, ne.checkParams = function(e, r) {
            for (var d = {}, _ = 0, D = e.params; _ < D.length; _ += 1) {
              var R = D[_];
              this.checkLVal(R, Ce, r ? null : d);
            }
          }, ne.parseExprList = function(e, r, d, _) {
            for (var D = [], R = true; !this.eat(e); ) {
              if (R)
                R = false;
              else if (this.expect(a.comma), r && this.afterTrailingComma(e))
                break;
              var z = void 0;
              d && this.type === a.comma ? z = null : this.type === a.ellipsis ? (z = this.parseSpread(_), _ && this.type === a.comma && _.trailingComma < 0 && (_.trailingComma = this.start)) : z = this.parseMaybeAssign(false, _), D.push(z);
            }
            return D;
          }, ne.checkUnreserved = function(e) {
            var r = e.start, d = e.end, _ = e.name;
            if (this.inGenerator && _ === "yield" && this.raiseRecoverable(r, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && _ === "await" && this.raiseRecoverable(r, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(_) && this.raise(r, "Unexpected keyword '" + _ + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(r, d).indexOf("\\\\") !== -1)) {
              var D = this.strict ? this.reservedWordsStrict : this.reservedWords;
              D.test(_) && (!this.inAsync && _ === "await" && this.raiseRecoverable(r, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(r, "The keyword '" + _ + "' is reserved"));
            }
          }, ne.parseIdent = function(e, r) {
            var d = this.startNode();
            return this.type === a.name ? d.name = this.value : this.type.keyword ? (d.name = this.type.keyword, (d.name === "class" || d.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!e), this.finishNode(d, "Identifier"), e || (this.checkUnreserved(d), d.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = d.start)), d;
          }, ne.parseYield = function(e) {
            this.yieldPos || (this.yieldPos = this.start);
            var r = this.startNode();
            return this.next(), this.type === a.semi || this.canInsertSemicolon() || this.type !== a.star && !this.type.startsExpr ? (r.delegate = false, r.argument = null) : (r.delegate = this.eat(a.star), r.argument = this.parseMaybeAssign(e)), this.finishNode(r, "YieldExpression");
          }, ne.parseAwait = function() {
            this.awaitPos || (this.awaitPos = this.start);
            var e = this.startNode();
            return this.next(), e.argument = this.parseMaybeUnary(null, false), this.finishNode(e, "AwaitExpression");
          };
          var Oe = le.prototype;
          Oe.raise = function(e, r) {
            var d = j(this.input, e);
            r += " (" + d.line + ":" + d.column + ")";
            var _ = new SyntaxError(r);
            throw _.pos = e, _.loc = d, _.raisedAt = this.pos, _;
          }, Oe.raiseRecoverable = Oe.raise, Oe.curPosition = function() {
            if (this.options.locations)
              return new J(this.curLine, this.pos - this.lineStart);
          };
          var ke = le.prototype, Lt = function(r) {
            this.flags = r, this.var = [], this.lexical = [], this.functions = [];
          };
          ke.enterScope = function(e) {
            this.scopeStack.push(new Lt(e));
          }, ke.exitScope = function() {
            this.scopeStack.pop();
          }, ke.treatFunctionsAsVarInScope = function(e) {
            return e.flags & be || !this.inModule && e.flags & ee;
          }, ke.declareName = function(e, r, d) {
            var _ = false;
            if (r === _e) {
              var D = this.currentScope();
              _ = D.lexical.indexOf(e) > -1 || D.functions.indexOf(e) > -1 || D.var.indexOf(e) > -1, D.lexical.push(e), this.inModule && D.flags & ee && delete this.undefinedExports[e];
            } else if (r === it) {
              var R = this.currentScope();
              R.lexical.push(e);
            } else if (r === tt) {
              var z = this.currentScope();
              this.treatFunctionsAsVar ? _ = z.lexical.indexOf(e) > -1 : _ = z.lexical.indexOf(e) > -1 || z.var.indexOf(e) > -1, z.functions.push(e);
            } else
              for (var G = this.scopeStack.length - 1; G >= 0; --G) {
                var H = this.scopeStack[G];
                if (H.lexical.indexOf(e) > -1 && !(H.flags & te && H.lexical[0] === e) || !this.treatFunctionsAsVarInScope(H) && H.functions.indexOf(e) > -1) {
                  _ = true;
                  break;
                }
                if (H.var.push(e), this.inModule && H.flags & ee && delete this.undefinedExports[e], H.flags & Q)
                  break;
              }
            _ && this.raiseRecoverable(d, "Identifier '" + e + "' has already been declared");
          }, ke.checkLocalExport = function(e) {
            this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
          }, ke.currentScope = function() {
            return this.scopeStack[this.scopeStack.length - 1];
          }, ke.currentVarScope = function() {
            for (var e = this.scopeStack.length - 1; ; e--) {
              var r = this.scopeStack[e];
              if (r.flags & Q)
                return r;
            }
          }, ke.currentThisScope = function() {
            for (var e = this.scopeStack.length - 1; ; e--) {
              var r = this.scopeStack[e];
              if (r.flags & Q && !(r.flags & pe))
                return r;
            }
          };
          var ze = function(r, d, _) {
            this.type = "", this.start = d, this.end = 0, r.options.locations && (this.loc = new q(r, _)), r.options.directSourceFile && (this.sourceFile = r.options.directSourceFile), r.options.ranges && (this.range = [d, 0]);
          }, Ne = le.prototype;
          Ne.startNode = function() {
            return new ze(this, this.start, this.startLoc);
          }, Ne.startNodeAt = function(e, r) {
            return new ze(this, e, r);
          };
          function rt(e, r, d, _) {
            return e.type = r, e.end = d, this.options.locations && (e.loc.end = _), this.options.ranges && (e.range[1] = d), e;
          }
          Ne.finishNode = function(e, r) {
            return rt.call(this, e, r, this.lastTokEnd, this.lastTokEndLoc);
          }, Ne.finishNodeAt = function(e, r, d, _) {
            return rt.call(this, e, r, d, _);
          };
          var ve = function(r, d, _, D, R) {
            this.token = r, this.isExpr = !!d, this.preserveSpace = !!_, this.override = D, this.generator = !!R;
          }, ce = { b_stat: new ve("{", false), b_expr: new ve("{", true), b_tmpl: new ve("\${", false), p_stat: new ve("(", false), p_expr: new ve("(", true), q_tmpl: new ve("\`", true, true, function(e) {
            return e.tryReadTemplateToken();
          }), f_stat: new ve("function", false), f_expr: new ve("function", true), f_expr_gen: new ve("function", true, false, null, true), f_gen: new ve("function", false, false, null, true) }, Pe = le.prototype;
          Pe.initialContext = function() {
            return [ce.b_stat];
          }, Pe.braceIsBlock = function(e) {
            var r = this.curContext();
            return r === ce.f_expr || r === ce.f_stat ? true : e === a.colon && (r === ce.b_stat || r === ce.b_expr) ? !r.isExpr : e === a._return || e === a.name && this.exprAllowed ? k.test(this.input.slice(this.lastTokEnd, this.start)) : e === a._else || e === a.semi || e === a.eof || e === a.parenR || e === a.arrow ? true : e === a.braceL ? r === ce.b_stat : e === a._var || e === a._const || e === a.name ? false : !this.exprAllowed;
          }, Pe.inGeneratorContext = function() {
            for (var e = this.context.length - 1; e >= 1; e--) {
              var r = this.context[e];
              if (r.token === "function")
                return r.generator;
            }
            return false;
          }, Pe.updateContext = function(e) {
            var r, d = this.type;
            d.keyword && e === a.dot ? this.exprAllowed = false : (r = d.updateContext) ? r.call(this, e) : this.exprAllowed = d.beforeExpr;
          }, a.parenR.updateContext = a.braceR.updateContext = function() {
            if (this.context.length === 1) {
              this.exprAllowed = true;
              return;
            }
            var e = this.context.pop();
            e === ce.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
          }, a.braceL.updateContext = function(e) {
            this.context.push(this.braceIsBlock(e) ? ce.b_stat : ce.b_expr), this.exprAllowed = true;
          }, a.dollarBraceL.updateContext = function() {
            this.context.push(ce.b_tmpl), this.exprAllowed = true;
          }, a.parenL.updateContext = function(e) {
            var r = e === a._if || e === a._for || e === a._with || e === a._while;
            this.context.push(r ? ce.p_stat : ce.p_expr), this.exprAllowed = true;
          }, a.incDec.updateContext = function() {
          }, a._function.updateContext = a._class.updateContext = function(e) {
            e.beforeExpr && e !== a.semi && e !== a._else && !(e === a._return && k.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === a.colon || e === a.braceL) && this.curContext() === ce.b_stat) ? this.context.push(ce.f_expr) : this.context.push(ce.f_stat), this.exprAllowed = false;
          }, a.backQuote.updateContext = function() {
            this.curContext() === ce.q_tmpl ? this.context.pop() : this.context.push(ce.q_tmpl), this.exprAllowed = false;
          }, a.star.updateContext = function(e) {
            if (e === a._function) {
              var r = this.context.length - 1;
              this.context[r] === ce.f_expr ? this.context[r] = ce.f_expr_gen : this.context[r] = ce.f_gen;
            }
            this.exprAllowed = true;
          }, a.name.updateContext = function(e) {
            var r = false;
            this.options.ecmaVersion >= 6 && e !== a.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (r = true), this.exprAllowed = r;
          };
          var at = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ot = at + " Extended_Pictographic", Rt = ot, Mt = { 9: at, 10: ot, 11: Rt }, ut = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", lt = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ht = lt + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Vt = ht + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Ot = { 9: lt, 10: ht, 11: Vt }, ct = {};
          function Xe(e) {
            var r = ct[e] = { binary: Y(Mt[e] + " " + ut), nonBinary: { General_Category: Y(ut), Script: Y(Ot[e]) } };
            r.nonBinary.Script_Extensions = r.nonBinary.Script, r.nonBinary.gc = r.nonBinary.General_Category, r.nonBinary.sc = r.nonBinary.Script, r.nonBinary.scx = r.nonBinary.Script_Extensions;
          }
          Xe(9), Xe(10), Xe(11);
          var W = le.prototype, Ee = function(r) {
            this.parser = r, this.validFlags = "gim" + (r.options.ecmaVersion >= 6 ? "uy" : "") + (r.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = ct[r.options.ecmaVersion >= 11 ? 11 : r.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
          };
          Ee.prototype.reset = function(r, d, _) {
            var D = _.indexOf("u") !== -1;
            this.start = r | 0, this.source = d + "", this.flags = _, this.switchU = D && this.parser.options.ecmaVersion >= 6, this.switchN = D && this.parser.options.ecmaVersion >= 9;
          }, Ee.prototype.raise = function(r) {
            this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + r);
          }, Ee.prototype.at = function(r) {
            var d = this.source, _ = d.length;
            if (r >= _)
              return -1;
            var D = d.charCodeAt(r);
            if (!this.switchU || D <= 55295 || D >= 57344 || r + 1 >= _)
              return D;
            var R = d.charCodeAt(r + 1);
            return R >= 56320 && R <= 57343 ? (D << 10) + R - 56613888 : D;
          }, Ee.prototype.nextIndex = function(r) {
            var d = this.source, _ = d.length;
            if (r >= _)
              return _;
            var D = d.charCodeAt(r), R;
            return !this.switchU || D <= 55295 || D >= 57344 || r + 1 >= _ || (R = d.charCodeAt(r + 1)) < 56320 || R > 57343 ? r + 1 : r + 2;
          }, Ee.prototype.current = function() {
            return this.at(this.pos);
          }, Ee.prototype.lookahead = function() {
            return this.at(this.nextIndex(this.pos));
          }, Ee.prototype.advance = function() {
            this.pos = this.nextIndex(this.pos);
          }, Ee.prototype.eat = function(r) {
            return this.current() === r ? (this.advance(), true) : false;
          };
          function Ke(e) {
            return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
          }
          W.validateRegExpFlags = function(e) {
            for (var r = e.validFlags, d = e.flags, _ = 0; _ < d.length; _++) {
              var D = d.charAt(_);
              r.indexOf(D) === -1 && this.raise(e.start, "Invalid regular expression flag"), d.indexOf(D, _ + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag");
            }
          }, W.validateRegExpPattern = function(e) {
            this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = true, this.regexp_pattern(e));
          }, W.regexp_pattern = function(e) {
            e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = false, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
            for (var r = 0, d = e.backReferenceNames; r < d.length; r += 1) {
              var _ = d[r];
              e.groupNames.indexOf(_) === -1 && e.raise("Invalid named capture referenced");
            }
          }, W.regexp_disjunction = function(e) {
            for (this.regexp_alternative(e); e.eat(124); )
              this.regexp_alternative(e);
            this.regexp_eatQuantifier(e, true) && e.raise("Nothing to repeat"), e.eat(123) && e.raise("Lone quantifier brackets");
          }, W.regexp_alternative = function(e) {
            for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
              ;
          }, W.regexp_eatTerm = function(e) {
            return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), true) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), true) : false;
          }, W.regexp_eatAssertion = function(e) {
            var r = e.pos;
            if (e.lastAssertionIsQuantifiable = false, e.eat(94) || e.eat(36))
              return true;
            if (e.eat(92)) {
              if (e.eat(66) || e.eat(98))
                return true;
              e.pos = r;
            }
            if (e.eat(40) && e.eat(63)) {
              var d = false;
              if (this.options.ecmaVersion >= 9 && (d = e.eat(60)), e.eat(61) || e.eat(33))
                return this.regexp_disjunction(e), e.eat(41) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !d, true;
            }
            return e.pos = r, false;
          }, W.regexp_eatQuantifier = function(e, r) {
            return r === void 0 && (r = false), this.regexp_eatQuantifierPrefix(e, r) ? (e.eat(63), true) : false;
          }, W.regexp_eatQuantifierPrefix = function(e, r) {
            return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, r);
          }, W.regexp_eatBracedQuantifier = function(e, r) {
            var d = e.pos;
            if (e.eat(123)) {
              var _ = 0, D = -1;
              if (this.regexp_eatDecimalDigits(e) && (_ = e.lastIntValue, e.eat(44) && this.regexp_eatDecimalDigits(e) && (D = e.lastIntValue), e.eat(125)))
                return D !== -1 && D < _ && !r && e.raise("numbers out of order in {} quantifier"), true;
              e.switchU && !r && e.raise("Incomplete quantifier"), e.pos = d;
            }
            return false;
          }, W.regexp_eatAtom = function(e) {
            return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
          }, W.regexp_eatReverseSolidusAtomEscape = function(e) {
            var r = e.pos;
            if (e.eat(92)) {
              if (this.regexp_eatAtomEscape(e))
                return true;
              e.pos = r;
            }
            return false;
          }, W.regexp_eatUncapturingGroup = function(e) {
            var r = e.pos;
            if (e.eat(40)) {
              if (e.eat(63) && e.eat(58)) {
                if (this.regexp_disjunction(e), e.eat(41))
                  return true;
                e.raise("Unterminated group");
              }
              e.pos = r;
            }
            return false;
          }, W.regexp_eatCapturingGroup = function(e) {
            if (e.eat(40)) {
              if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(41))
                return e.numCapturingParens += 1, true;
              e.raise("Unterminated group");
            }
            return false;
          }, W.regexp_eatExtendedAtom = function(e) {
            return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
          }, W.regexp_eatInvalidBracedQuantifier = function(e) {
            return this.regexp_eatBracedQuantifier(e, true) && e.raise("Nothing to repeat"), false;
          }, W.regexp_eatSyntaxCharacter = function(e) {
            var r = e.current();
            return pt(r) ? (e.lastIntValue = r, e.advance(), true) : false;
          };
          function pt(e) {
            return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
          }
          W.regexp_eatPatternCharacters = function(e) {
            for (var r = e.pos, d = 0; (d = e.current()) !== -1 && !pt(d); )
              e.advance();
            return e.pos !== r;
          }, W.regexp_eatExtendedPatternCharacter = function(e) {
            var r = e.current();
            return r !== -1 && r !== 36 && !(r >= 40 && r <= 43) && r !== 46 && r !== 63 && r !== 91 && r !== 94 && r !== 124 ? (e.advance(), true) : false;
          }, W.regexp_groupSpecifier = function(e) {
            if (e.eat(63)) {
              if (this.regexp_eatGroupName(e)) {
                e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise("Duplicate capture group name"), e.groupNames.push(e.lastStringValue);
                return;
              }
              e.raise("Invalid group");
            }
          }, W.regexp_eatGroupName = function(e) {
            if (e.lastStringValue = "", e.eat(60)) {
              if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62))
                return true;
              e.raise("Invalid capture group name");
            }
            return false;
          }, W.regexp_eatRegExpIdentifierName = function(e) {
            if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
              for (e.lastStringValue += Ke(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
                e.lastStringValue += Ke(e.lastIntValue);
              return true;
            }
            return false;
          }, W.regexp_eatRegExpIdentifierStart = function(e) {
            var r = e.pos, d = e.current();
            return e.advance(), d === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (d = e.lastIntValue), zt(d) ? (e.lastIntValue = d, true) : (e.pos = r, false);
          };
          function zt(e) {
            return S(e, true) || e === 36 || e === 95;
          }
          W.regexp_eatRegExpIdentifierPart = function(e) {
            var r = e.pos, d = e.current();
            return e.advance(), d === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (d = e.lastIntValue), Nt(d) ? (e.lastIntValue = d, true) : (e.pos = r, false);
          };
          function Nt(e) {
            return v(e, true) || e === 36 || e === 95 || e === 8204 || e === 8205;
          }
          W.regexp_eatAtomEscape = function(e) {
            return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? true : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), false);
          }, W.regexp_eatBackReference = function(e) {
            var r = e.pos;
            if (this.regexp_eatDecimalEscape(e)) {
              var d = e.lastIntValue;
              if (e.switchU)
                return d > e.maxBackReference && (e.maxBackReference = d), true;
              if (d <= e.numCapturingParens)
                return true;
              e.pos = r;
            }
            return false;
          }, W.regexp_eatKGroupName = function(e) {
            if (e.eat(107)) {
              if (this.regexp_eatGroupName(e))
                return e.backReferenceNames.push(e.lastStringValue), true;
              e.raise("Invalid named reference");
            }
            return false;
          }, W.regexp_eatCharacterEscape = function(e) {
            return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
          }, W.regexp_eatCControlLetter = function(e) {
            var r = e.pos;
            if (e.eat(99)) {
              if (this.regexp_eatControlLetter(e))
                return true;
              e.pos = r;
            }
            return false;
          }, W.regexp_eatZero = function(e) {
            return e.current() === 48 && !Ge(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), true) : false;
          }, W.regexp_eatControlEscape = function(e) {
            var r = e.current();
            return r === 116 ? (e.lastIntValue = 9, e.advance(), true) : r === 110 ? (e.lastIntValue = 10, e.advance(), true) : r === 118 ? (e.lastIntValue = 11, e.advance(), true) : r === 102 ? (e.lastIntValue = 12, e.advance(), true) : r === 114 ? (e.lastIntValue = 13, e.advance(), true) : false;
          }, W.regexp_eatControlLetter = function(e) {
            var r = e.current();
            return ft(r) ? (e.lastIntValue = r % 32, e.advance(), true) : false;
          };
          function ft(e) {
            return e >= 65 && e <= 90 || e >= 97 && e <= 122;
          }
          W.regexp_eatRegExpUnicodeEscapeSequence = function(e) {
            var r = e.pos;
            if (e.eat(117)) {
              if (this.regexp_eatFixedHexDigits(e, 4)) {
                var d = e.lastIntValue;
                if (e.switchU && d >= 55296 && d <= 56319) {
                  var _ = e.pos;
                  if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) {
                    var D = e.lastIntValue;
                    if (D >= 56320 && D <= 57343)
                      return e.lastIntValue = (d - 55296) * 1024 + (D - 56320) + 65536, true;
                  }
                  e.pos = _, e.lastIntValue = d;
                }
                return true;
              }
              if (e.switchU && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && Pt(e.lastIntValue))
                return true;
              e.switchU && e.raise("Invalid unicode escape"), e.pos = r;
            }
            return false;
          };
          function Pt(e) {
            return e >= 0 && e <= 1114111;
          }
          W.regexp_eatIdentityEscape = function(e) {
            if (e.switchU)
              return this.regexp_eatSyntaxCharacter(e) ? true : e.eat(47) ? (e.lastIntValue = 47, true) : false;
            var r = e.current();
            return r !== 99 && (!e.switchN || r !== 107) ? (e.lastIntValue = r, e.advance(), true) : false;
          }, W.regexp_eatDecimalEscape = function(e) {
            e.lastIntValue = 0;
            var r = e.current();
            if (r >= 49 && r <= 57) {
              do
                e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
              while ((r = e.current()) >= 48 && r <= 57);
              return true;
            }
            return false;
          }, W.regexp_eatCharacterClassEscape = function(e) {
            var r = e.current();
            if (Kt(r))
              return e.lastIntValue = -1, e.advance(), true;
            if (e.switchU && this.options.ecmaVersion >= 9 && (r === 80 || r === 112)) {
              if (e.lastIntValue = -1, e.advance(), e.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(125))
                return true;
              e.raise("Invalid property name");
            }
            return false;
          };
          function Kt(e) {
            return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
          }
          W.regexp_eatUnicodePropertyValueExpression = function(e) {
            var r = e.pos;
            if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
              var d = e.lastStringValue;
              if (this.regexp_eatUnicodePropertyValue(e)) {
                var _ = e.lastStringValue;
                return this.regexp_validateUnicodePropertyNameAndValue(e, d, _), true;
              }
            }
            if (e.pos = r, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
              var D = e.lastStringValue;
              return this.regexp_validateUnicodePropertyNameOrValue(e, D), true;
            }
            return false;
          }, W.regexp_validateUnicodePropertyNameAndValue = function(e, r, d) {
            B(e.unicodeProperties.nonBinary, r) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[r].test(d) || e.raise("Invalid property value");
          }, W.regexp_validateUnicodePropertyNameOrValue = function(e, r) {
            e.unicodeProperties.binary.test(r) || e.raise("Invalid property name");
          }, W.regexp_eatUnicodePropertyName = function(e) {
            var r = 0;
            for (e.lastStringValue = ""; dt(r = e.current()); )
              e.lastStringValue += Ke(r), e.advance();
            return e.lastStringValue !== "";
          };
          function dt(e) {
            return ft(e) || e === 95;
          }
          W.regexp_eatUnicodePropertyValue = function(e) {
            var r = 0;
            for (e.lastStringValue = ""; Gt(r = e.current()); )
              e.lastStringValue += Ke(r), e.advance();
            return e.lastStringValue !== "";
          };
          function Gt(e) {
            return dt(e) || Ge(e);
          }
          W.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
            return this.regexp_eatUnicodePropertyValue(e);
          }, W.regexp_eatCharacterClass = function(e) {
            if (e.eat(91)) {
              if (e.eat(94), this.regexp_classRanges(e), e.eat(93))
                return true;
              e.raise("Unterminated character class");
            }
            return false;
          }, W.regexp_classRanges = function(e) {
            for (; this.regexp_eatClassAtom(e); ) {
              var r = e.lastIntValue;
              if (e.eat(45) && this.regexp_eatClassAtom(e)) {
                var d = e.lastIntValue;
                e.switchU && (r === -1 || d === -1) && e.raise("Invalid character class"), r !== -1 && d !== -1 && r > d && e.raise("Range out of order in character class");
              }
            }
          }, W.regexp_eatClassAtom = function(e) {
            var r = e.pos;
            if (e.eat(92)) {
              if (this.regexp_eatClassEscape(e))
                return true;
              if (e.switchU) {
                var d = e.current();
                (d === 99 || gt(d)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
              }
              e.pos = r;
            }
            var _ = e.current();
            return _ !== 93 ? (e.lastIntValue = _, e.advance(), true) : false;
          }, W.regexp_eatClassEscape = function(e) {
            var r = e.pos;
            if (e.eat(98))
              return e.lastIntValue = 8, true;
            if (e.switchU && e.eat(45))
              return e.lastIntValue = 45, true;
            if (!e.switchU && e.eat(99)) {
              if (this.regexp_eatClassControlLetter(e))
                return true;
              e.pos = r;
            }
            return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
          }, W.regexp_eatClassControlLetter = function(e) {
            var r = e.current();
            return Ge(r) || r === 95 ? (e.lastIntValue = r % 32, e.advance(), true) : false;
          }, W.regexp_eatHexEscapeSequence = function(e) {
            var r = e.pos;
            if (e.eat(120)) {
              if (this.regexp_eatFixedHexDigits(e, 2))
                return true;
              e.switchU && e.raise("Invalid escape"), e.pos = r;
            }
            return false;
          }, W.regexp_eatDecimalDigits = function(e) {
            var r = e.pos, d = 0;
            for (e.lastIntValue = 0; Ge(d = e.current()); )
              e.lastIntValue = 10 * e.lastIntValue + (d - 48), e.advance();
            return e.pos !== r;
          };
          function Ge(e) {
            return e >= 48 && e <= 57;
          }
          W.regexp_eatHexDigits = function(e) {
            var r = e.pos, d = 0;
            for (e.lastIntValue = 0; mt(d = e.current()); )
              e.lastIntValue = 16 * e.lastIntValue + xt(d), e.advance();
            return e.pos !== r;
          };
          function mt(e) {
            return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
          }
          function xt(e) {
            return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
          }
          W.regexp_eatLegacyOctalEscapeSequence = function(e) {
            if (this.regexp_eatOctalDigit(e)) {
              var r = e.lastIntValue;
              if (this.regexp_eatOctalDigit(e)) {
                var d = e.lastIntValue;
                r <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = r * 64 + d * 8 + e.lastIntValue : e.lastIntValue = r * 8 + d;
              } else
                e.lastIntValue = r;
              return true;
            }
            return false;
          }, W.regexp_eatOctalDigit = function(e) {
            var r = e.current();
            return gt(r) ? (e.lastIntValue = r - 48, e.advance(), true) : (e.lastIntValue = 0, false);
          };
          function gt(e) {
            return e >= 48 && e <= 55;
          }
          W.regexp_eatFixedHexDigits = function(e, r) {
            var d = e.pos;
            e.lastIntValue = 0;
            for (var _ = 0; _ < r; ++_) {
              var D = e.current();
              if (!mt(D))
                return e.pos = d, false;
              e.lastIntValue = 16 * e.lastIntValue + xt(D), e.advance();
            }
            return true;
          };
          var Ue = function(r) {
            this.type = r.type, this.value = r.value, this.start = r.start, this.end = r.end, r.options.locations && (this.loc = new q(r, r.startLoc, r.endLoc)), r.options.ranges && (this.range = [r.start, r.end]);
          }, se = le.prototype;
          se.next = function(e) {
            !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Ue(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
          }, se.getToken = function() {
            return this.next(), new Ue(this);
          }, typeof Symbol < "u" && (se[Symbol.iterator] = function() {
            var e = this;
            return { next: function() {
              var r = e.getToken();
              return { done: r.type === a.eof, value: r };
            } };
          }), se.curContext = function() {
            return this.context[this.context.length - 1];
          }, se.nextToken = function() {
            var e = this.curContext();
            if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
              return this.finishToken(a.eof);
            if (e.override)
              return e.override(this);
            this.readToken(this.fullCharCodeAtPos());
          }, se.readToken = function(e) {
            return S(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
          }, se.fullCharCodeAtPos = function() {
            var e = this.input.charCodeAt(this.pos);
            if (e <= 55295 || e >= 57344)
              return e;
            var r = this.input.charCodeAt(this.pos + 1);
            return (e << 10) + r - 56613888;
          }, se.skipBlockComment = function() {
            var e = this.options.onComment && this.curPosition(), r = this.pos, d = this.input.indexOf("*/", this.pos += 2);
            if (d === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = d + 2, this.options.locations) {
              A.lastIndex = r;
              for (var _; (_ = A.exec(this.input)) && _.index < this.pos; )
                ++this.curLine, this.lineStart = _.index + _[0].length;
            }
            this.options.onComment && this.options.onComment(true, this.input.slice(r + 2, d), r, this.pos, e, this.curPosition());
          }, se.skipLineComment = function(e) {
            for (var r = this.pos, d = this.options.onComment && this.curPosition(), _ = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !N(_); )
              _ = this.input.charCodeAt(++this.pos);
            this.options.onComment && this.options.onComment(false, this.input.slice(r + e, this.pos), r, this.pos, d, this.curPosition());
          }, se.skipSpace = function() {
            e:
              for (; this.pos < this.input.length; ) {
                var e = this.input.charCodeAt(this.pos);
                switch (e) {
                  case 32:
                  case 160:
                    ++this.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.pos + 1)) {
                      case 42:
                        this.skipBlockComment();
                        break;
                      case 47:
                        this.skipLineComment(2);
                        break;
                      default:
                        break e;
                    }
                    break;
                  default:
                    if (e > 8 && e < 14 || e >= 5760 && F.test(String.fromCharCode(e)))
                      ++this.pos;
                    else
                      break e;
                }
              }
          }, se.finishToken = function(e, r) {
            this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
            var d = this.type;
            this.type = e, this.value = r, this.updateContext(d);
          }, se.readToken_dot = function() {
            var e = this.input.charCodeAt(this.pos + 1);
            if (e >= 48 && e <= 57)
              return this.readNumber(true);
            var r = this.input.charCodeAt(this.pos + 2);
            return this.options.ecmaVersion >= 6 && e === 46 && r === 46 ? (this.pos += 3, this.finishToken(a.ellipsis)) : (++this.pos, this.finishToken(a.dot));
          }, se.readToken_slash = function() {
            var e = this.input.charCodeAt(this.pos + 1);
            return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(a.assign, 2) : this.finishOp(a.slash, 1);
          }, se.readToken_mult_modulo_exp = function(e) {
            var r = this.input.charCodeAt(this.pos + 1), d = 1, _ = e === 42 ? a.star : a.modulo;
            return this.options.ecmaVersion >= 7 && e === 42 && r === 42 && (++d, _ = a.starstar, r = this.input.charCodeAt(this.pos + 2)), r === 61 ? this.finishOp(a.assign, d + 1) : this.finishOp(_, d);
          }, se.readToken_pipe_amp = function(e) {
            var r = this.input.charCodeAt(this.pos + 1);
            return r === e ? this.finishOp(e === 124 ? a.logicalOR : a.logicalAND, 2) : r === 61 ? this.finishOp(a.assign, 2) : this.finishOp(e === 124 ? a.bitwiseOR : a.bitwiseAND, 1);
          }, se.readToken_caret = function() {
            var e = this.input.charCodeAt(this.pos + 1);
            return e === 61 ? this.finishOp(a.assign, 2) : this.finishOp(a.bitwiseXOR, 1);
          }, se.readToken_plus_min = function(e) {
            var r = this.input.charCodeAt(this.pos + 1);
            return r === e ? r === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || k.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(a.incDec, 2) : r === 61 ? this.finishOp(a.assign, 2) : this.finishOp(a.plusMin, 1);
          }, se.readToken_lt_gt = function(e) {
            var r = this.input.charCodeAt(this.pos + 1), d = 1;
            return r === e ? (d = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + d) === 61 ? this.finishOp(a.assign, d + 1) : this.finishOp(a.bitShift, d)) : r === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (r === 61 && (d = 2), this.finishOp(a.relational, d));
          }, se.readToken_eq_excl = function(e) {
            var r = this.input.charCodeAt(this.pos + 1);
            return r === 61 ? this.finishOp(a.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && r === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(a.arrow)) : this.finishOp(e === 61 ? a.eq : a.prefix, 1);
          }, se.getTokenFromCode = function(e) {
            switch (e) {
              case 46:
                return this.readToken_dot();
              case 40:
                return ++this.pos, this.finishToken(a.parenL);
              case 41:
                return ++this.pos, this.finishToken(a.parenR);
              case 59:
                return ++this.pos, this.finishToken(a.semi);
              case 44:
                return ++this.pos, this.finishToken(a.comma);
              case 91:
                return ++this.pos, this.finishToken(a.bracketL);
              case 93:
                return ++this.pos, this.finishToken(a.bracketR);
              case 123:
                return ++this.pos, this.finishToken(a.braceL);
              case 125:
                return ++this.pos, this.finishToken(a.braceR);
              case 58:
                return ++this.pos, this.finishToken(a.colon);
              case 63:
                return ++this.pos, this.finishToken(a.question);
              case 96:
                if (this.options.ecmaVersion < 6)
                  break;
                return ++this.pos, this.finishToken(a.backQuote);
              case 48:
                var r = this.input.charCodeAt(this.pos + 1);
                if (r === 120 || r === 88)
                  return this.readRadixNumber(16);
                if (this.options.ecmaVersion >= 6) {
                  if (r === 111 || r === 79)
                    return this.readRadixNumber(8);
                  if (r === 98 || r === 66)
                    return this.readRadixNumber(2);
                }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return this.readNumber(false);
              case 34:
              case 39:
                return this.readString(e);
              case 47:
                return this.readToken_slash();
              case 37:
              case 42:
                return this.readToken_mult_modulo_exp(e);
              case 124:
              case 38:
                return this.readToken_pipe_amp(e);
              case 94:
                return this.readToken_caret();
              case 43:
              case 45:
                return this.readToken_plus_min(e);
              case 60:
              case 62:
                return this.readToken_lt_gt(e);
              case 61:
              case 33:
                return this.readToken_eq_excl(e);
              case 126:
                return this.finishOp(a.prefix, 1);
            }
            this.raise(this.pos, "Unexpected character '" + Ye(e) + "'");
          }, se.finishOp = function(e, r) {
            var d = this.input.slice(this.pos, this.pos + r);
            return this.pos += r, this.finishToken(e, d);
          }, se.readRegexp = function() {
            for (var e, r, d = this.pos; ; ) {
              this.pos >= this.input.length && this.raise(d, "Unterminated regular expression");
              var _ = this.input.charAt(this.pos);
              if (k.test(_) && this.raise(d, "Unterminated regular expression"), e)
                e = false;
              else {
                if (_ === "[")
                  r = true;
                else if (_ === "]" && r)
                  r = false;
                else if (_ === "/" && !r)
                  break;
                e = _ === "\\\\";
              }
              ++this.pos;
            }
            var D = this.input.slice(d, this.pos);
            ++this.pos;
            var R = this.pos, z = this.readWord1();
            this.containsEsc && this.unexpected(R);
            var G = this.regexpState || (this.regexpState = new Ee(this));
            G.reset(d, D, z), this.validateRegExpFlags(G), this.validateRegExpPattern(G);
            var H = null;
            try {
              H = new RegExp(D, z);
            } catch {
            }
            return this.finishToken(a.regexp, { pattern: D, flags: z, value: H });
          }, se.readInt = function(e, r) {
            for (var d = this.pos, _ = 0, D = 0, R = r ?? 1 / 0; D < R; ++D) {
              var z = this.input.charCodeAt(this.pos), G = void 0;
              if (z >= 97 ? G = z - 97 + 10 : z >= 65 ? G = z - 65 + 10 : z >= 48 && z <= 57 ? G = z - 48 : G = 1 / 0, G >= e)
                break;
              ++this.pos, _ = _ * e + G;
            }
            return this.pos === d || r != null && this.pos - d !== r ? null : _;
          }, se.readRadixNumber = function(e) {
            var r = this.pos;
            this.pos += 2;
            var d = this.readInt(e);
            return d == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (d = typeof BigInt < "u" ? BigInt(this.input.slice(r, this.pos)) : null, ++this.pos) : S(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(a.num, d);
          }, se.readNumber = function(e) {
            var r = this.pos;
            !e && this.readInt(10) === null && this.raise(r, "Invalid number");
            var d = this.pos - r >= 2 && this.input.charCodeAt(r) === 48;
            d && this.strict && this.raise(r, "Invalid number");
            var _ = this.input.charCodeAt(this.pos);
            if (!d && !e && this.options.ecmaVersion >= 11 && _ === 110) {
              var D = this.input.slice(r, this.pos), R = typeof BigInt < "u" ? BigInt(D) : null;
              return ++this.pos, S(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(a.num, R);
            }
            d && /[89]/.test(this.input.slice(r, this.pos)) && (d = false), _ === 46 && !d && (++this.pos, this.readInt(10), _ = this.input.charCodeAt(this.pos)), (_ === 69 || _ === 101) && !d && (_ = this.input.charCodeAt(++this.pos), (_ === 43 || _ === 45) && ++this.pos, this.readInt(10) === null && this.raise(r, "Invalid number")), S(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
            var z = this.input.slice(r, this.pos), G = d ? parseInt(z, 8) : parseFloat(z);
            return this.finishToken(a.num, G);
          }, se.readCodePoint = function() {
            var e = this.input.charCodeAt(this.pos), r;
            if (e === 123) {
              this.options.ecmaVersion < 6 && this.unexpected();
              var d = ++this.pos;
              r = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, r > 1114111 && this.invalidStringToken(d, "Code point out of bounds");
            } else
              r = this.readHexChar(4);
            return r;
          };
          function Ye(e) {
            return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
          }
          se.readString = function(e) {
            for (var r = "", d = ++this.pos; ; ) {
              this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
              var _ = this.input.charCodeAt(this.pos);
              if (_ === e)
                break;
              _ === 92 ? (r += this.input.slice(d, this.pos), r += this.readEscapedChar(false), d = this.pos) : (N(_, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
            }
            return r += this.input.slice(d, this.pos++), this.finishToken(a.string, r);
          };
          var yt = {};
          se.tryReadTemplateToken = function() {
            this.inTemplateElement = true;
            try {
              this.readTmplToken();
            } catch (e) {
              if (e === yt)
                this.readInvalidTemplateToken();
              else
                throw e;
            }
            this.inTemplateElement = false;
          }, se.invalidStringToken = function(e, r) {
            if (this.inTemplateElement && this.options.ecmaVersion >= 9)
              throw yt;
            this.raise(e, r);
          }, se.readTmplToken = function() {
            for (var e = "", r = this.pos; ; ) {
              this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
              var d = this.input.charCodeAt(this.pos);
              if (d === 96 || d === 36 && this.input.charCodeAt(this.pos + 1) === 123)
                return this.pos === this.start && (this.type === a.template || this.type === a.invalidTemplate) ? d === 36 ? (this.pos += 2, this.finishToken(a.dollarBraceL)) : (++this.pos, this.finishToken(a.backQuote)) : (e += this.input.slice(r, this.pos), this.finishToken(a.template, e));
              if (d === 92)
                e += this.input.slice(r, this.pos), e += this.readEscapedChar(true), r = this.pos;
              else if (N(d)) {
                switch (e += this.input.slice(r, this.pos), ++this.pos, d) {
                  case 13:
                    this.input.charCodeAt(this.pos) === 10 && ++this.pos;
                  case 10:
                    e += \`
\`;
                    break;
                  default:
                    e += String.fromCharCode(d);
                    break;
                }
                this.options.locations && (++this.curLine, this.lineStart = this.pos), r = this.pos;
              } else
                ++this.pos;
            }
          }, se.readInvalidTemplateToken = function() {
            for (; this.pos < this.input.length; this.pos++)
              switch (this.input[this.pos]) {
                case "\\\\":
                  ++this.pos;
                  break;
                case "$":
                  if (this.input[this.pos + 1] !== "{")
                    break;
                case "\`":
                  return this.finishToken(a.invalidTemplate, this.input.slice(this.start, this.pos));
              }
            this.raise(this.start, "Unterminated template");
          }, se.readEscapedChar = function(e) {
            var r = this.input.charCodeAt(++this.pos);
            switch (++this.pos, r) {
              case 110:
                return \`
\`;
              case 114:
                return "\\r";
              case 120:
                return String.fromCharCode(this.readHexChar(2));
              case 117:
                return Ye(this.readCodePoint());
              case 116:
                return "	";
              case 98:
                return "\\b";
              case 118:
                return "\\v";
              case 102:
                return "\\f";
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
              case 56:
              case 57:
                if (e) {
                  var d = this.pos - 1;
                  return this.invalidStringToken(d, "Invalid escape sequence in template string"), null;
                }
              default:
                if (r >= 48 && r <= 55) {
                  var _ = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], D = parseInt(_, 8);
                  return D > 255 && (_ = _.slice(0, -1), D = parseInt(_, 8)), this.pos += _.length - 1, r = this.input.charCodeAt(this.pos), (_ !== "0" || r === 56 || r === 57) && (this.strict || e) && this.invalidStringToken(this.pos - 1 - _.length, e ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(D);
                }
                return N(r) ? "" : String.fromCharCode(r);
            }
          }, se.readHexChar = function(e) {
            var r = this.pos, d = this.readInt(16, e);
            return d === null && this.invalidStringToken(r, "Bad character escape sequence"), d;
          }, se.readWord1 = function() {
            this.containsEsc = false;
            for (var e = "", r = true, d = this.pos, _ = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
              var D = this.fullCharCodeAtPos();
              if (v(D, _))
                this.pos += D <= 65535 ? 1 : 2;
              else if (D === 92) {
                this.containsEsc = true, e += this.input.slice(d, this.pos);
                var R = this.pos;
                this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\\\uXXXX"), ++this.pos;
                var z = this.readCodePoint();
                (r ? S : v)(z, _) || this.invalidStringToken(R, "Invalid Unicode escape"), e += Ye(z), d = this.pos;
              } else
                break;
              r = false;
            }
            return e + this.input.slice(d, this.pos);
          }, se.readWord = function() {
            var e = this.readWord1(), r = a.name;
            return this.keywords.test(e) && (r = V[e]), this.finishToken(r, e);
          };
          var bt = "7.1.0";
          le.acorn = { Parser: le, version: bt, defaultOptions: U, Position: J, SourceLocation: q, getLineInfo: j, Node: ze, TokenType: h, tokTypes: a, keywordTypes: V, TokContext: ve, tokContexts: ce, isIdentifierChar: v, isIdentifierStart: S, Token: Ue, isNewLine: N, lineBreak: k, lineBreakG: A, nonASCIIwhitespace: F };
          function Ut(e, r) {
            return le.parse(e, r);
          }
          function Bt(e, r, d) {
            return le.parseExpressionAt(e, r, d);
          }
          function Wt(e, r) {
            return le.tokenizer(e, r);
          }
          p.Node = ze, p.Parser = le, p.Position = J, p.SourceLocation = q, p.TokContext = ve, p.Token = Ue, p.TokenType = h, p.defaultOptions = U, p.getLineInfo = j, p.isIdentifierChar = v, p.isIdentifierStart = S, p.isNewLine = N, p.keywordTypes = V, p.lineBreak = k, p.lineBreakG = A, p.nonASCIIwhitespace = F, p.parse = Ut, p.parseExpressionAt = Bt, p.tokContexts = ce, p.tokTypes = a, p.tokenizer = Wt, p.version = bt, Object.defineProperty(p, "__esModule", { value: true });
        });
      }, {}], 2: [function(o, y, E) {
      }, {}], 3: [function(o, y, E) {
        function p(s, t = {}) {
          let { contextName: i = "gl", throwGetError: u, useTrackablePrimitives: x2, readPixelsFile: w, recording: m = [], variables: S = {}, onReadPixels: v, onUnrecognizedArgumentLookup: h } = t, b = new Proxy(s, { get: k }), T = [], C = {}, V = 0, c = "", a;
          return b;
          function k(j, U) {
            switch (U) {
              case "addComment":
                return B;
              case "checkThrowError":
                return P;
              case "getReadPixelsVariableName":
                return a;
              case "insertVariable":
                return F;
              case "reset":
                return N;
              case "setIndent":
                return K;
              case "toString":
                return A;
              case "getContextVariableName":
                return q;
            }
            return typeof s[U] == "function" ? function() {
              switch (U) {
                case "getError":
                  return u ? m.push(\`\${c}if (\${i}.getError() !== \${i}.NONE) throw new Error('error');\`) : m.push(\`\${c}\${i}.getError();\`), s.getError();
                case "getExtension": {
                  let Q = \`\${i}Variables\${T.length}\`;
                  m.push(\`\${c}const \${Q} = \${i}.getExtension('\${arguments[0]}');\`);
                  let ue = s.getExtension(arguments[0]);
                  if (ue && typeof ue == "object") {
                    let he = g(ue, { getEntity: L, useTrackablePrimitives: x2, recording: m, contextName: Q, contextVariables: T, variables: S, indent: c, onUnrecognizedArgumentLookup: h });
                    return T.push(he), he;
                  } else
                    T.push(null);
                  return ue;
                }
                case "readPixels":
                  let Z = T.indexOf(arguments[6]), ee;
                  if (Z === -1) {
                    let Q = J(arguments[6]);
                    Q ? (ee = Q, m.push(\`\${c}\${Q}\`)) : (ee = \`\${i}Variable\${T.length}\`, T.push(arguments[6]), m.push(\`\${c}const \${ee} = new \${arguments[6].constructor.name}(\${arguments[6].length});\`));
                  } else
                    ee = \`\${i}Variable\${Z}\`;
                  a = ee;
                  let be = [arguments[0], arguments[1], arguments[2], arguments[3], L(arguments[4]), L(arguments[5]), ee];
                  return m.push(\`\${c}\${i}.readPixels(\${be.join(", ")});\`), w && X(arguments[2], arguments[3]), v && v(ee, be), s.readPixels.apply(s, arguments);
                case "drawBuffers":
                  return m.push(\`\${c}\${i}.drawBuffers([\${f(arguments[0], { contextName: i, contextVariables: T, getEntity: L, addVariable: O, variables: S, onUnrecognizedArgumentLookup: h })}]);\`), s.drawBuffers(arguments[0]);
              }
              let oe = s[U].apply(s, arguments);
              switch (typeof oe) {
                case "undefined":
                  m.push(\`\${c}\${Y(U, arguments)};\`);
                  return;
                case "number":
                case "boolean":
                  if (x2 && T.indexOf(n(oe)) === -1) {
                    m.push(\`\${c}const \${i}Variable\${T.length} = \${Y(U, arguments)};\`), T.push(oe = n(oe));
                    break;
                  }
                default:
                  oe === null ? m.push(\`\${Y(U, arguments)};\`) : m.push(\`\${c}const \${i}Variable\${T.length} = \${Y(U, arguments)};\`), T.push(oe);
              }
              return oe;
            } : (C[s[U]] = U, s[U]);
          }
          function A() {
            return m.join(\`
\`);
          }
          function N() {
            for (; m.length > 0; )
              m.pop();
          }
          function F(j, U) {
            S[j] = U;
          }
          function L(j) {
            let U = C[j];
            return U ? i + "." + U : j;
          }
          function K(j) {
            c = " ".repeat(j);
          }
          function O(j, U) {
            let oe = \`\${i}Variable\${T.length}\`;
            return m.push(\`\${c}const \${oe} = \${U};\`), T.push(j), oe;
          }
          function X(j, U) {
            let oe = \`\${i}Variable\${T.length}\`, Z = \`imageDatum\${V}\`;
            m.push(\`\${c}let \${Z} = ["P3\\\\n# \${w}.ppm\\\\n", \${j}, ' ', \${U}, "\\\\n255\\\\n"].join("");\`), m.push(\`\${c}for (let i = 0; i < \${Z}.length; i += 4) {\`), m.push(\`\${c}  \${Z} += \${oe}[i] + ' ' + \${oe}[i + 1] + ' ' + \${oe}[i + 2] + ' ';\`), m.push(\`\${c}}\`), m.push(\`\${c}if (typeof require !== "undefined") {\`), m.push(\`\${c}  require('fs').writeFileSync('./\${w}.ppm', \${Z});\`), m.push(\`\${c}}\`), V++;
          }
          function B(j) {
            m.push(\`\${c}// \${j}\`);
          }
          function P() {
            m.push(\`\${c}(() => {
      \${c}const error = \${i}.getError();
      \${c}if (error !== \${i}.NONE) {
      \${c}  const names = Object.getOwnPropertyNames(gl);
      \${c}  for (let i = 0; i < names.length; i++) {
      \${c}    const name = names[i];
      \${c}    if (\${i}[name] === error) {
      \${c}      throw new Error('\${i} threw ' + name);
      \${c}    }
      \${c}  }
      \${c}}
      \${c}})();\`);
          }
          function Y(j, U) {
            return \`\${i}.\${j}(\${f(U, { contextName: i, contextVariables: T, getEntity: L, addVariable: O, variables: S, onUnrecognizedArgumentLookup: h })})\`;
          }
          function J(j) {
            if (S) {
              for (let U in S)
                if (S[U] === j)
                  return U;
            }
            return null;
          }
          function q(j) {
            let U = T.indexOf(j);
            return U !== -1 ? \`\${i}Variable\${U}\` : null;
          }
        }
        function g(s, t) {
          let i = new Proxy(s, { get: C }), u = {}, { contextName: x2, contextVariables: w, getEntity: m, useTrackablePrimitives: S, recording: v, variables: h, indent: b, onUnrecognizedArgumentLookup: T } = t;
          return i;
          function C(k, A) {
            return typeof k[A] == "function" ? function() {
              switch (A) {
                case "drawBuffersWEBGL":
                  return v.push(\`\${b}\${x2}.drawBuffersWEBGL([\${f(arguments[0], { contextName: x2, contextVariables: w, getEntity: V, addVariable: a, variables: h, onUnrecognizedArgumentLookup: T })}]);\`), s.drawBuffersWEBGL(arguments[0]);
              }
              let N = s[A].apply(s, arguments);
              switch (typeof N) {
                case "undefined":
                  v.push(\`\${b}\${c(A, arguments)};\`);
                  return;
                case "number":
                case "boolean":
                  S && w.indexOf(n(N)) === -1 ? (v.push(\`\${b}const \${x2}Variable\${w.length} = \${c(A, arguments)};\`), w.push(N = n(N))) : (v.push(\`\${b}const \${x2}Variable\${w.length} = \${c(A, arguments)};\`), w.push(N));
                  break;
                default:
                  N === null ? v.push(\`\${c(A, arguments)};\`) : v.push(\`\${b}const \${x2}Variable\${w.length} = \${c(A, arguments)};\`), w.push(N);
              }
              return N;
            } : (u[s[A]] = A, s[A]);
          }
          function V(k) {
            return u.hasOwnProperty(k) ? \`\${x2}.\${u[k]}\` : m(k);
          }
          function c(k, A) {
            return \`\${x2}.\${k}(\${f(A, { contextName: x2, contextVariables: w, getEntity: V, addVariable: a, variables: h, onUnrecognizedArgumentLookup: T })})\`;
          }
          function a(k, A) {
            let N = \`\${x2}Variable\${w.length}\`;
            return w.push(k), v.push(\`\${b}const \${N} = \${A};\`), N;
          }
        }
        function f(s, t) {
          let { variables: i, onUnrecognizedArgumentLookup: u } = t;
          return Array.from(s).map((w) => {
            let m = x2(w);
            return m || l(w, t);
          }).join(", ");
          function x2(w) {
            if (i) {
              for (let m in i)
                if (!!i.hasOwnProperty(m) && i[m] === w)
                  return m;
            }
            return u ? u(w) : null;
          }
        }
        function l(s, t) {
          let { contextName: i, contextVariables: u, getEntity: x2, addVariable: w, onUnrecognizedArgumentLookup: m } = t;
          if (typeof s > "u")
            return "undefined";
          if (s === null)
            return "null";
          let S = u.indexOf(s);
          if (S > -1)
            return \`\${i}Variable\${S}\`;
          switch (s.constructor.name) {
            case "String":
              let v = /\\n/.test(s), h = /'/.test(s), b = /"/.test(s);
              return v ? "\`" + s + "\`" : h && !b ? '"' + s + '"' : "'" + s + "'";
            case "Number":
              return x2(s);
            case "Boolean":
              return x2(s);
            case "Array":
              return w(s, \`new \${s.constructor.name}([\${Array.from(s).join(",")}])\`);
            case "Float32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Int32Array":
              return w(s, \`new \${s.constructor.name}(\${JSON.stringify(Array.from(s))})\`);
            default:
              if (m) {
                let T = m(s);
                if (T)
                  return T;
              }
              throw new Error(\`unrecognized argument type \${s.constructor.name}\`);
          }
        }
        function n(s) {
          return new s.constructor(s);
        }
        typeof y < "u" && (y.exports = { glWiretap: p, glExtensionWiretap: g }), typeof window < "u" && (p.glExtensionWiretap = g, window.glWiretap = p);
      }, {}], 4: [function(o, y, E) {
        function p(w) {
          let m = new Array(w.length);
          for (let S = 0; S < w.length; S++) {
            let v = w[S];
            v.toArray ? m[S] = v.toArray() : m[S] = v;
          }
          return m;
        }
        function g() {
          let w = p(arguments), m = new Float32Array(this.output.x);
          for (let S = 0; S < this.output.x; S++)
            this.thread.x = S, this.thread.y = 0, this.thread.z = 0, m[S] = this._fn.apply(this, w);
          return m;
        }
        function f() {
          let w = p(arguments), m = new Array(this.output.y);
          for (let S = 0; S < this.output.y; S++) {
            let v = new Float32Array(this.output.x);
            for (let h = 0; h < this.output.x; h++)
              this.thread.x = h, this.thread.y = S, this.thread.z = 0, v[h] = this._fn.apply(this, w);
            m[S] = v;
          }
          return m;
        }
        function l() {
          let w = p(arguments);
          for (let m = 0; m < this.output.y; m++)
            for (let S = 0; S < this.output.x; S++)
              this.thread.x = S, this.thread.y = m, this.thread.z = 0, this._fn.apply(this, w);
        }
        function n() {
          let w = p(arguments), m = new Array(this.output.z);
          for (let S = 0; S < this.output.z; S++) {
            let v = new Array(this.output.y);
            for (let h = 0; h < this.output.y; h++) {
              let b = new Float32Array(this.output.x);
              for (let T = 0; T < this.output.x; T++)
                this.thread.x = T, this.thread.y = h, this.thread.z = S, b[T] = this._fn.apply(this, w);
              v[h] = b;
            }
            m[S] = v;
          }
          return m;
        }
        function s(w) {
          w.setOutput = (v) => {
            w.output = i(v), w.graphical && t(w);
          }, w.toJSON = () => {
            throw new Error("Not usable with gpuMock");
          }, w.setConstants = (v) => (w.constants = v, w), w.setGraphical = (v) => (w.graphical = v, w), w.setCanvas = (v) => (w.canvas = v, w), w.setContext = (v) => (w.context = v, w), w.destroy = () => {
          }, w.validateSettings = () => {
          }, w.graphical && w.output && t(w), w.exec = function() {
            return new Promise((v, h) => {
              try {
                v(w.apply(w, arguments));
              } catch (b) {
                h(b);
              }
            });
          }, w.getPixels = (v) => {
            let { x: h, y: b } = w.output;
            return v ? x2(w._imageData.data, h, b) : w._imageData.data.slice(0);
          }, w.color = function(v, h, b, T) {
            typeof T > "u" && (T = 1), v = Math.floor(v * 255), h = Math.floor(h * 255), b = Math.floor(b * 255), T = Math.floor(T * 255);
            let C = w.output.x, V = w.output.y, c = w.thread.x, a = V - w.thread.y - 1, k = c + a * C;
            w._colorData[k * 4 + 0] = v, w._colorData[k * 4 + 1] = h, w._colorData[k * 4 + 2] = b, w._colorData[k * 4 + 3] = T;
          };
          let m = () => w, S = ["setWarnVarUsage", "setArgumentTypes", "setTactic", "setOptimizeFloatMemory", "setDebug", "setLoopMaxIterations", "setConstantTypes", "setFunctions", "setNativeFunctions", "setInjectedNative", "setPipeline", "setPrecision", "setOutputToTexture", "setImmutable", "setStrictIntegers", "setDynamicOutput", "setHardcodeConstants", "setDynamicArguments", "setUseLegacyEncoder", "setWarnVarUsage", "addSubKernel"];
          for (let v = 0; v < S.length; v++)
            w[S[v]] = m;
          return w;
        }
        function t(w) {
          let { x: m, y: S } = w.output;
          if (w.context && w.context.createImageData) {
            let v = new Uint8ClampedArray(m * S * 4);
            w._imageData = w.context.createImageData(m, S), w._colorData = v;
          } else {
            let v = new Uint8ClampedArray(m * S * 4);
            w._imageData = { data: v }, w._colorData = v;
          }
        }
        function i(w) {
          let m = null;
          if (w.length)
            if (w.length === 3) {
              let [S, v, h] = w;
              m = { x: S, y: v, z: h };
            } else if (w.length === 2) {
              let [S, v] = w;
              m = { x: S, y: v };
            } else {
              let [S] = w;
              m = { x: S };
            }
          else
            m = w;
          return m;
        }
        function u(w, m = {}) {
          let S = m.output ? i(m.output) : null;
          function v() {
            return v.output.z ? n.apply(v, arguments) : v.output.y ? v.graphical ? l.apply(v, arguments) : f.apply(v, arguments) : g.apply(v, arguments);
          }
          return v._fn = w, v.constants = m.constants || null, v.context = m.context || null, v.canvas = m.canvas || null, v.graphical = m.graphical || false, v._imageData = null, v._colorData = null, v.output = S, v.thread = { x: 0, y: 0, z: 0 }, s(v);
        }
        function x2(w, m, S) {
          let v = S / 2 | 0, h = m * 4, b = new Uint8ClampedArray(m * 4), T = w.slice(0);
          for (let C = 0; C < v; ++C) {
            let V = C * h, c = (S - C - 1) * h;
            b.set(T.subarray(V, V + h)), T.copyWithin(V, c, c + h), T.set(b, c);
          }
          return T;
        }
        y.exports = { gpuMock: u };
      }, {}], 5: [function(o, y, E) {
        let { utils: p } = o("./utils");
        function g(f, l) {
          let n = l.toString();
          return new Function(\`return function \${f} (\${p.getArgumentNamesFromString(n).join(", ")}) {
        \${p.getFunctionBodyFromString(n)}
      }\`)();
        }
        y.exports = { alias: g };
      }, { "./utils": 114 }], 6: [function(o, y, E) {
        let { FunctionNode: p } = o("../function-node");
        class g extends p {
          astFunction(l, n) {
            if (!this.isRootKernel) {
              n.push("function"), n.push(" "), n.push(this.name), n.push("(");
              for (let s = 0; s < this.argumentNames.length; ++s) {
                let t = this.argumentNames[s];
                s > 0 && n.push(", "), n.push("user_"), n.push(t);
              }
              n.push(\`) {
\`);
            }
            for (let s = 0; s < l.body.body.length; ++s)
              this.astGeneric(l.body.body[s], n), n.push(\`
\`);
            return this.isRootKernel || n.push(\`}
\`), n;
          }
          astReturnStatement(l, n) {
            let s = this.returnType || this.getType(l.argument);
            return this.returnType || (this.returnType = s), this.isRootKernel ? (n.push(this.leadingReturnStatement), this.astGeneric(l.argument, n), n.push(\`;
\`), n.push(this.followingReturnStatement), n.push(\`continue;
\`)) : this.isSubKernel ? (n.push(\`subKernelResult_\${this.name} = \`), this.astGeneric(l.argument, n), n.push(";"), n.push(\`return subKernelResult_\${this.name};\`)) : (n.push("return "), this.astGeneric(l.argument, n), n.push(";")), n;
          }
          astLiteral(l, n) {
            if (isNaN(l.value))
              throw this.astErrorOutput("Non-numeric literal not supported : " + l.value, l);
            return n.push(l.value), n;
          }
          astBinaryExpression(l, n) {
            return n.push("("), this.astGeneric(l.left, n), n.push(l.operator), this.astGeneric(l.right, n), n.push(")"), n;
          }
          astIdentifierExpression(l, n) {
            if (l.type !== "Identifier")
              throw this.astErrorOutput("IdentifierExpression - not an Identifier", l);
            switch (l.name) {
              case "Infinity":
                n.push("Infinity");
                break;
              default:
                this.constants && this.constants.hasOwnProperty(l.name) ? n.push("constants_" + l.name) : n.push("user_" + l.name);
            }
            return n;
          }
          astForStatement(l, n) {
            if (l.type !== "ForStatement")
              throw this.astErrorOutput("Invalid for statement", l);
            let s = [], t = [], i = [], u = [], x2 = null;
            if (l.init) {
              this.pushState("in-for-loop-init"), this.astGeneric(l.init, s);
              for (let w = 0; w < s.length; w++)
                s[w].includes && s[w].includes(",") && (x2 = false);
              this.popState("in-for-loop-init");
            } else
              x2 = false;
            if (l.test ? this.astGeneric(l.test, t) : x2 = false, l.update ? this.astGeneric(l.update, i) : x2 = false, l.body && (this.pushState("loop-body"), this.astGeneric(l.body, u), this.popState("loop-body")), x2 === null && (x2 = this.isSafe(l.init) && this.isSafe(l.test)), x2)
              n.push(\`for (\${s.join("")};\${t.join("")};\${i.join("")}){
\`), n.push(u.join("")), n.push(\`}
\`);
            else {
              let w = this.getInternalVariableName("safeI");
              s.length > 0 && n.push(s.join(""), \`;
\`), n.push(\`for (let \${w}=0;\${w}<LOOP_MAX;\${w}++){
\`), t.length > 0 && n.push(\`if (!\${t.join("")}) break;
\`), n.push(u.join("")), n.push(\`
\${i.join("")};\`), n.push(\`}
\`);
            }
            return n;
          }
          astWhileStatement(l, n) {
            if (l.type !== "WhileStatement")
              throw this.astErrorOutput("Invalid while statement", l);
            return n.push("for (let i = 0; i < LOOP_MAX; i++) {"), n.push("if ("), this.astGeneric(l.test, n), n.push(\`) {
\`), this.astGeneric(l.body, n), n.push(\`} else {
\`), n.push(\`break;
\`), n.push(\`}
\`), n.push(\`}
\`), n;
          }
          astDoWhileStatement(l, n) {
            if (l.type !== "DoWhileStatement")
              throw this.astErrorOutput("Invalid while statement", l);
            return n.push("for (let i = 0; i < LOOP_MAX; i++) {"), this.astGeneric(l.body, n), n.push("if (!"), this.astGeneric(l.test, n), n.push(\`) {
\`), n.push(\`break;
\`), n.push(\`}
\`), n.push(\`}
\`), n;
          }
          astAssignmentExpression(l, n) {
            let s = this.getDeclaration(l.left);
            if (s && !s.assignable)
              throw this.astErrorOutput(\`Variable \${l.left.name} is not assignable here\`, l);
            return this.astGeneric(l.left, n), n.push(l.operator), this.astGeneric(l.right, n), n;
          }
          astBlockStatement(l, n) {
            if (this.isState("loop-body")) {
              this.pushState("block-body");
              for (let s = 0; s < l.body.length; s++)
                this.astGeneric(l.body[s], n);
              this.popState("block-body");
            } else {
              n.push(\`{
\`);
              for (let s = 0; s < l.body.length; s++)
                this.astGeneric(l.body[s], n);
              n.push(\`}
\`);
            }
            return n;
          }
          astVariableDeclaration(l, n) {
            n.push(\`\${l.kind} \`);
            let { declarations: s } = l;
            for (let t = 0; t < s.length; t++) {
              t > 0 && n.push(",");
              let i = s[t], u = this.getDeclaration(i.id);
              u.valueType || (u.valueType = this.getType(i.init)), this.astGeneric(i, n);
            }
            return this.isState("in-for-loop-init") || n.push(";"), n;
          }
          astIfStatement(l, n) {
            return n.push("if ("), this.astGeneric(l.test, n), n.push(")"), l.consequent.type === "BlockStatement" ? this.astGeneric(l.consequent, n) : (n.push(\` {
\`), this.astGeneric(l.consequent, n), n.push(\`
}
\`)), l.alternate && (n.push("else "), l.alternate.type === "BlockStatement" || l.alternate.type === "IfStatement" ? this.astGeneric(l.alternate, n) : (n.push(\` {
\`), this.astGeneric(l.alternate, n), n.push(\`
}
\`))), n;
          }
          astSwitchStatement(l, n) {
            let { discriminant: s, cases: t } = l;
            n.push("switch ("), this.astGeneric(s, n), n.push(\`) {
\`);
            for (let i = 0; i < t.length; i++) {
              if (t[i].test === null) {
                n.push(\`default:
\`), this.astGeneric(t[i].consequent, n), t[i].consequent && t[i].consequent.length > 0 && n.push(\`break;
\`);
                continue;
              }
              n.push("case "), this.astGeneric(t[i].test, n), n.push(\`:
\`), t[i].consequent && t[i].consequent.length > 0 && (this.astGeneric(t[i].consequent, n), n.push(\`break;
\`));
            }
            n.push(\`
}\`);
          }
          astThisExpression(l, n) {
            return n.push("_this"), n;
          }
          astMemberExpression(l, n) {
            let { signature: s, type: t, property: i, xProperty: u, yProperty: x2, zProperty: w, name: m, origin: S } = this.getMemberExpressionDetails(l);
            switch (s) {
              case "this.thread.value":
                return n.push(\`_this.thread.\${m}\`), n;
              case "this.output.value":
                switch (m) {
                  case "x":
                    n.push("outputX");
                    break;
                  case "y":
                    n.push("outputY");
                    break;
                  case "z":
                    n.push("outputZ");
                    break;
                  default:
                    throw this.astErrorOutput("Unexpected expression", l);
                }
                return n;
              case "value":
                throw this.astErrorOutput("Unexpected expression", l);
              case "value[]":
              case "value[][]":
              case "value[][][]":
              case "value.value":
                if (S === "Math")
                  return n.push(Math[m]), n;
                switch (i) {
                  case "r":
                    return n.push(\`user_\${m}[0]\`), n;
                  case "g":
                    return n.push(\`user_\${m}[1]\`), n;
                  case "b":
                    return n.push(\`user_\${m}[2]\`), n;
                  case "a":
                    return n.push(\`user_\${m}[3]\`), n;
                }
                break;
              case "this.constants.value":
              case "this.constants.value[]":
              case "this.constants.value[][]":
              case "this.constants.value[][][]":
                break;
              case "fn()[]":
                return this.astGeneric(l.object, n), n.push("["), this.astGeneric(l.property, n), n.push("]"), n;
              case "fn()[][]":
                return this.astGeneric(l.object.object, n), n.push("["), this.astGeneric(l.object.property, n), n.push("]"), n.push("["), this.astGeneric(l.property, n), n.push("]"), n;
              default:
                throw this.astErrorOutput("Unexpected expression", l);
            }
            if (!l.computed)
              switch (t) {
                case "Number":
                case "Integer":
                case "Float":
                case "Boolean":
                  return n.push(\`\${S}_\${m}\`), n;
              }
            let v = \`\${S}_\${m}\`;
            switch (t) {
              case "Array(2)":
              case "Array(3)":
              case "Array(4)":
              case "Matrix(2)":
              case "Matrix(3)":
              case "Matrix(4)":
              case "HTMLImageArray":
              case "ArrayTexture(1)":
              case "ArrayTexture(2)":
              case "ArrayTexture(3)":
              case "ArrayTexture(4)":
              case "HTMLImage":
              default:
                let h, b;
                if (S === "constants") {
                  let T = this.constants[m];
                  b = this.constantTypes[m] === "Input", h = b ? T.size : null;
                } else
                  b = this.isInput(m), h = b ? this.argumentSizes[this.argumentNames.indexOf(m)] : null;
                n.push(\`\${v}\`), w && x2 ? b ? (n.push("[("), this.astGeneric(w, n), n.push(\`*\${this.dynamicArguments ? "(outputY * outputX)" : h[1] * h[0]})+(\`), this.astGeneric(x2, n), n.push(\`*\${this.dynamicArguments ? "outputX" : h[0]})+\`), this.astGeneric(u, n), n.push("]")) : (n.push("["), this.astGeneric(w, n), n.push("]"), n.push("["), this.astGeneric(x2, n), n.push("]"), n.push("["), this.astGeneric(u, n), n.push("]")) : x2 ? b ? (n.push("[("), this.astGeneric(x2, n), n.push(\`*\${this.dynamicArguments ? "outputX" : h[0]})+\`), this.astGeneric(u, n), n.push("]")) : (n.push("["), this.astGeneric(x2, n), n.push("]"), n.push("["), this.astGeneric(u, n), n.push("]")) : typeof u < "u" && (n.push("["), this.astGeneric(u, n), n.push("]"));
            }
            return n;
          }
          astCallExpression(l, n) {
            if (l.type !== "CallExpression")
              throw this.astErrorOutput("Unknown CallExpression", l);
            let s = this.astMemberExpressionUnroll(l.callee);
            this.calledFunctions.indexOf(s) < 0 && this.calledFunctions.push(s);
            let t = this.isAstMathFunction(l);
            this.onFunctionCall && this.onFunctionCall(this.name, s, l.arguments), n.push(s), n.push("(");
            let i = this.lookupFunctionArgumentTypes(s) || [];
            for (let u = 0; u < l.arguments.length; ++u) {
              let x2 = l.arguments[u], w = this.getType(x2);
              i[u] || this.triggerImplyArgumentType(s, u, w, this), u > 0 && n.push(", "), this.astGeneric(x2, n);
            }
            return n.push(")"), n;
          }
          astArrayExpression(l, n) {
            let s = this.getType(l), t = l.elements.length, i = [];
            for (let u = 0; u < t; ++u) {
              let x2 = [];
              this.astGeneric(l.elements[u], x2), i.push(x2.join(""));
            }
            switch (s) {
              case "Matrix(2)":
              case "Matrix(3)":
              case "Matrix(4)":
                n.push(\`[\${i.join(", ")}]\`);
                break;
              default:
                n.push(\`new Float32Array([\${i.join(", ")}])\`);
            }
            return n;
          }
          astDebuggerStatement(l, n) {
            return n.push("debugger;"), n;
          }
        }
        y.exports = { CPUFunctionNode: g };
      }, { "../function-node": 10 }], 7: [function(o, y, E) {
        let { utils: p } = o("../../utils");
        function g(l, n) {
          let s = [];
          for (let t in n) {
            if (!n.hasOwnProperty(t))
              continue;
            let i = n[t], u = l[t];
            switch (i) {
              case "Number":
              case "Integer":
              case "Float":
              case "Boolean":
                s.push(\`\${t}:\${u}\`);
                break;
              case "Array(2)":
              case "Array(3)":
              case "Array(4)":
              case "Matrix(2)":
              case "Matrix(3)":
              case "Matrix(4)":
                s.push(\`\${t}:new \${u.constructor.name}(\${JSON.stringify(Array.from(u))})\`);
                break;
            }
          }
          return \`{ \${s.join()} }\`;
        }
        function f(l, n) {
          let s = [], t = [], i = [], u = !/^function/.test(l.color.toString());
          if (s.push("  const { context, canvas, constants: incomingConstants } = settings;", \`  const output = new Int32Array(\${JSON.stringify(Array.from(l.output))});\`, \`  const _constantTypes = \${JSON.stringify(l.constantTypes)};\`, \`  const _constants = \${g(l.constants, l.constantTypes)};\`), t.push("    constants: _constants,", "    context,", "    output,", "    thread: {x: 0, y: 0, z: 0},"), l.graphical) {
            s.push(\`  const _imageData = context.createImageData(\${l.output[0]}, \${l.output[1]});\`), s.push(\`  const _colorData = new Uint8ClampedArray(\${l.output[0]} * \${l.output[1]} * 4);\`);
            let m = p.flattenFunctionToString((u ? "function " : "") + l.color.toString(), { thisLookup: (v) => {
              switch (v) {
                case "_colorData":
                  return "_colorData";
                case "_imageData":
                  return "_imageData";
                case "output":
                  return "output";
                case "thread":
                  return "this.thread";
              }
              return JSON.stringify(l[v]);
            }, findDependency: (v, h) => null }), S = p.flattenFunctionToString((u ? "function " : "") + l.getPixels.toString(), { thisLookup: (v) => {
              switch (v) {
                case "_colorData":
                  return "_colorData";
                case "_imageData":
                  return "_imageData";
                case "output":
                  return "output";
                case "thread":
                  return "this.thread";
              }
              return JSON.stringify(l[v]);
            }, findDependency: () => null });
            t.push("    _imageData,", "    _colorData,", \`    color: \${m},\`), i.push(\`  kernel.getPixels = \${S};\`);
          }
          let x2 = [], w = Object.keys(l.constantTypes);
          for (let m = 0; m < w.length; m++)
            x2.push(l.constantTypes[w]);
          if (l.argumentTypes.indexOf("HTMLImageArray") !== -1 || x2.indexOf("HTMLImageArray") !== -1) {
            let m = p.flattenFunctionToString((u ? "function " : "") + l._imageTo3DArray.toString(), { doNotDefine: ["canvas"], findDependency: (S, v) => S === "this" ? (u ? "function " : "") + l[v].toString() : null, thisLookup: (S) => {
              switch (S) {
                case "canvas":
                  return;
                case "context":
                  return "context";
              }
            } });
            i.push(m), t.push("    _mediaTo2DArray,"), t.push("    _imageTo3DArray,");
          } else if (l.argumentTypes.indexOf("HTMLImage") !== -1 || x2.indexOf("HTMLImage") !== -1) {
            let m = p.flattenFunctionToString((u ? "function " : "") + l._mediaTo2DArray.toString(), { findDependency: (S, v) => null, thisLookup: (S) => {
              switch (S) {
                case "canvas":
                  return "settings.canvas";
                case "context":
                  return "settings.context";
              }
              throw new Error("unhandled thisLookup");
            } });
            i.push(m), t.push("    _mediaTo2DArray,");
          }
          return \`function(settings) {
      \${s.join(\`
\`)}
        for (const p in _constantTypes) {
          if (!_constantTypes.hasOwnProperty(p)) continue;
          const type = _constantTypes[p];
          switch (type) {
            case 'Number':
            case 'Integer':
            case 'Float':
            case 'Boolean':
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
              if (incomingConstants.hasOwnProperty(p)) {
                console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
              }
              continue;
          }
          if (!incomingConstants.hasOwnProperty(p)) {
            throw new Error('constant ' + p + ' not found');
          }
          _constants[p] = incomingConstants[p];
        }
        const kernel = (function() {
      \${l._kernelString}
        })
          .apply({ \${t.join(\`
\`)} });
        \${i.join(\`
\`)}
        return kernel;
      }\`;
        }
        y.exports = { cpuKernelString: f };
      }, { "../../utils": 114 }], 8: [function(o, y, E) {
        let { Kernel: p } = o("../kernel"), { FunctionBuilder: g } = o("../function-builder"), { CPUFunctionNode: f } = o("./function-node"), { utils: l } = o("../../utils"), { cpuKernelString: n } = o("./kernel-string");
        class s extends p {
          static getFeatures() {
            return this.features;
          }
          static get features() {
            return Object.freeze({ kernelMap: true, isIntegerDivisionAccurate: true });
          }
          static get isSupported() {
            return true;
          }
          static isContextMatch(i) {
            return false;
          }
          static get mode() {
            return "cpu";
          }
          static nativeFunctionArguments() {
            return null;
          }
          static nativeFunctionReturnType() {
            throw new Error(\`Looking up native function return type not supported on \${this.name}\`);
          }
          static combineKernels(i) {
            return i;
          }
          static getSignature(i, u) {
            return "cpu" + (u.length > 0 ? ":" + u.join(",") : "");
          }
          constructor(i, u) {
            super(i, u), this.mergeSettings(i.settings || u), this._imageData = null, this._colorData = null, this._kernelString = null, this._prependedString = [], this.thread = { x: 0, y: 0, z: 0 }, this.translatedSources = null;
          }
          initCanvas() {
            if (typeof document < "u")
              return document.createElement("canvas");
            if (typeof OffscreenCanvas < "u")
              return new OffscreenCanvas(0, 0);
          }
          initContext() {
            return this.canvas ? this.canvas.getContext("2d") : null;
          }
          initPlugins(i) {
            return [];
          }
          validateSettings(i) {
            if (!this.output || this.output.length === 0) {
              if (i.length !== 1)
                throw new Error("Auto output only supported for kernels with only one input");
              let u = l.getVariableType(i[0], this.strictIntegers);
              if (u === "Array")
                this.output = l.getDimensions(u);
              else if (u === "NumberTexture" || u === "ArrayTexture(4)")
                this.output = i[0].output;
              else
                throw new Error("Auto output not supported for input type: " + u);
            }
            if (this.graphical && this.output.length !== 2)
              throw new Error("Output must have 2 dimensions on graphical mode");
            this.checkOutput();
          }
          translateSource() {
            if (this.leadingReturnStatement = this.output.length > 1 ? "resultX[x] = " : "result[x] = ", this.subKernels) {
              let u = [];
              for (let x2 = 0; x2 < this.subKernels.length; x2++) {
                let { name: w } = this.subKernels[x2];
                u.push(this.output.length > 1 ? \`resultX_\${w}[x] = subKernelResult_\${w};
\` : \`result_\${w}[x] = subKernelResult_\${w};
\`);
              }
              this.followingReturnStatement = u.join("");
            }
            let i = g.fromKernel(this, f);
            this.translatedSources = i.getPrototypes("kernel"), !this.graphical && !this.returnType && (this.returnType = i.getKernelResultType());
          }
          build() {
            if (this.built)
              return;
            if (this.setupConstants(), this.setupArguments(arguments), this.validateSettings(arguments), this.translateSource(), this.graphical) {
              let { canvas: u, output: x2 } = this;
              if (!u)
                throw new Error("no canvas available for using graphical output");
              let w = x2[0], m = x2[1] || 1;
              u.width = w, u.height = m, this._imageData = this.context.createImageData(w, m), this._colorData = new Uint8ClampedArray(w * m * 4);
            }
            let i = this.getKernelString();
            this.kernelString = i, this.debug && (console.log("Function output:"), console.log(i));
            try {
              this.run = new Function([], i).bind(this)();
            } catch (u) {
              console.error("An error occurred compiling the javascript: ", u);
            }
            this.buildSignature(arguments), this.built = true;
          }
          color(i, u, x2, w) {
            typeof w > "u" && (w = 1), i = Math.floor(i * 255), u = Math.floor(u * 255), x2 = Math.floor(x2 * 255), w = Math.floor(w * 255);
            let m = this.output[0], S = this.output[1], v = this.thread.x, h = S - this.thread.y - 1, b = v + h * m;
            this._colorData[b * 4 + 0] = i, this._colorData[b * 4 + 1] = u, this._colorData[b * 4 + 2] = x2, this._colorData[b * 4 + 3] = w;
          }
          getKernelString() {
            if (this._kernelString !== null)
              return this._kernelString;
            let i = null, { translatedSources: u } = this;
            return u.length > 1 ? u = u.filter((x2) => /^function/.test(x2) ? x2 : (i = x2, false)) : i = u.shift(), this._kernelString = \`  const LOOP_MAX = \${this._getLoopMaxString()};
        \${this.injectedNative || ""}
        const _this = this;
        \${this._resultKernelHeader()}
        \${this._processConstants()}
        return (\${this.argumentNames.map((x2) => "user_" + x2).join(", ")}) => {
          \${this._prependedString.join("")}
          \${this._earlyThrows()}
          \${this._processArguments()}
          \${this.graphical ? this._graphicalKernelBody(i) : this._resultKernelBody(i)}
          \${u.length > 0 ? u.join(\`
\`) : ""}
        };\`;
          }
          toString() {
            return n(this);
          }
          _getLoopMaxString() {
            return this.loopMaxIterations ? \` \${parseInt(this.loopMaxIterations)};\` : " 1000;";
          }
          _processConstants() {
            if (!this.constants)
              return "";
            let i = [];
            for (let u in this.constants)
              switch (this.constantTypes[u]) {
                case "HTMLCanvas":
                case "HTMLImage":
                case "HTMLVideo":
                  i.push(\`    const constants_\${u} = this._mediaTo2DArray(this.constants.\${u});
\`);
                  break;
                case "HTMLImageArray":
                  i.push(\`    const constants_\${u} = this._imageTo3DArray(this.constants.\${u});
\`);
                  break;
                case "Input":
                  i.push(\`    const constants_\${u} = this.constants.\${u}.value;
\`);
                  break;
                default:
                  i.push(\`    const constants_\${u} = this.constants.\${u};
\`);
              }
            return i.join("");
          }
          _earlyThrows() {
            if (this.graphical || this.immutable || !this.pipeline)
              return "";
            let i = [];
            for (let x2 = 0; x2 < this.argumentTypes.length; x2++)
              this.argumentTypes[x2] === "Array" && i.push(this.argumentNames[x2]);
            if (i.length === 0)
              return "";
            let u = [];
            for (let x2 = 0; x2 < i.length; x2++) {
              let w = i[x2], m = this._mapSubKernels((S) => \`user_\${w} === result_\${S.name}\`).join(" || ");
              u.push(\`user_\${w} === result\${m ? \` || \${m}\` : ""}\`);
            }
            return \`if (\${u.join(" || ")}) throw new Error('Source and destination arrays are the same.  Use immutable = true');\`;
          }
          _processArguments() {
            let i = [];
            for (let u = 0; u < this.argumentTypes.length; u++) {
              let x2 = \`user_\${this.argumentNames[u]}\`;
              switch (this.argumentTypes[u]) {
                case "HTMLCanvas":
                case "HTMLImage":
                case "HTMLVideo":
                  i.push(\`    \${x2} = this._mediaTo2DArray(\${x2});
\`);
                  break;
                case "HTMLImageArray":
                  i.push(\`    \${x2} = this._imageTo3DArray(\${x2});
\`);
                  break;
                case "Input":
                  i.push(\`    \${x2} = \${x2}.value;
\`);
                  break;
                case "ArrayTexture(1)":
                case "ArrayTexture(2)":
                case "ArrayTexture(3)":
                case "ArrayTexture(4)":
                case "NumberTexture":
                case "MemoryOptimizedNumberTexture":
                  i.push(\`
          if (\${x2}.toArray) {
            if (!_this.textureCache) {
              _this.textureCache = [];
              _this.arrayCache = [];
            }
            const textureIndex = _this.textureCache.indexOf(\${x2});
            if (textureIndex !== -1) {
              \${x2} = _this.arrayCache[textureIndex];
            } else {
              _this.textureCache.push(\${x2});
              \${x2} = \${x2}.toArray();
              _this.arrayCache.push(\${x2});
            }
          }\`);
                  break;
              }
            }
            return i.join("");
          }
          _mediaTo2DArray(i) {
            let u = this.canvas, x2 = i.width > 0 ? i.width : i.videoWidth, w = i.height > 0 ? i.height : i.videoHeight;
            u.width < x2 && (u.width = x2), u.height < w && (u.height = w);
            let m = this.context;
            m.drawImage(i, 0, 0, x2, w);
            let S = m.getImageData(0, 0, x2, w).data, v = new Array(w), h = 0;
            for (let b = w - 1; b >= 0; b--) {
              let T = v[b] = new Array(x2);
              for (let C = 0; C < x2; C++) {
                let V = new Float32Array(4);
                V[0] = S[h++] / 255, V[1] = S[h++] / 255, V[2] = S[h++] / 255, V[3] = S[h++] / 255, T[C] = V;
              }
            }
            return v;
          }
          getPixels(i) {
            let [u, x2] = this.output;
            return i ? l.flipPixels(this._imageData.data, u, x2) : this._imageData.data.slice(0);
          }
          _imageTo3DArray(i) {
            let u = new Array(i.length);
            for (let x2 = 0; x2 < i.length; x2++)
              u[x2] = this._mediaTo2DArray(i[x2]);
            return u;
          }
          _resultKernelHeader() {
            if (this.graphical || this.immutable || !this.pipeline)
              return "";
            switch (this.output.length) {
              case 1:
                return this._mutableKernel1DResults();
              case 2:
                return this._mutableKernel2DResults();
              case 3:
                return this._mutableKernel3DResults();
            }
          }
          _resultKernelBody(i) {
            switch (this.output.length) {
              case 1:
                return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(i) : this._resultImmutableKernel1DLoop(i)) + this._kernelOutput();
              case 2:
                return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(i) : this._resultImmutableKernel2DLoop(i)) + this._kernelOutput();
              case 3:
                return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(i) : this._resultImmutableKernel3DLoop(i)) + this._kernelOutput();
              default:
                throw new Error("unsupported size kernel");
            }
          }
          _graphicalKernelBody(i) {
            switch (this.output.length) {
              case 2:
                return this._graphicalKernel2DLoop(i) + this._graphicalOutput();
              default:
                throw new Error("unsupported size kernel");
            }
          }
          _graphicalOutput() {
            return \`
          this._imageData.data.set(this._colorData);
          this.context.putImageData(this._imageData, 0, 0);
          return;\`;
          }
          _getKernelResultTypeConstructorString() {
            switch (this.returnType) {
              case "LiteralInteger":
              case "Number":
              case "Integer":
              case "Float":
                return "Float32Array";
              case "Array(2)":
              case "Array(3)":
              case "Array(4)":
                return "Array";
              default:
                if (this.graphical)
                  return "Float32Array";
                throw new Error(\`unhandled returnType \${this.returnType}\`);
            }
          }
          _resultImmutableKernel1DLoop(i) {
            let u = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const result = new \${u}(outputX);
          \${this._mapSubKernels((x2) => \`const result_\${x2.name} = new \${u}(outputX);
\`).join("    ")}
          \${this._mapSubKernels((x2) => \`let subKernelResult_\${x2.name};
\`).join("    ")}
          for (let x = 0; x < outputX; x++) {
            this.thread.x = x;
            this.thread.y = 0;
            this.thread.z = 0;
            \${i}
          }\`;
          }
          _mutableKernel1DResults() {
            let i = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const result = new \${i}(outputX);
          \${this._mapSubKernels((u) => \`const result_\${u.name} = new \${i}(outputX);
\`).join("    ")}
          \${this._mapSubKernels((u) => \`let subKernelResult_\${u.name};
\`).join("    ")}\`;
          }
          _resultMutableKernel1DLoop(i) {
            return \`  const outputX = _this.output[0];
          for (let x = 0; x < outputX; x++) {
            this.thread.x = x;
            this.thread.y = 0;
            this.thread.z = 0;
            \${i}
          }\`;
          }
          _resultImmutableKernel2DLoop(i) {
            let u = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const result = new Array(outputY);
          \${this._mapSubKernels((x2) => \`const result_\${x2.name} = new Array(outputY);
\`).join("    ")}
          \${this._mapSubKernels((x2) => \`let subKernelResult_\${x2.name};
\`).join("    ")}
          for (let y = 0; y < outputY; y++) {
            this.thread.z = 0;
            this.thread.y = y;
            const resultX = result[y] = new \${u}(outputX);
            \${this._mapSubKernels((x2) => \`const resultX_\${x2.name} = result_\${x2.name}[y] = new \${u}(outputX);
\`).join("")}
            for (let x = 0; x < outputX; x++) {
              this.thread.x = x;
              \${i}
            }
          }\`;
          }
          _mutableKernel2DResults() {
            let i = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const result = new Array(outputY);
          \${this._mapSubKernels((u) => \`const result_\${u.name} = new Array(outputY);
\`).join("    ")}
          \${this._mapSubKernels((u) => \`let subKernelResult_\${u.name};
\`).join("    ")}
          for (let y = 0; y < outputY; y++) {
            const resultX = result[y] = new \${i}(outputX);
            \${this._mapSubKernels((u) => \`const resultX_\${u.name} = result_\${u.name}[y] = new \${i}(outputX);
\`).join("")}
          }\`;
          }
          _resultMutableKernel2DLoop(i) {
            let u = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          for (let y = 0; y < outputY; y++) {
            this.thread.z = 0;
            this.thread.y = y;
            const resultX = result[y];
            \${this._mapSubKernels((x2) => \`const resultX_\${x2.name} = result_\${x2.name}[y] = new \${u}(outputX);
\`).join("")}
            for (let x = 0; x < outputX; x++) {
              this.thread.x = x;
              \${i}
            }
          }\`;
          }
          _graphicalKernel2DLoop(i) {
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          for (let y = 0; y < outputY; y++) {
            this.thread.z = 0;
            this.thread.y = y;
            for (let x = 0; x < outputX; x++) {
              this.thread.x = x;
              \${i}
            }
          }\`;
          }
          _resultImmutableKernel3DLoop(i) {
            let u = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const outputZ = _this.output[2];
          const result = new Array(outputZ);
          \${this._mapSubKernels((x2) => \`const result_\${x2.name} = new Array(outputZ);
\`).join("    ")}
          \${this._mapSubKernels((x2) => \`let subKernelResult_\${x2.name};
\`).join("    ")}
          for (let z = 0; z < outputZ; z++) {
            this.thread.z = z;
            const resultY = result[z] = new Array(outputY);
            \${this._mapSubKernels((x2) => \`const resultY_\${x2.name} = result_\${x2.name}[z] = new Array(outputY);
\`).join("      ")}
            for (let y = 0; y < outputY; y++) {
              this.thread.y = y;
              const resultX = resultY[y] = new \${u}(outputX);
              \${this._mapSubKernels((x2) => \`const resultX_\${x2.name} = resultY_\${x2.name}[y] = new \${u}(outputX);
\`).join("        ")}
              for (let x = 0; x < outputX; x++) {
                this.thread.x = x;
                \${i}
              }
            }
          }\`;
          }
          _mutableKernel3DResults() {
            let i = this._getKernelResultTypeConstructorString();
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const outputZ = _this.output[2];
          const result = new Array(outputZ);
          \${this._mapSubKernels((u) => \`const result_\${u.name} = new Array(outputZ);
\`).join("    ")}
          \${this._mapSubKernels((u) => \`let subKernelResult_\${u.name};
\`).join("    ")}
          for (let z = 0; z < outputZ; z++) {
            const resultY = result[z] = new Array(outputY);
            \${this._mapSubKernels((u) => \`const resultY_\${u.name} = result_\${u.name}[z] = new Array(outputY);
\`).join("      ")}
            for (let y = 0; y < outputY; y++) {
              const resultX = resultY[y] = new \${i}(outputX);
              \${this._mapSubKernels((u) => \`const resultX_\${u.name} = resultY_\${u.name}[y] = new \${i}(outputX);
\`).join("        ")}
            }
          }\`;
          }
          _resultMutableKernel3DLoop(i) {
            return \`  const outputX = _this.output[0];
          const outputY = _this.output[1];
          const outputZ = _this.output[2];
          for (let z = 0; z < outputZ; z++) {
            this.thread.z = z;
            const resultY = result[z];
            for (let y = 0; y < outputY; y++) {
              this.thread.y = y;
              const resultX = resultY[y];
              for (let x = 0; x < outputX; x++) {
                this.thread.x = x;
                \${i}
              }
            }
          }\`;
          }
          _kernelOutput() {
            return this.subKernels ? \`
    return {
            result: result,
            \${this.subKernels.map((i) => \`\${i.property}: result_\${i.name}\`).join(\`,
      \`)}
          };\` : \`
    return result;\`;
          }
          _mapSubKernels(i) {
            return this.subKernels === null ? [""] : this.subKernels.map(i);
          }
          destroy(i) {
            i && delete this.canvas;
          }
          static destroyContext(i) {
          }
          toJSON() {
            let i = super.toJSON();
            return i.functionNodes = g.fromKernel(this, f).toJSON(), i;
          }
          setOutput(i) {
            super.setOutput(i);
            let [u, x2] = this.output;
            this.graphical && (this._imageData = this.context.createImageData(u, x2), this._colorData = new Uint8ClampedArray(u * x2 * 4));
          }
          prependString(i) {
            if (this._kernelString)
              throw new Error("Kernel already built");
            this._prependedString.push(i);
          }
          hasPrependString(i) {
            return this._prependedString.indexOf(i) > -1;
          }
        }
        y.exports = { CPUKernel: s };
      }, { "../../utils": 114, "../function-builder": 9, "../kernel": 36, "./function-node": 6, "./kernel-string": 7 }], 9: [function(o, y, E) {
        class p {
          static fromKernel(f, l, n) {
            let { kernelArguments: s, kernelConstants: t, argumentNames: i, argumentSizes: u, argumentBitRatios: x2, constants: w, constantBitRatios: m, debug: S, loopMaxIterations: v, nativeFunctions: h, output: b, optimizeFloatMemory: T, precision: C, plugins: V, source: c, subKernels: a, functions: k, leadingReturnStatement: A, followingReturnStatement: N, dynamicArguments: F, dynamicOutput: L } = f, K = new Array(s.length), O = {};
            for (let te = 0; te < s.length; te++)
              K[te] = s[te].type;
            for (let te = 0; te < t.length; te++) {
              let re = t[te];
              O[re.name] = re.type;
            }
            let X = (te, re) => pe.needsArgumentType(te, re), B = (te, re, de) => {
              pe.assignArgumentType(te, re, de);
            }, P = (te, re, de) => pe.lookupReturnType(te, re, de), Y = (te) => pe.lookupFunctionArgumentTypes(te), J = (te, re) => pe.lookupFunctionArgumentName(te, re), q = (te, re) => pe.lookupFunctionArgumentBitRatio(te, re), j = (te, re, de, Te) => {
              pe.assignArgumentType(te, re, de, Te);
            }, U = (te, re, de, Te) => {
              pe.assignArgumentBitRatio(te, re, de, Te);
            }, oe = (te, re, de) => {
              pe.trackFunctionCall(te, re, de);
            }, Z = (te, re) => {
              let de = [];
              for (let Se = 0; Se < te.params.length; Se++)
                de.push(te.params[Se].name);
              let Te = new l(re, Object.assign({}, ee, { returnType: null, ast: te, name: te.id.name, argumentNames: de, lookupReturnType: P, lookupFunctionArgumentTypes: Y, lookupFunctionArgumentName: J, lookupFunctionArgumentBitRatio: q, needsArgumentType: X, assignArgumentType: B, triggerImplyArgumentType: j, triggerImplyArgumentBitRatio: U, onFunctionCall: oe }));
              Te.traceFunctionAST(te), pe.addFunctionNode(Te);
            }, ee = Object.assign({ isRootKernel: false, onNestedFunction: Z, lookupReturnType: P, lookupFunctionArgumentTypes: Y, lookupFunctionArgumentName: J, lookupFunctionArgumentBitRatio: q, needsArgumentType: X, assignArgumentType: B, triggerImplyArgumentType: j, triggerImplyArgumentBitRatio: U, onFunctionCall: oe, optimizeFloatMemory: T, precision: C, constants: w, constantTypes: O, constantBitRatios: m, debug: S, loopMaxIterations: v, output: b, plugins: V, dynamicArguments: F, dynamicOutput: L }, n || {}), be = Object.assign({}, ee, { isRootKernel: true, name: "kernel", argumentNames: i, argumentTypes: K, argumentSizes: u, argumentBitRatios: x2, leadingReturnStatement: A, followingReturnStatement: N });
            if (typeof c == "object" && c.functionNodes)
              return new p().fromJSON(c.functionNodes, l);
            let Q = new l(c, be), ue = null;
            k && (ue = k.map((te) => new l(te.source, { returnType: te.returnType, argumentTypes: te.argumentTypes, output: b, plugins: V, constants: w, constantTypes: O, constantBitRatios: m, optimizeFloatMemory: T, precision: C, lookupReturnType: P, lookupFunctionArgumentTypes: Y, lookupFunctionArgumentName: J, lookupFunctionArgumentBitRatio: q, needsArgumentType: X, assignArgumentType: B, triggerImplyArgumentType: j, triggerImplyArgumentBitRatio: U, onFunctionCall: oe, onNestedFunction: Z })));
            let he = null;
            a && (he = a.map((te) => {
              let { name: re, source: de } = te;
              return new l(de, Object.assign({}, ee, { name: re, isSubKernel: true, isRootKernel: false }));
            }));
            let pe = new p({ kernel: f, rootNode: Q, functionNodes: ue, nativeFunctions: h, subKernelNodes: he });
            return pe;
          }
          constructor(f) {
            if (f = f || {}, this.kernel = f.kernel, this.rootNode = f.rootNode, this.functionNodes = f.functionNodes || [], this.subKernelNodes = f.subKernelNodes || [], this.nativeFunctions = f.nativeFunctions || [], this.functionMap = {}, this.nativeFunctionNames = [], this.lookupChain = [], this.functionNodeDependencies = {}, this.functionCalls = {}, this.rootNode && (this.functionMap.kernel = this.rootNode), this.functionNodes)
              for (let l = 0; l < this.functionNodes.length; l++)
                this.functionMap[this.functionNodes[l].name] = this.functionNodes[l];
            if (this.subKernelNodes)
              for (let l = 0; l < this.subKernelNodes.length; l++)
                this.functionMap[this.subKernelNodes[l].name] = this.subKernelNodes[l];
            if (this.nativeFunctions)
              for (let l = 0; l < this.nativeFunctions.length; l++) {
                let n = this.nativeFunctions[l];
                this.nativeFunctionNames.push(n.name);
              }
          }
          addFunctionNode(f) {
            if (!f.name)
              throw new Error("functionNode.name needs set");
            this.functionMap[f.name] = f, f.isRootKernel && (this.rootNode = f);
          }
          traceFunctionCalls(f, l) {
            if (f = f || "kernel", l = l || [], this.nativeFunctionNames.indexOf(f) > -1) {
              let s = l.indexOf(f);
              if (s === -1)
                l.push(f);
              else {
                let t = l.splice(s, 1)[0];
                l.push(t);
              }
              return l;
            }
            let n = this.functionMap[f];
            if (n) {
              let s = l.indexOf(f);
              if (s === -1) {
                l.push(f), n.toString();
                for (let t = 0; t < n.calledFunctions.length; ++t)
                  this.traceFunctionCalls(n.calledFunctions[t], l);
              } else {
                let t = l.splice(s, 1)[0];
                l.push(t);
              }
            }
            return l;
          }
          getPrototypeString(f) {
            return this.getPrototypes(f).join(\`
\`);
          }
          getPrototypes(f) {
            return this.rootNode && this.rootNode.toString(), f ? this.getPrototypesFromFunctionNames(this.traceFunctionCalls(f, []).reverse()) : this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
          }
          getStringFromFunctionNames(f) {
            let l = [];
            for (let n = 0; n < f.length; ++n)
              this.functionMap[f[n]] && l.push(this.functionMap[f[n]].toString());
            return l.join(\`
\`);
          }
          getPrototypesFromFunctionNames(f) {
            let l = [];
            for (let n = 0; n < f.length; ++n) {
              let s = f[n], t = this.nativeFunctionNames.indexOf(s);
              if (t > -1) {
                l.push(this.nativeFunctions[t].source);
                continue;
              }
              let i = this.functionMap[s];
              i && l.push(i.toString());
            }
            return l;
          }
          toJSON() {
            return this.traceFunctionCalls(this.rootNode.name).reverse().map((f) => {
              let l = this.nativeFunctions.indexOf(f);
              if (l > -1)
                return { name: f, source: this.nativeFunctions[l].source };
              if (this.functionMap[f])
                return this.functionMap[f].toJSON();
              throw new Error(\`function \${f} not found\`);
            });
          }
          fromJSON(f, l) {
            this.functionMap = {};
            for (let n = 0; n < f.length; n++) {
              let s = f[n];
              this.functionMap[s.settings.name] = new l(s.ast, s.settings);
            }
            return this;
          }
          getString(f) {
            return f ? this.getStringFromFunctionNames(this.traceFunctionCalls(f).reverse()) : this.getStringFromFunctionNames(Object.keys(this.functionMap));
          }
          lookupReturnType(f, l, n) {
            if (l.type !== "CallExpression")
              throw new Error(\`expected ast type of "CallExpression", but is \${l.type}\`);
            if (this._isNativeFunction(f))
              return this._lookupNativeFunctionReturnType(f);
            if (this._isFunction(f)) {
              let s = this._getFunction(f);
              if (s.returnType)
                return s.returnType;
              {
                for (let i = 0; i < this.lookupChain.length; i++)
                  if (this.lookupChain[i].ast === l) {
                    if (s.argumentTypes.length === 0 && l.arguments.length > 0) {
                      let u = l.arguments;
                      for (let x2 = 0; x2 < u.length; x2++)
                        this.lookupChain.push({ name: n.name, ast: u[i], requestingNode: n }), s.argumentTypes[x2] = n.getType(u[x2]), this.lookupChain.pop();
                      return s.returnType = s.getType(s.getJsAST());
                    }
                    throw new Error("circlical logic detected!");
                  }
                this.lookupChain.push({ name: n.name, ast: l, requestingNode: n });
                let t = s.getType(s.getJsAST());
                return this.lookupChain.pop(), s.returnType = t;
              }
            }
            return null;
          }
          _getFunction(f) {
            return this._isFunction(f) || new Error(\`Function \${f} not found\`), this.functionMap[f];
          }
          _isFunction(f) {
            return Boolean(this.functionMap[f]);
          }
          _getNativeFunction(f) {
            for (let l = 0; l < this.nativeFunctions.length; l++)
              if (this.nativeFunctions[l].name === f)
                return this.nativeFunctions[l];
            return null;
          }
          _isNativeFunction(f) {
            return Boolean(this._getNativeFunction(f));
          }
          _lookupNativeFunctionReturnType(f) {
            let l = this._getNativeFunction(f);
            if (l)
              return l.returnType;
            throw new Error(\`Native function \${f} not found\`);
          }
          lookupFunctionArgumentTypes(f) {
            return this._isNativeFunction(f) ? this._getNativeFunction(f).argumentTypes : this._isFunction(f) ? this._getFunction(f).argumentTypes : null;
          }
          lookupFunctionArgumentName(f, l) {
            return this._getFunction(f).argumentNames[l];
          }
          lookupFunctionArgumentBitRatio(f, l) {
            if (!this._isFunction(f))
              throw new Error("function not found");
            if (this.rootNode.name === f) {
              let i = this.rootNode.argumentNames.indexOf(l);
              if (i !== -1)
                return this.rootNode.argumentBitRatios[i];
            }
            let n = this._getFunction(f), s = n.argumentNames.indexOf(l);
            if (s === -1)
              throw new Error("argument not found");
            let t = n.argumentBitRatios[s];
            if (typeof t != "number")
              throw new Error("argument bit ratio not found");
            return t;
          }
          needsArgumentType(f, l) {
            return this._isFunction(f) ? !this._getFunction(f).argumentTypes[l] : false;
          }
          assignArgumentType(f, l, n, s) {
            if (!this._isFunction(f))
              return;
            let t = this._getFunction(f);
            t.argumentTypes[l] || (t.argumentTypes[l] = n);
          }
          assignArgumentBitRatio(f, l, n, s) {
            let t = this._getFunction(f);
            if (this._isNativeFunction(n))
              return null;
            let i = this._getFunction(n), u = t.argumentNames.indexOf(l);
            if (u === -1)
              throw new Error(\`Argument \${l} not found in arguments from function \${f}\`);
            let x2 = t.argumentBitRatios[u];
            if (typeof x2 != "number")
              throw new Error(\`Bit ratio for argument \${l} not found in function \${f}\`);
            i.argumentBitRatios || (i.argumentBitRatios = new Array(i.argumentNames.length));
            let w = i.argumentBitRatios[u];
            if (typeof w == "number") {
              if (w !== x2)
                throw new Error(\`Incompatible bit ratio found at function \${f} at argument \${l}\`);
              return w;
            }
            return i.argumentBitRatios[u] = x2, x2;
          }
          trackFunctionCall(f, l, n) {
            this.functionNodeDependencies[f] || (this.functionNodeDependencies[f] = /* @__PURE__ */ new Set(), this.functionCalls[f] = []), this.functionNodeDependencies[f].add(l), this.functionCalls[f].push(n);
          }
          getKernelResultType() {
            return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
          }
          getSubKernelResultType(f) {
            let l = this.subKernelNodes[f], n = false;
            for (let s = 0; s < this.rootNode.functionCalls.length; s++)
              this.rootNode.functionCalls[s].ast.callee.name === l.name && (n = true);
            if (!n)
              throw new Error(\`SubKernel \${l.name} never called by kernel\`);
            return l.returnType || l.getType(l.getJsAST());
          }
          getReturnTypes() {
            let f = { [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast) }, l = this.traceFunctionCalls(this.rootNode.name);
            for (let n = 0; n < l.length; n++) {
              let s = l[n], t = this.functionMap[s];
              f[s] = t.getType(t.ast);
            }
            return f;
          }
        }
        y.exports = { FunctionBuilder: p };
      }, {}], 10: [function(o, y, E) {
        let p = o("acorn"), { utils: g } = o("../utils"), { FunctionTracer: f } = o("./function-tracer");
        class l {
          constructor(t, i) {
            if (!t && !i.ast)
              throw new Error("source parameter is missing");
            if (i = i || {}, this.source = t, this.ast = null, this.name = typeof t == "string" ? i.isRootKernel ? "kernel" : i.name || g.getFunctionNameFromString(t) : null, this.calledFunctions = [], this.constants = {}, this.constantTypes = {}, this.constantBitRatios = {}, this.isRootKernel = false, this.isSubKernel = false, this.debug = null, this.functions = null, this.identifiers = null, this.contexts = null, this.functionCalls = null, this.states = [], this.needsArgumentType = null, this.assignArgumentType = null, this.lookupReturnType = null, this.lookupFunctionArgumentTypes = null, this.lookupFunctionArgumentBitRatio = null, this.triggerImplyArgumentType = null, this.triggerImplyArgumentBitRatio = null, this.onNestedFunction = null, this.onFunctionCall = null, this.optimizeFloatMemory = null, this.precision = null, this.loopMaxIterations = null, this.argumentNames = typeof this.source == "string" ? g.getArgumentNamesFromString(this.source) : null, this.argumentTypes = [], this.argumentSizes = [], this.argumentBitRatios = null, this.returnType = null, this.output = [], this.plugins = null, this.leadingReturnStatement = null, this.followingReturnStatement = null, this.dynamicOutput = null, this.dynamicArguments = null, this.strictTypingChecking = false, this.fixIntegerDivisionAccuracy = null, i)
              for (let u in i)
                !i.hasOwnProperty(u) || !this.hasOwnProperty(u) || (this[u] = i[u]);
            this.literalTypes = {}, this.validate(), this._string = null, this._internalVariableNames = {};
          }
          validate() {
            if (typeof this.source != "string" && !this.ast)
              throw new Error("this.source not a string");
            if (!this.ast && !g.isFunctionString(this.source))
              throw new Error("this.source not a function string");
            if (!this.name)
              throw new Error("this.name could not be set");
            if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length)
              throw new Error(\`argumentTypes count of \${this.argumentTypes.length} exceeds \${this.argumentNames.length}\`);
            if (this.output.length < 1)
              throw new Error("this.output is not big enough");
          }
          isIdentifierConstant(t) {
            return this.constants ? this.constants.hasOwnProperty(t) : false;
          }
          isInput(t) {
            return this.argumentTypes[this.argumentNames.indexOf(t)] === "Input";
          }
          pushState(t) {
            this.states.push(t);
          }
          popState(t) {
            if (this.state !== t)
              throw new Error(\`Cannot popState \${t} when in \${this.state}\`);
            this.states.pop();
          }
          isState(t) {
            return this.state === t;
          }
          get state() {
            return this.states[this.states.length - 1];
          }
          astMemberExpressionUnroll(t) {
            if (t.type === "Identifier")
              return t.name;
            if (t.type === "ThisExpression")
              return "this";
            if (t.type === "MemberExpression" && t.object && t.property)
              return t.object.hasOwnProperty("name") && t.object.name !== "Math" ? this.astMemberExpressionUnroll(t.property) : this.astMemberExpressionUnroll(t.object) + "." + this.astMemberExpressionUnroll(t.property);
            if (t.hasOwnProperty("expressions")) {
              let i = t.expressions[0];
              if (i.type === "Literal" && i.value === 0 && t.expressions.length === 2)
                return this.astMemberExpressionUnroll(t.expressions[1]);
            }
            throw this.astErrorOutput("Unknown astMemberExpressionUnroll", t);
          }
          getJsAST(t) {
            if (this.ast)
              return this.ast;
            if (typeof this.source == "object")
              return this.traceFunctionAST(this.source), this.ast = this.source;
            if (t = t || p, t === null)
              throw new Error("Missing JS to AST parser");
            let i = Object.freeze(t.parse(\`const parser_\${this.name} = \${this.source};\`, { locations: true })), u = i.body[0].declarations[0].init;
            if (this.traceFunctionAST(u), !i)
              throw new Error("Failed to parse JS code");
            return this.ast = u;
          }
          traceFunctionAST(t) {
            let { contexts: i, declarations: u, functions: x2, identifiers: w, functionCalls: m } = new f(t);
            this.contexts = i, this.identifiers = w, this.functionCalls = m, this.functions = x2;
            for (let S = 0; S < u.length; S++) {
              let v = u[S], { ast: h, inForLoopInit: b, inForLoopTest: T } = v, { init: C } = h, V = this.getDependencies(C), c = null;
              if (b && T)
                c = "Integer";
              else if (C) {
                let a = this.getType(C);
                switch (a) {
                  case "Integer":
                  case "Float":
                  case "Number":
                    C.type === "MemberExpression" ? c = a : c = "Number";
                    break;
                  case "LiteralInteger":
                    c = "Number";
                    break;
                  default:
                    c = a;
                }
              }
              v.valueType = c, v.dependencies = V, v.isSafe = this.isSafeDependencies(V);
            }
            for (let S = 0; S < x2.length; S++)
              this.onNestedFunction(x2[S], this.source);
          }
          getDeclaration(t) {
            for (let i = 0; i < this.identifiers.length; i++) {
              let u = this.identifiers[i];
              if (t === u.ast)
                return u.declaration;
            }
            return null;
          }
          getVariableType(t) {
            if (t.type !== "Identifier")
              throw new Error(\`ast of \${t.type} not "Identifier"\`);
            let i = null, u = this.argumentNames.indexOf(t.name);
            if (u === -1) {
              let x2 = this.getDeclaration(t);
              if (x2)
                return x2.valueType;
            } else {
              let x2 = this.argumentTypes[u];
              x2 && (i = x2);
            }
            if (!i && this.strictTypingChecking)
              throw new Error(\`Declaration of \${name} not found\`);
            return i;
          }
          getLookupType(t) {
            if (!n.hasOwnProperty(t))
              throw new Error(\`unknown typeLookupMap \${t}\`);
            return n[t];
          }
          getConstantType(t) {
            if (this.constantTypes[t]) {
              let i = this.constantTypes[t];
              return i === "Float" ? "Number" : i;
            }
            throw new Error(\`Type for constant "\${t}" not declared\`);
          }
          toString() {
            return this._string ? this._string : this._string = this.astGeneric(this.getJsAST(), []).join("").trim();
          }
          toJSON() {
            let t = { source: this.source, name: this.name, constants: this.constants, constantTypes: this.constantTypes, isRootKernel: this.isRootKernel, isSubKernel: this.isSubKernel, debug: this.debug, output: this.output, loopMaxIterations: this.loopMaxIterations, argumentNames: this.argumentNames, argumentTypes: this.argumentTypes, argumentSizes: this.argumentSizes, returnType: this.returnType, leadingReturnStatement: this.leadingReturnStatement, followingReturnStatement: this.followingReturnStatement };
            return { ast: this.ast, settings: t };
          }
          getType(t) {
            if (Array.isArray(t))
              return this.getType(t[t.length - 1]);
            switch (t.type) {
              case "BlockStatement":
                return this.getType(t.body);
              case "ArrayExpression":
                switch (this.getType(t.elements[0])) {
                  case "Array(2)":
                  case "Array(3)":
                  case "Array(4)":
                    return \`Matrix(\${t.elements.length})\`;
                }
                return \`Array(\${t.elements.length})\`;
              case "Literal":
                let u = this.astKey(t);
                return this.literalTypes[u] ? this.literalTypes[u] : Number.isInteger(t.value) ? "LiteralInteger" : t.value === true || t.value === false ? "Boolean" : "Number";
              case "AssignmentExpression":
                return this.getType(t.left);
              case "CallExpression":
                if (this.isAstMathFunction(t))
                  return "Number";
                if (!t.callee || !t.callee.name) {
                  if (t.callee.type === "SequenceExpression" && t.callee.expressions[t.callee.expressions.length - 1].property.name) {
                    let v = t.callee.expressions[t.callee.expressions.length - 1].property.name;
                    return this.inferArgumentTypesIfNeeded(v, t.arguments), this.lookupReturnType(v, t, this);
                  }
                  if (this.getVariableSignature(t.callee, true) === "this.color")
                    return null;
                  if (t.callee.type === "MemberExpression" && t.callee.object && t.callee.property && t.callee.property.name && t.arguments) {
                    let v = t.callee.property.name;
                    return this.inferArgumentTypesIfNeeded(v, t.arguments), this.lookupReturnType(v, t, this);
                  }
                  throw this.astErrorOutput("Unknown call expression", t);
                }
                if (t.callee && t.callee.name) {
                  let v = t.callee.name;
                  return this.inferArgumentTypesIfNeeded(v, t.arguments), this.lookupReturnType(v, t, this);
                }
                throw this.astErrorOutput(\`Unhandled getType Type "\${t.type}"\`, t);
              case "LogicalExpression":
                return "Boolean";
              case "BinaryExpression":
                switch (t.operator) {
                  case "%":
                  case "/":
                    if (this.fixIntegerDivisionAccuracy)
                      return "Number";
                    break;
                  case ">":
                  case "<":
                    return "Boolean";
                  case "&":
                  case "|":
                  case "^":
                  case "<<":
                  case ">>":
                  case ">>>":
                    return "Integer";
                }
                let x2 = this.getType(t.left);
                if (this.isState("skip-literal-correction"))
                  return x2;
                if (x2 === "LiteralInteger") {
                  let v = this.getType(t.right);
                  return v === "LiteralInteger" ? t.left.value % 1 === 0 ? "Integer" : "Float" : v;
                }
                return n[x2] || x2;
              case "UpdateExpression":
                return this.getType(t.argument);
              case "UnaryExpression":
                return t.operator === "~" ? "Integer" : this.getType(t.argument);
              case "VariableDeclaration": {
                let v = t.declarations, h;
                for (let b = 0; b < v.length; b++) {
                  let T = v[b];
                  h = this.getType(T);
                }
                if (!h)
                  throw this.astErrorOutput("Unable to find type for declaration", t);
                return h;
              }
              case "VariableDeclarator":
                let w = this.getDeclaration(t.id);
                if (!w)
                  throw this.astErrorOutput("Unable to find declarator", t);
                if (!w.valueType)
                  throw this.astErrorOutput("Unable to find declarator valueType", t);
                return w.valueType;
              case "Identifier":
                if (t.name === "Infinity")
                  return "Number";
                if (this.isAstVariable(t) && this.getVariableSignature(t) === "value")
                  return this.getCheckVariableType(t);
                let m = this.findIdentifierOrigin(t);
                return m && m.init ? this.getType(m.init) : null;
              case "ReturnStatement":
                return this.getType(t.argument);
              case "MemberExpression":
                if (this.isAstMathFunction(t)) {
                  switch (t.property.name) {
                    case "ceil":
                      return "Integer";
                    case "floor":
                      return "Integer";
                    case "round":
                      return "Integer";
                  }
                  return "Number";
                }
                if (this.isAstVariable(t)) {
                  switch (this.getVariableSignature(t)) {
                    case "value[]":
                      return this.getLookupType(this.getCheckVariableType(t.object));
                    case "value[][]":
                      return this.getLookupType(this.getCheckVariableType(t.object.object));
                    case "value[][][]":
                      return this.getLookupType(this.getCheckVariableType(t.object.object.object));
                    case "value[][][][]":
                      return this.getLookupType(this.getCheckVariableType(t.object.object.object.object));
                    case "value.thread.value":
                    case "this.thread.value":
                      return "Integer";
                    case "this.output.value":
                      return this.dynamicOutput ? "Integer" : "LiteralInteger";
                    case "this.constants.value":
                      return this.getConstantType(t.property.name);
                    case "this.constants.value[]":
                      return this.getLookupType(this.getConstantType(t.object.property.name));
                    case "this.constants.value[][]":
                      return this.getLookupType(this.getConstantType(t.object.object.property.name));
                    case "this.constants.value[][][]":
                      return this.getLookupType(this.getConstantType(t.object.object.object.property.name));
                    case "this.constants.value[][][][]":
                      return this.getLookupType(this.getConstantType(t.object.object.object.object.property.name));
                    case "fn()[]":
                    case "fn()[][]":
                    case "fn()[][][]":
                      return this.getLookupType(this.getType(t.object));
                    case "value.value":
                      if (this.isAstMathVariable(t))
                        return "Number";
                      switch (t.property.name) {
                        case "r":
                        case "g":
                        case "b":
                        case "a":
                          return this.getLookupType(this.getCheckVariableType(t.object));
                      }
                    case "[][]":
                      return "Number";
                  }
                  throw this.astErrorOutput("Unhandled getType MemberExpression", t);
                }
                throw this.astErrorOutput("Unhandled getType MemberExpression", t);
              case "ConditionalExpression":
                return this.getType(t.consequent);
              case "FunctionDeclaration":
              case "FunctionExpression":
                let S = this.findLastReturn(t.body);
                return S ? this.getType(S) : null;
              case "IfStatement":
                return this.getType(t.consequent);
              case "SequenceExpression":
                return this.getType(t.expressions[t.expressions.length - 1]);
              default:
                throw this.astErrorOutput(\`Unhandled getType Type "\${t.type}"\`, t);
            }
          }
          getCheckVariableType(t) {
            let i = this.getVariableType(t);
            if (!i)
              throw this.astErrorOutput(\`\${t.type} is not defined\`, t);
            return i;
          }
          inferArgumentTypesIfNeeded(t, i) {
            for (let u = 0; u < i.length; u++) {
              if (!this.needsArgumentType(t, u))
                continue;
              let x2 = this.getType(i[u]);
              if (!x2)
                throw this.astErrorOutput(\`Unable to infer argument \${u}\`, i[u]);
              this.assignArgumentType(t, u, x2);
            }
          }
          isAstMathVariable(t) {
            let i = ["E", "PI", "SQRT2", "SQRT1_2", "LN2", "LN10", "LOG2E", "LOG10E"];
            return t.type === "MemberExpression" && t.object && t.object.type === "Identifier" && t.object.name === "Math" && t.property && t.property.type === "Identifier" && i.indexOf(t.property.name) > -1;
          }
          isAstMathFunction(t) {
            let i = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atan2", "atanh", "cbrt", "ceil", "clz32", "cos", "cosh", "expm1", "exp", "floor", "fround", "imul", "log", "log2", "log10", "log1p", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc"];
            return t.type === "CallExpression" && t.callee && t.callee.type === "MemberExpression" && t.callee.object && t.callee.object.type === "Identifier" && t.callee.object.name === "Math" && t.callee.property && t.callee.property.type === "Identifier" && i.indexOf(t.callee.property.name) > -1;
          }
          isAstVariable(t) {
            return t.type === "Identifier" || t.type === "MemberExpression";
          }
          isSafe(t) {
            return this.isSafeDependencies(this.getDependencies(t));
          }
          isSafeDependencies(t) {
            return t && t.every ? t.every((i) => i.isSafe) : true;
          }
          getDependencies(t, i, u) {
            if (i || (i = []), !t)
              return null;
            if (Array.isArray(t)) {
              for (let x2 = 0; x2 < t.length; x2++)
                this.getDependencies(t[x2], i, u);
              return i;
            }
            switch (t.type) {
              case "AssignmentExpression":
                return this.getDependencies(t.left, i, u), this.getDependencies(t.right, i, u), i;
              case "ConditionalExpression":
                return this.getDependencies(t.test, i, u), this.getDependencies(t.alternate, i, u), this.getDependencies(t.consequent, i, u), i;
              case "Literal":
                i.push({ origin: "literal", value: t.value, isSafe: u === true ? false : t.value > -1 / 0 && t.value < 1 / 0 && !isNaN(t.value) });
                break;
              case "VariableDeclarator":
                return this.getDependencies(t.init, i, u);
              case "Identifier":
                let x2 = this.getDeclaration(t);
                if (x2)
                  i.push({ name: t.name, origin: "declaration", isSafe: u ? false : this.isSafeDependencies(x2.dependencies) });
                else if (this.argumentNames.indexOf(t.name) > -1)
                  i.push({ name: t.name, origin: "argument", isSafe: false });
                else if (this.strictTypingChecking)
                  throw new Error(\`Cannot find identifier origin "\${t.name}"\`);
                break;
              case "FunctionDeclaration":
                return this.getDependencies(t.body.body[t.body.body.length - 1], i, u);
              case "ReturnStatement":
                return this.getDependencies(t.argument, i);
              case "BinaryExpression":
              case "LogicalExpression":
                return u = t.operator === "/" || t.operator === "*", this.getDependencies(t.left, i, u), this.getDependencies(t.right, i, u), i;
              case "UnaryExpression":
              case "UpdateExpression":
                return this.getDependencies(t.argument, i, u);
              case "VariableDeclaration":
                return this.getDependencies(t.declarations, i, u);
              case "ArrayExpression":
                return i.push({ origin: "declaration", isSafe: true }), i;
              case "CallExpression":
                return i.push({ origin: "function", isSafe: true }), i;
              case "MemberExpression":
                let w = this.getMemberExpressionDetails(t);
                switch (w.signature) {
                  case "value[]":
                    this.getDependencies(t.object, i, u);
                    break;
                  case "value[][]":
                    this.getDependencies(t.object.object, i, u);
                    break;
                  case "value[][][]":
                    this.getDependencies(t.object.object.object, i, u);
                    break;
                  case "this.output.value":
                    this.dynamicOutput && i.push({ name: w.name, origin: "output", isSafe: false });
                    break;
                }
                if (w)
                  return w.property && this.getDependencies(w.property, i, u), w.xProperty && this.getDependencies(w.xProperty, i, u), w.yProperty && this.getDependencies(w.yProperty, i, u), w.zProperty && this.getDependencies(w.zProperty, i, u), i;
              case "SequenceExpression":
                return this.getDependencies(t.expressions, i, u);
              default:
                throw this.astErrorOutput(\`Unhandled type \${t.type} in getDependencies\`, t);
            }
            return i;
          }
          getVariableSignature(t, i) {
            if (!this.isAstVariable(t))
              throw new Error(\`ast of type "\${t.type}" is not a variable signature\`);
            if (t.type === "Identifier")
              return "value";
            let u = [];
            for (; t; )
              t.computed ? u.push("[]") : t.type === "ThisExpression" ? u.unshift("this") : t.property && t.property.name ? t.property.name === "x" || t.property.name === "y" || t.property.name === "z" ? u.unshift(i ? "." + t.property.name : ".value") : t.property.name === "constants" || t.property.name === "thread" || t.property.name === "output" ? u.unshift("." + t.property.name) : u.unshift(i ? "." + t.property.name : ".value") : t.name ? u.unshift(i ? t.name : "value") : t.callee && t.callee.name ? u.unshift(i ? t.callee.name + "()" : "fn()") : t.elements ? u.unshift("[]") : u.unshift("unknown"), t = t.object;
            let x2 = u.join("");
            return i || ["value", "value[]", "value[][]", "value[][][]", "value[][][][]", "value.value", "value.thread.value", "this.thread.value", "this.output.value", "this.constants.value", "this.constants.value[]", "this.constants.value[][]", "this.constants.value[][][]", "this.constants.value[][][][]", "fn()[]", "fn()[][]", "fn()[][][]", "[][]"].indexOf(x2) > -1 ? x2 : null;
          }
          build() {
            return this.toString().length > 0;
          }
          astGeneric(t, i) {
            if (t === null)
              throw this.astErrorOutput("NULL ast", t);
            if (Array.isArray(t)) {
              for (let u = 0; u < t.length; u++)
                this.astGeneric(t[u], i);
              return i;
            }
            switch (t.type) {
              case "FunctionDeclaration":
                return this.astFunctionDeclaration(t, i);
              case "FunctionExpression":
                return this.astFunctionExpression(t, i);
              case "ReturnStatement":
                return this.astReturnStatement(t, i);
              case "Literal":
                return this.astLiteral(t, i);
              case "BinaryExpression":
                return this.astBinaryExpression(t, i);
              case "Identifier":
                return this.astIdentifierExpression(t, i);
              case "AssignmentExpression":
                return this.astAssignmentExpression(t, i);
              case "ExpressionStatement":
                return this.astExpressionStatement(t, i);
              case "EmptyStatement":
                return this.astEmptyStatement(t, i);
              case "BlockStatement":
                return this.astBlockStatement(t, i);
              case "IfStatement":
                return this.astIfStatement(t, i);
              case "SwitchStatement":
                return this.astSwitchStatement(t, i);
              case "BreakStatement":
                return this.astBreakStatement(t, i);
              case "ContinueStatement":
                return this.astContinueStatement(t, i);
              case "ForStatement":
                return this.astForStatement(t, i);
              case "WhileStatement":
                return this.astWhileStatement(t, i);
              case "DoWhileStatement":
                return this.astDoWhileStatement(t, i);
              case "VariableDeclaration":
                return this.astVariableDeclaration(t, i);
              case "VariableDeclarator":
                return this.astVariableDeclarator(t, i);
              case "ThisExpression":
                return this.astThisExpression(t, i);
              case "SequenceExpression":
                return this.astSequenceExpression(t, i);
              case "UnaryExpression":
                return this.astUnaryExpression(t, i);
              case "UpdateExpression":
                return this.astUpdateExpression(t, i);
              case "LogicalExpression":
                return this.astLogicalExpression(t, i);
              case "MemberExpression":
                return this.astMemberExpression(t, i);
              case "CallExpression":
                return this.astCallExpression(t, i);
              case "ArrayExpression":
                return this.astArrayExpression(t, i);
              case "DebuggerStatement":
                return this.astDebuggerStatement(t, i);
              case "ConditionalExpression":
                return this.astConditionalExpression(t, i);
            }
            throw this.astErrorOutput("Unknown ast type : " + t.type, t);
          }
          astErrorOutput(t, i) {
            if (typeof this.source != "string")
              return new Error(t);
            let u = g.getAstString(this.source, i), w = this.source.substr(i.start).split(/\\n/), m = w.length > 0 ? w[w.length - 1] : 0;
            return new Error(\`\${t} on line \${w.length}, position \${m.length}:
 \${u}\`);
          }
          astDebuggerStatement(t, i) {
            return i;
          }
          astConditionalExpression(t, i) {
            if (t.type !== "ConditionalExpression")
              throw this.astErrorOutput("Not a conditional expression", t);
            return i.push("("), this.astGeneric(t.test, i), i.push("?"), this.astGeneric(t.consequent, i), i.push(":"), this.astGeneric(t.alternate, i), i.push(")"), i;
          }
          astFunction(t, i) {
            throw new Error(\`"astFunction" not defined on \${this.constructor.name}\`);
          }
          astFunctionDeclaration(t, i) {
            return this.isChildFunction(t) ? i : this.astFunction(t, i);
          }
          astFunctionExpression(t, i) {
            return this.isChildFunction(t) ? i : this.astFunction(t, i);
          }
          isChildFunction(t) {
            for (let i = 0; i < this.functions.length; i++)
              if (this.functions[i] === t)
                return true;
            return false;
          }
          astReturnStatement(t, i) {
            return i;
          }
          astLiteral(t, i) {
            return this.literalTypes[this.astKey(t)] = "Number", i;
          }
          astBinaryExpression(t, i) {
            return i;
          }
          astIdentifierExpression(t, i) {
            return i;
          }
          astAssignmentExpression(t, i) {
            return i;
          }
          astExpressionStatement(t, i) {
            return this.astGeneric(t.expression, i), i.push(";"), i;
          }
          astEmptyStatement(t, i) {
            return i;
          }
          astBlockStatement(t, i) {
            return i;
          }
          astIfStatement(t, i) {
            return i;
          }
          astSwitchStatement(t, i) {
            return i;
          }
          astBreakStatement(t, i) {
            return i.push("break;"), i;
          }
          astContinueStatement(t, i) {
            return i.push(\`continue;
\`), i;
          }
          astForStatement(t, i) {
            return i;
          }
          astWhileStatement(t, i) {
            return i;
          }
          astDoWhileStatement(t, i) {
            return i;
          }
          astVariableDeclarator(t, i) {
            return this.astGeneric(t.id, i), t.init !== null && (i.push("="), this.astGeneric(t.init, i)), i;
          }
          astThisExpression(t, i) {
            return i;
          }
          astSequenceExpression(t, i) {
            let { expressions: u } = t, x2 = [];
            for (let w = 0; w < u.length; w++) {
              let m = u[w], S = [];
              this.astGeneric(m, S), x2.push(S.join(""));
            }
            return x2.length > 1 ? i.push("(", x2.join(","), ")") : i.push(x2[0]), i;
          }
          astUnaryExpression(t, i) {
            return this.checkAndUpconvertBitwiseUnary(t, i) || (t.prefix ? (i.push(t.operator), this.astGeneric(t.argument, i)) : (this.astGeneric(t.argument, i), i.push(t.operator))), i;
          }
          checkAndUpconvertBitwiseUnary(t, i) {
          }
          astUpdateExpression(t, i) {
            return t.prefix ? (i.push(t.operator), this.astGeneric(t.argument, i)) : (this.astGeneric(t.argument, i), i.push(t.operator)), i;
          }
          astLogicalExpression(t, i) {
            return i.push("("), this.astGeneric(t.left, i), i.push(t.operator), this.astGeneric(t.right, i), i.push(")"), i;
          }
          astMemberExpression(t, i) {
            return i;
          }
          astCallExpression(t, i) {
            return i;
          }
          astArrayExpression(t, i) {
            return i;
          }
          getMemberExpressionDetails(t) {
            if (t.type !== "MemberExpression")
              throw this.astErrorOutput(\`Expression \${t.type} not a MemberExpression\`, t);
            let i = null, u = null, x2 = this.getVariableSignature(t);
            switch (x2) {
              case "value":
                return null;
              case "value.thread.value":
              case "this.thread.value":
              case "this.output.value":
                return { signature: x2, type: "Integer", name: t.property.name };
              case "value[]":
                if (typeof t.object.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                return i = t.object.name, { name: i, origin: "user", signature: x2, type: this.getVariableType(t.object), xProperty: t.property };
              case "value[][]":
                if (typeof t.object.object.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                return i = t.object.object.name, { name: i, origin: "user", signature: x2, type: this.getVariableType(t.object.object), yProperty: t.object.property, xProperty: t.property };
              case "value[][][]":
                if (typeof t.object.object.object.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                return i = t.object.object.object.name, { name: i, origin: "user", signature: x2, type: this.getVariableType(t.object.object.object), zProperty: t.object.object.property, yProperty: t.object.property, xProperty: t.property };
              case "value[][][][]":
                if (typeof t.object.object.object.object.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                return i = t.object.object.object.object.name, { name: i, origin: "user", signature: x2, type: this.getVariableType(t.object.object.object.object), zProperty: t.object.object.property, yProperty: t.object.property, xProperty: t.property };
              case "value.value":
                if (typeof t.property.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                if (this.isAstMathVariable(t))
                  return i = t.property.name, { name: i, origin: "Math", type: "Number", signature: x2 };
                switch (t.property.name) {
                  case "r":
                  case "g":
                  case "b":
                  case "a":
                    return i = t.object.name, { name: i, property: t.property.name, origin: "user", signature: x2, type: "Number" };
                  default:
                    throw this.astErrorOutput("Unexpected expression", t);
                }
              case "this.constants.value":
                if (typeof t.property.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                if (i = t.property.name, u = this.getConstantType(i), !u)
                  throw this.astErrorOutput("Constant has no type", t);
                return { name: i, type: u, origin: "constants", signature: x2 };
              case "this.constants.value[]":
                if (typeof t.object.property.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                if (i = t.object.property.name, u = this.getConstantType(i), !u)
                  throw this.astErrorOutput("Constant has no type", t);
                return { name: i, type: u, origin: "constants", signature: x2, xProperty: t.property };
              case "this.constants.value[][]": {
                if (typeof t.object.object.property.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                if (i = t.object.object.property.name, u = this.getConstantType(i), !u)
                  throw this.astErrorOutput("Constant has no type", t);
                return { name: i, type: u, origin: "constants", signature: x2, yProperty: t.object.property, xProperty: t.property };
              }
              case "this.constants.value[][][]": {
                if (typeof t.object.object.object.property.name != "string")
                  throw this.astErrorOutput("Unexpected expression", t);
                if (i = t.object.object.object.property.name, u = this.getConstantType(i), !u)
                  throw this.astErrorOutput("Constant has no type", t);
                return { name: i, type: u, origin: "constants", signature: x2, zProperty: t.object.object.property, yProperty: t.object.property, xProperty: t.property };
              }
              case "fn()[]":
              case "fn()[][]":
              case "[][]":
                return { signature: x2, property: t.property };
              default:
                throw this.astErrorOutput("Unexpected expression", t);
            }
          }
          findIdentifierOrigin(t) {
            let i = [this.ast];
            for (; i.length > 0; ) {
              let u = i[0];
              if (u.type === "VariableDeclarator" && u.id && u.id.name && u.id.name === t.name)
                return u;
              if (i.shift(), u.argument)
                i.push(u.argument);
              else if (u.body)
                i.push(u.body);
              else if (u.declarations)
                i.push(u.declarations);
              else if (Array.isArray(u))
                for (let x2 = 0; x2 < u.length; x2++)
                  i.push(u[x2]);
            }
            return null;
          }
          findLastReturn(t) {
            let i = [t || this.ast];
            for (; i.length > 0; ) {
              let u = i.pop();
              if (u.type === "ReturnStatement")
                return u;
              if (u.type !== "FunctionDeclaration")
                if (u.argument)
                  i.push(u.argument);
                else if (u.body)
                  i.push(u.body);
                else if (u.declarations)
                  i.push(u.declarations);
                else if (Array.isArray(u))
                  for (let x2 = 0; x2 < u.length; x2++)
                    i.push(u[x2]);
                else
                  u.consequent ? i.push(u.consequent) : u.cases && i.push(u.cases);
            }
            return null;
          }
          getInternalVariableName(t) {
            return this._internalVariableNames.hasOwnProperty(t) || (this._internalVariableNames[t] = 0), this._internalVariableNames[t]++, this._internalVariableNames[t] === 1 ? t : t + this._internalVariableNames[t];
          }
          astKey(t, i = ",") {
            if (!t.start || !t.end)
              throw new Error("AST start and end needed");
            return \`\${t.start}\${i}\${t.end}\`;
          }
        }
        let n = { Number: "Number", Float: "Float", Integer: "Integer", Array: "Number", "Array(2)": "Number", "Array(3)": "Number", "Array(4)": "Number", "Matrix(2)": "Number", "Matrix(3)": "Number", "Matrix(4)": "Number", Array2D: "Number", Array3D: "Number", Input: "Number", HTMLCanvas: "Array(4)", HTMLImage: "Array(4)", HTMLVideo: "Array(4)", HTMLImageArray: "Array(4)", NumberTexture: "Number", MemoryOptimizedNumberTexture: "Number", "Array1D(2)": "Array(2)", "Array1D(3)": "Array(3)", "Array1D(4)": "Array(4)", "Array2D(2)": "Array(2)", "Array2D(3)": "Array(3)", "Array2D(4)": "Array(4)", "Array3D(2)": "Array(2)", "Array3D(3)": "Array(3)", "Array3D(4)": "Array(4)", "ArrayTexture(1)": "Number", "ArrayTexture(2)": "Array(2)", "ArrayTexture(3)": "Array(3)", "ArrayTexture(4)": "Array(4)" };
        y.exports = { FunctionNode: l };
      }, { "../utils": 114, "./function-tracer": 11, acorn: 1 }], 11: [function(o, y, E) {
        let { utils: p } = o("../utils");
        function g(n) {
          return n.length > 0 ? n[n.length - 1] : null;
        }
        let f = { trackIdentifiers: "trackIdentifiers", memberExpression: "memberExpression", inForLoopInit: "inForLoopInit" };
        class l {
          constructor(s) {
            this.runningContexts = [], this.functionContexts = [], this.contexts = [], this.functionCalls = [], this.declarations = [], this.identifiers = [], this.functions = [], this.returnStatements = [], this.trackedIdentifiers = null, this.states = [], this.newFunctionContext(), this.scan(s);
          }
          isState(s) {
            return this.states[this.states.length - 1] === s;
          }
          hasState(s) {
            return this.states.indexOf(s) > -1;
          }
          pushState(s) {
            this.states.push(s);
          }
          popState(s) {
            if (this.isState(s))
              this.states.pop();
            else
              throw new Error(\`Cannot pop the non-active state "\${s}"\`);
          }
          get currentFunctionContext() {
            return g(this.functionContexts);
          }
          get currentContext() {
            return g(this.runningContexts);
          }
          newFunctionContext() {
            let s = { "@contextType": "function" };
            this.contexts.push(s), this.functionContexts.push(s);
          }
          newContext(s) {
            let t = Object.assign({ "@contextType": "const/let" }, this.currentContext);
            this.contexts.push(t), this.runningContexts.push(t), s();
            let { currentFunctionContext: i } = this;
            for (let u in i)
              !i.hasOwnProperty(u) || t.hasOwnProperty(u) || (t[u] = i[u]);
            return this.runningContexts.pop(), t;
          }
          useFunctionContext(s) {
            let t = g(this.functionContexts);
            this.runningContexts.push(t), s(), this.runningContexts.pop();
          }
          getIdentifiers(s) {
            let t = this.trackedIdentifiers = [];
            return this.pushState(f.trackIdentifiers), s(), this.trackedIdentifiers = null, this.popState(f.trackIdentifiers), t;
          }
          getDeclaration(s) {
            let { currentContext: t, currentFunctionContext: i, runningContexts: u } = this, x2 = t[s] || i[s] || null;
            if (!x2 && t === i && u.length > 0) {
              let w = u[u.length - 2];
              if (w[s])
                return w[s];
            }
            return x2;
          }
          scan(s) {
            if (!!s) {
              if (Array.isArray(s)) {
                for (let t = 0; t < s.length; t++)
                  this.scan(s[t]);
                return;
              }
              switch (s.type) {
                case "Program":
                  this.useFunctionContext(() => {
                    this.scan(s.body);
                  });
                  break;
                case "BlockStatement":
                  this.newContext(() => {
                    this.scan(s.body);
                  });
                  break;
                case "AssignmentExpression":
                case "LogicalExpression":
                  this.scan(s.left), this.scan(s.right);
                  break;
                case "BinaryExpression":
                  this.scan(s.left), this.scan(s.right);
                  break;
                case "UpdateExpression":
                  if (s.operator === "++") {
                    let t = this.getDeclaration(s.argument.name);
                    t && (t.suggestedType = "Integer");
                  }
                  this.scan(s.argument);
                  break;
                case "UnaryExpression":
                  this.scan(s.argument);
                  break;
                case "VariableDeclaration":
                  s.kind === "var" ? this.useFunctionContext(() => {
                    s.declarations = p.normalizeDeclarations(s), this.scan(s.declarations);
                  }) : (s.declarations = p.normalizeDeclarations(s), this.scan(s.declarations));
                  break;
                case "VariableDeclarator": {
                  let { currentContext: t } = this, i = this.hasState(f.inForLoopInit), u = { ast: s, context: t, name: s.id.name, origin: "declaration", inForLoopInit: i, inForLoopTest: null, assignable: t === this.currentFunctionContext || !i && !t.hasOwnProperty(s.id.name), suggestedType: null, valueType: null, dependencies: null, isSafe: null };
                  t[s.id.name] || (t[s.id.name] = u), this.declarations.push(u), this.scan(s.id), this.scan(s.init);
                  break;
                }
                case "FunctionExpression":
                case "FunctionDeclaration":
                  this.runningContexts.length === 0 ? this.scan(s.body) : this.functions.push(s);
                  break;
                case "IfStatement":
                  this.scan(s.test), this.scan(s.consequent), s.alternate && this.scan(s.alternate);
                  break;
                case "ForStatement": {
                  let t, i = this.newContext(() => {
                    this.pushState(f.inForLoopInit), this.scan(s.init), this.popState(f.inForLoopInit), t = this.getIdentifiers(() => {
                      this.scan(s.test);
                    }), this.scan(s.update), this.newContext(() => {
                      this.scan(s.body);
                    });
                  });
                  if (t)
                    for (let u in i)
                      u !== "@contextType" && t.indexOf(u) > -1 && (i[u].inForLoopTest = true);
                  break;
                }
                case "DoWhileStatement":
                case "WhileStatement":
                  this.newContext(() => {
                    this.scan(s.body), this.scan(s.test);
                  });
                  break;
                case "Identifier": {
                  this.isState(f.trackIdentifiers) && this.trackedIdentifiers.push(s.name), this.identifiers.push({ context: this.currentContext, declaration: this.getDeclaration(s.name), ast: s });
                  break;
                }
                case "ReturnStatement":
                  this.returnStatements.push(s), this.scan(s.argument);
                  break;
                case "MemberExpression":
                  this.pushState(f.memberExpression), this.scan(s.object), this.scan(s.property), this.popState(f.memberExpression);
                  break;
                case "ExpressionStatement":
                  this.scan(s.expression);
                  break;
                case "SequenceExpression":
                  this.scan(s.expressions);
                  break;
                case "CallExpression":
                  this.functionCalls.push({ context: this.currentContext, ast: s }), this.scan(s.arguments);
                  break;
                case "ArrayExpression":
                  this.scan(s.elements);
                  break;
                case "ConditionalExpression":
                  this.scan(s.test), this.scan(s.alternate), this.scan(s.consequent);
                  break;
                case "SwitchStatement":
                  this.scan(s.discriminant), this.scan(s.cases);
                  break;
                case "SwitchCase":
                  this.scan(s.test), this.scan(s.consequent);
                  break;
                case "ThisExpression":
                case "Literal":
                case "DebuggerStatement":
                case "EmptyStatement":
                case "BreakStatement":
                case "ContinueStatement":
                  break;
                default:
                  throw new Error(\`unhandled type "\${s.type}"\`);
              }
            }
          }
        }
        y.exports = { FunctionTracer: l };
      }, { "../utils": 114 }], 12: [function(o, y, E) {
        let { glWiretap: p } = o("gl-wiretap"), { utils: g } = o("../../utils");
        function f(u) {
          return u.toString().replace("=>", "").replace(/^function /, "").replace(/utils[.]/g, "/*utils.*/");
        }
        function l(u, x2, w, m, S) {
          w.built || w.build.apply(w, x2), x2 = x2 ? Array.from(x2).map((Q) => {
            switch (typeof Q) {
              case "boolean":
                return new Boolean(Q);
              case "number":
                return new Number(Q);
              default:
                return Q;
            }
          }) : null;
          let v = [], h = [], b = p(w.context, { useTrackablePrimitives: true, onReadPixels: (Q) => {
            if (Z.subKernels) {
              if (!T)
                h.push(\`    const result = { result: \${n(Q, Z)} };\`), T = true;
              else {
                let ue = Z.subKernels[C++].property;
                h.push(\`    result\${isNaN(ue) ? "." + ue : \`[\${ue}]\`} = \${n(Q, Z)};\`);
              }
              C === Z.subKernels.length && h.push("    return result;");
              return;
            }
            Q ? h.push(\`    return \${n(Q, Z)};\`) : h.push("    return null;");
          }, onUnrecognizedArgumentLookup: (Q) => {
            let ue = i(Q, Z.kernelArguments, [], b, v);
            if (ue)
              return ue;
            let he = i(Q, Z.kernelConstants, F ? Object.keys(F).map((pe) => F[pe]) : [], b, v);
            return he || null;
          } }), T = false, C = 0, { source: V, canvas: c, output: a, pipeline: k, graphical: A, loopMaxIterations: N, constants: F, optimizeFloatMemory: L, precision: K, fixIntegerDivisionAccuracy: O, functions: X, nativeFunctions: B, subKernels: P, immutable: Y, argumentTypes: J, constantTypes: q, kernelArguments: j, kernelConstants: U, tactic: oe } = w, Z = new u(V, { canvas: c, context: b, checkContext: false, output: a, pipeline: k, graphical: A, loopMaxIterations: N, constants: F, optimizeFloatMemory: L, precision: K, fixIntegerDivisionAccuracy: O, functions: X, nativeFunctions: B, subKernels: P, immutable: Y, argumentTypes: J, constantTypes: q, tactic: oe }), ee = [];
          if (b.setIndent(2), Z.build.apply(Z, x2), ee.push(b.toString()), b.reset(), Z.kernelArguments.forEach((Q, ue) => {
            switch (Q.type) {
              case "Integer":
              case "Boolean":
              case "Number":
              case "Float":
              case "Array":
              case "Array(2)":
              case "Array(3)":
              case "Array(4)":
              case "HTMLCanvas":
              case "HTMLImage":
              case "HTMLVideo":
                b.insertVariable(\`uploadValue_\${Q.name}\`, Q.uploadValue);
                break;
              case "HTMLImageArray":
                for (let he = 0; he < x2[ue].length; he++) {
                  let pe = x2[ue];
                  b.insertVariable(\`uploadValue_\${Q.name}[\${he}]\`, pe[he]);
                }
                break;
              case "Input":
                b.insertVariable(\`uploadValue_\${Q.name}\`, Q.uploadValue);
                break;
              case "MemoryOptimizedNumberTexture":
              case "NumberTexture":
              case "Array1D(2)":
              case "Array1D(3)":
              case "Array1D(4)":
              case "Array2D(2)":
              case "Array2D(3)":
              case "Array2D(4)":
              case "Array3D(2)":
              case "Array3D(3)":
              case "Array3D(4)":
              case "ArrayTexture(1)":
              case "ArrayTexture(2)":
              case "ArrayTexture(3)":
              case "ArrayTexture(4)":
                b.insertVariable(\`uploadValue_\${Q.name}\`, x2[ue].texture);
                break;
              default:
                throw new Error(\`unhandled kernelArgumentType insertion for glWiretap of type \${Q.type}\`);
            }
          }), ee.push("/** start of injected functions **/"), ee.push(\`function \${f(g.flattenTo)}\`), ee.push(\`function \${f(g.flatten2dArrayTo)}\`), ee.push(\`function \${f(g.flatten3dArrayTo)}\`), ee.push(\`function \${f(g.flatten4dArrayTo)}\`), ee.push(\`function \${f(g.isArray)}\`), Z.renderOutput !== Z.renderTexture && Z.formatValues && ee.push(\`  const renderOutput = function \${f(Z.formatValues)};\`), ee.push("/** end of injected functions **/"), ee.push(\`  const innerKernel = function (\${Z.kernelArguments.map((Q) => Q.varName).join(", ")}) {\`), b.setIndent(4), Z.run.apply(Z, x2), Z.renderKernels ? Z.renderKernels() : Z.renderOutput && Z.renderOutput(), ee.push("    /** start setup uploads for kernel values **/"), Z.kernelArguments.forEach((Q) => {
            ee.push("    " + Q.getStringValueHandler().split(\`
\`).join(\`
    \`));
          }), ee.push("    /** end setup uploads for kernel values **/"), ee.push(b.toString()), Z.renderOutput === Z.renderTexture) {
            b.reset();
            let Q = b.getContextVariableName(Z.framebuffer);
            if (Z.renderKernels) {
              let ue = Z.renderKernels(), he = b.getContextVariableName(Z.texture.texture);
              ee.push(\`    return {
            result: {
              texture: \${he},
              type: '\${ue.result.type}',
              toArray: \${t(ue.result, he, Q)}
            },\`);
              let { subKernels: pe, mappedTextures: te } = Z;
              for (let re = 0; re < pe.length; re++) {
                let de = te[re], Te = pe[re], Se = ue[Te.property], Ce = b.getContextVariableName(de.texture);
                ee.push(\`
            \${Te.property}: {
              texture: \${Ce},
              type: '\${Se.type}',
              toArray: \${t(Se, Ce, Q)}
            },\`);
              }
              ee.push("    };");
            } else {
              let ue = Z.renderOutput(), he = b.getContextVariableName(Z.texture.texture);
              ee.push(\`    return {
              texture: \${he},
              type: '\${ue.type}',
              toArray: \${t(ue, he, Q)}
            };\`);
            }
          }
          ee.push(\`    \${S ? \`
\` + S + "    " : ""}\`), ee.push(h.join(\`
\`)), ee.push("  };"), Z.graphical && (ee.push(s(Z)), ee.push("  innerKernel.getPixels = getPixels;")), ee.push("  return innerKernel;");
          let be = [];
          return U.forEach((Q) => {
            be.push(\`\${Q.getStringValueHandler()}\`);
          }), \`function kernel(settings) {
        const { context, constants } = settings;
        \${be.join("")}
        \${m || ""}
      \${ee.join(\`
\`)}
      }\`;
        }
        function n(u, x2) {
          let w = x2.precision === "single" ? u : \`new Float32Array(\${u}.buffer)\`;
          return x2.output[2] ? \`renderOutput(\${w}, \${x2.output[0]}, \${x2.output[1]}, \${x2.output[2]})\` : x2.output[1] ? \`renderOutput(\${w}, \${x2.output[0]}, \${x2.output[1]})\` : \`renderOutput(\${w}, \${x2.output[0]})\`;
        }
        function s(u) {
          let x2 = u.getPixels.toString(), w = !/^function/.test(x2);
          return g.flattenFunctionToString(\`\${w ? "function " : ""}\${x2}\`, { findDependency: (m, S) => m === "utils" ? \`const \${S} = \${g[S].toString()};\` : null, thisLookup: (m) => {
            if (m === "context")
              return null;
            if (u.hasOwnProperty(m))
              return JSON.stringify(u[m]);
            throw new Error(\`unhandled thisLookup \${m}\`);
          } });
        }
        function t(u, x2, w) {
          let m = u.toArray.toString(), S = !/^function/.test(m), v = g.flattenFunctionToString(\`\${S ? "function " : ""}\${m}\`, { findDependency: (h, b) => {
            if (h === "utils")
              return \`const \${b} = \${g[b].toString()};\`;
            if (h === "this")
              return b === "framebuffer" ? "" : \`\${S ? "function " : ""}\${u[b].toString()}\`;
            throw new Error("unhandled fromObject");
          }, thisLookup: (h, b) => {
            if (h === "texture")
              return x2;
            if (h === "context")
              return b ? null : "gl";
            if (u.hasOwnProperty(h))
              return JSON.stringify(u[h]);
            throw new Error(\`unhandled thisLookup \${h}\`);
          } });
          return \`() => {
        function framebuffer() { return \${w}; };
        \${v}
        return toArray();
        }\`;
        }
        function i(u, x2, w, m, S) {
          if (u === null || x2 === null)
            return null;
          switch (typeof u) {
            case "boolean":
            case "number":
              return null;
          }
          if (typeof HTMLImageElement < "u" && u instanceof HTMLImageElement)
            for (let v = 0; v < x2.length; v++) {
              let h = x2[v];
              if (h.type !== "HTMLImageArray" && h || h.uploadValue !== u)
                continue;
              let b = w[v].indexOf(u);
              if (b === -1)
                continue;
              let T = \`uploadValue_\${h.name}[\${b}]\`;
              return m.insertVariable(T, u), T;
            }
          for (let v = 0; v < x2.length; v++) {
            let h = x2[v];
            if (u !== h.uploadValue)
              continue;
            let b = \`uploadValue_\${h.name}\`;
            return m.insertVariable(b, h), b;
          }
          return null;
        }
        y.exports = { glKernelString: l };
      }, { "../../utils": 114, "gl-wiretap": 3 }], 13: [function(o, y, E) {
        let { Kernel: p } = o("../kernel"), { utils: g } = o("../../utils"), { GLTextureArray2Float: f } = o("./texture/array-2-float"), { GLTextureArray2Float2D: l } = o("./texture/array-2-float-2d"), { GLTextureArray2Float3D: n } = o("./texture/array-2-float-3d"), { GLTextureArray3Float: s } = o("./texture/array-3-float"), { GLTextureArray3Float2D: t } = o("./texture/array-3-float-2d"), { GLTextureArray3Float3D: i } = o("./texture/array-3-float-3d"), { GLTextureArray4Float: u } = o("./texture/array-4-float"), { GLTextureArray4Float2D: x2 } = o("./texture/array-4-float-2d"), { GLTextureArray4Float3D: w } = o("./texture/array-4-float-3d"), { GLTextureFloat: m } = o("./texture/float"), { GLTextureFloat2D: S } = o("./texture/float-2d"), { GLTextureFloat3D: v } = o("./texture/float-3d"), { GLTextureMemoryOptimized: h } = o("./texture/memory-optimized"), { GLTextureMemoryOptimized2D: b } = o("./texture/memory-optimized-2d"), { GLTextureMemoryOptimized3D: T } = o("./texture/memory-optimized-3d"), { GLTextureUnsigned: C } = o("./texture/unsigned"), { GLTextureUnsigned2D: V } = o("./texture/unsigned-2d"), { GLTextureUnsigned3D: c } = o("./texture/unsigned-3d"), { GLTextureGraphical: a } = o("./texture/graphical");
        class k extends p {
          static get mode() {
            return "gpu";
          }
          static getIsFloatRead() {
            let F = \`function kernelFunction() {
            return 1;
          }\`, L = new this(F, { context: this.testContext, canvas: this.testCanvas, validate: false, output: [1], precision: "single", returnType: "Number", tactic: "speed" });
            L.build(), L.run();
            let K = L.renderOutput();
            return L.destroy(true), K[0] === 1;
          }
          static getIsIntegerDivisionAccurate() {
            function F(X, B) {
              return X[this.thread.x] / B[this.thread.x];
            }
            let L = new this(F.toString(), { context: this.testContext, canvas: this.testCanvas, validate: false, output: [2], returnType: "Number", precision: "unsigned", tactic: "speed" }), K = [[6, 6030401], [3, 3991]];
            L.build.apply(L, K), L.run.apply(L, K);
            let O = L.renderOutput();
            return L.destroy(true), O[0] === 2 && O[1] === 1511;
          }
          static getIsSpeedTacticSupported() {
            function F(X) {
              return X[this.thread.x];
            }
            let L = new this(F.toString(), { context: this.testContext, canvas: this.testCanvas, validate: false, output: [4], returnType: "Number", precision: "unsigned", tactic: "speed" }), K = [[0, 1, 2, 3]];
            L.build.apply(L, K), L.run.apply(L, K);
            let O = L.renderOutput();
            return L.destroy(true), Math.round(O[0]) === 0 && Math.round(O[1]) === 1 && Math.round(O[2]) === 2 && Math.round(O[3]) === 3;
          }
          static get testCanvas() {
            throw new Error(\`"testCanvas" not defined on \${this.name}\`);
          }
          static get testContext() {
            throw new Error(\`"testContext" not defined on \${this.name}\`);
          }
          static getFeatures() {
            let F = this.testContext, L = this.getIsDrawBuffers();
            return Object.freeze({ isFloatRead: this.getIsFloatRead(), isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(), isSpeedTacticSupported: this.getIsSpeedTacticSupported(), isTextureFloat: this.getIsTextureFloat(), isDrawBuffers: L, kernelMap: L, channelCount: this.getChannelCount(), maxTextureSize: this.getMaxTextureSize(), lowIntPrecision: F.getShaderPrecisionFormat(F.FRAGMENT_SHADER, F.LOW_INT), lowFloatPrecision: F.getShaderPrecisionFormat(F.FRAGMENT_SHADER, F.LOW_FLOAT), mediumIntPrecision: F.getShaderPrecisionFormat(F.FRAGMENT_SHADER, F.MEDIUM_INT), mediumFloatPrecision: F.getShaderPrecisionFormat(F.FRAGMENT_SHADER, F.MEDIUM_FLOAT), highIntPrecision: F.getShaderPrecisionFormat(F.FRAGMENT_SHADER, F.HIGH_INT), highFloatPrecision: F.getShaderPrecisionFormat(F.FRAGMENT_SHADER, F.HIGH_FLOAT) });
          }
          static setupFeatureChecks() {
            throw new Error(\`"setupFeatureChecks" not defined on \${this.name}\`);
          }
          static getSignature(F, L) {
            return F.getVariablePrecisionString() + (L.length > 0 ? ":" + L.join(",") : "");
          }
          setFixIntegerDivisionAccuracy(F) {
            return this.fixIntegerDivisionAccuracy = F, this;
          }
          setPrecision(F) {
            return this.precision = F, this;
          }
          setFloatTextures(F) {
            return g.warnDeprecated("method", "setFloatTextures", "setOptimizeFloatMemory"), this.floatTextures = F, this;
          }
          static nativeFunctionArguments(F) {
            let L = [], K = [], O = [], X = /^[a-zA-Z_]/, B = /[a-zA-Z_0-9]/, P = 0, Y = null, J = null;
            for (; P < F.length; ) {
              let q = F[P], j = F[P + 1], U = O.length > 0 ? O[O.length - 1] : null;
              if (U === "FUNCTION_ARGUMENTS" && q === "/" && j === "*") {
                O.push("MULTI_LINE_COMMENT"), P += 2;
                continue;
              } else if (U === "MULTI_LINE_COMMENT" && q === "*" && j === "/") {
                O.pop(), P += 2;
                continue;
              } else if (U === "FUNCTION_ARGUMENTS" && q === "/" && j === "/") {
                O.push("COMMENT"), P += 2;
                continue;
              } else if (U === "COMMENT" && q === \`
\`) {
                O.pop(), P++;
                continue;
              } else if (U === null && q === "(") {
                O.push("FUNCTION_ARGUMENTS"), P++;
                continue;
              } else if (U === "FUNCTION_ARGUMENTS") {
                if (q === ")") {
                  O.pop();
                  break;
                }
                if (q === "f" && j === "l" && F[P + 2] === "o" && F[P + 3] === "a" && F[P + 4] === "t" && F[P + 5] === " ") {
                  O.push("DECLARE_VARIABLE"), J = "float", Y = "", P += 6;
                  continue;
                } else if (q === "i" && j === "n" && F[P + 2] === "t" && F[P + 3] === " ") {
                  O.push("DECLARE_VARIABLE"), J = "int", Y = "", P += 4;
                  continue;
                } else if (q === "v" && j === "e" && F[P + 2] === "c" && F[P + 3] === "2" && F[P + 4] === " ") {
                  O.push("DECLARE_VARIABLE"), J = "vec2", Y = "", P += 5;
                  continue;
                } else if (q === "v" && j === "e" && F[P + 2] === "c" && F[P + 3] === "3" && F[P + 4] === " ") {
                  O.push("DECLARE_VARIABLE"), J = "vec3", Y = "", P += 5;
                  continue;
                } else if (q === "v" && j === "e" && F[P + 2] === "c" && F[P + 3] === "4" && F[P + 4] === " ") {
                  O.push("DECLARE_VARIABLE"), J = "vec4", Y = "", P += 5;
                  continue;
                }
              } else if (U === "DECLARE_VARIABLE") {
                if (Y === "") {
                  if (q === " ") {
                    P++;
                    continue;
                  }
                  if (!X.test(q))
                    throw new Error("variable name is not expected string");
                }
                Y += q, B.test(j) || (O.pop(), K.push(Y), L.push(A[J]));
              }
              P++;
            }
            if (O.length > 0)
              throw new Error("GLSL function was not parsable");
            return { argumentNames: K, argumentTypes: L };
          }
          static nativeFunctionReturnType(F) {
            return A[F.match(/int|float|vec[2-4]/)[0]];
          }
          static combineKernels(F, L) {
            F.apply(null, arguments);
            let { texSize: K, context: O, threadDim: X } = L.texSize, B;
            if (L.precision === "single") {
              let P = K[0], Y = Math.ceil(K[1] / 4);
              B = new Float32Array(P * Y * 4 * 4), O.readPixels(0, 0, P, Y * 4, O.RGBA, O.FLOAT, B);
            } else {
              let P = new Uint8Array(K[0] * K[1] * 4);
              O.readPixels(0, 0, K[0], K[1], O.RGBA, O.UNSIGNED_BYTE, P), B = new Float32Array(P.buffer);
            }
            if (B = B.subarray(0, X[0] * X[1] * X[2]), L.output.length === 1)
              return B;
            if (L.output.length === 2)
              return g.splitArray(B, L.output[0]);
            if (L.output.length === 3)
              return g.splitArray(B, L.output[0] * L.output[1]).map(function(Y) {
                return g.splitArray(Y, L.output[0]);
              });
          }
          constructor(F, L) {
            super(F, L), this.transferValues = null, this.formatValues = null, this.TextureConstructor = null, this.renderOutput = null, this.renderRawOutput = null, this.texSize = null, this.translatedSource = null, this.compiledFragmentShader = null, this.compiledVertexShader = null, this.switchingKernels = null, this._textureSwitched = null, this._mappedTextureSwitched = null;
          }
          checkTextureSize() {
            let { features: F } = this.constructor;
            if (this.texSize[0] > F.maxTextureSize || this.texSize[1] > F.maxTextureSize)
              throw new Error(\`Texture size [\${this.texSize[0]},\${this.texSize[1]}] generated by kernel is larger than supported size [\${F.maxTextureSize},\${F.maxTextureSize}]\`);
          }
          translateSource() {
            throw new Error(\`"translateSource" not defined on \${this.constructor.name}\`);
          }
          pickRenderStrategy(F) {
            if (this.graphical)
              return this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues = (L) => L, this.TextureConstructor = a, null;
            if (this.precision === "unsigned")
              if (this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues = this.readPackedPixelsToFloat32Array, this.pipeline)
                switch (this.renderOutput = this.renderTexture, this.subKernels !== null && (this.renderKernels = this.renderKernelsToTextures), this.returnType) {
                  case "LiteralInteger":
                  case "Float":
                  case "Number":
                  case "Integer":
                    return this.output[2] > 0 ? (this.TextureConstructor = c, null) : this.output[1] > 0 ? (this.TextureConstructor = V, null) : (this.TextureConstructor = C, null);
                  case "Array(2)":
                  case "Array(3)":
                  case "Array(4)":
                    return this.requestFallback(F);
                }
              else
                switch (this.subKernels !== null && (this.renderKernels = this.renderKernelsToArrays), this.returnType) {
                  case "LiteralInteger":
                  case "Float":
                  case "Number":
                  case "Integer":
                    return this.renderOutput = this.renderValues, this.output[2] > 0 ? (this.TextureConstructor = c, this.formatValues = g.erect3DPackedFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = V, this.formatValues = g.erect2DPackedFloat, null) : (this.TextureConstructor = C, this.formatValues = g.erectPackedFloat, null);
                  case "Array(2)":
                  case "Array(3)":
                  case "Array(4)":
                    return this.requestFallback(F);
                }
            else if (this.precision === "single") {
              if (this.renderRawOutput = this.readFloatPixelsToFloat32Array, this.transferValues = this.readFloatPixelsToFloat32Array, this.pipeline)
                switch (this.renderOutput = this.renderTexture, this.subKernels !== null && (this.renderKernels = this.renderKernelsToTextures), this.returnType) {
                  case "LiteralInteger":
                  case "Float":
                  case "Number":
                  case "Integer":
                    return this.optimizeFloatMemory ? this.output[2] > 0 ? (this.TextureConstructor = T, null) : this.output[1] > 0 ? (this.TextureConstructor = b, null) : (this.TextureConstructor = h, null) : this.output[2] > 0 ? (this.TextureConstructor = v, null) : this.output[1] > 0 ? (this.TextureConstructor = S, null) : (this.TextureConstructor = m, null);
                  case "Array(2)":
                    return this.output[2] > 0 ? (this.TextureConstructor = n, null) : this.output[1] > 0 ? (this.TextureConstructor = l, null) : (this.TextureConstructor = f, null);
                  case "Array(3)":
                    return this.output[2] > 0 ? (this.TextureConstructor = i, null) : this.output[1] > 0 ? (this.TextureConstructor = t, null) : (this.TextureConstructor = s, null);
                  case "Array(4)":
                    return this.output[2] > 0 ? (this.TextureConstructor = w, null) : this.output[1] > 0 ? (this.TextureConstructor = x2, null) : (this.TextureConstructor = u, null);
                }
              if (this.renderOutput = this.renderValues, this.subKernels !== null && (this.renderKernels = this.renderKernelsToArrays), this.optimizeFloatMemory)
                switch (this.returnType) {
                  case "LiteralInteger":
                  case "Float":
                  case "Number":
                  case "Integer":
                    return this.output[2] > 0 ? (this.TextureConstructor = T, this.formatValues = g.erectMemoryOptimized3DFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = b, this.formatValues = g.erectMemoryOptimized2DFloat, null) : (this.TextureConstructor = h, this.formatValues = g.erectMemoryOptimizedFloat, null);
                  case "Array(2)":
                    return this.output[2] > 0 ? (this.TextureConstructor = n, this.formatValues = g.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = l, this.formatValues = g.erect2DArray2, null) : (this.TextureConstructor = f, this.formatValues = g.erectArray2, null);
                  case "Array(3)":
                    return this.output[2] > 0 ? (this.TextureConstructor = i, this.formatValues = g.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = t, this.formatValues = g.erect2DArray3, null) : (this.TextureConstructor = s, this.formatValues = g.erectArray3, null);
                  case "Array(4)":
                    return this.output[2] > 0 ? (this.TextureConstructor = w, this.formatValues = g.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = x2, this.formatValues = g.erect2DArray4, null) : (this.TextureConstructor = u, this.formatValues = g.erectArray4, null);
                }
              else
                switch (this.returnType) {
                  case "LiteralInteger":
                  case "Float":
                  case "Number":
                  case "Integer":
                    return this.output[2] > 0 ? (this.TextureConstructor = v, this.formatValues = g.erect3DFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = S, this.formatValues = g.erect2DFloat, null) : (this.TextureConstructor = m, this.formatValues = g.erectFloat, null);
                  case "Array(2)":
                    return this.output[2] > 0 ? (this.TextureConstructor = n, this.formatValues = g.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = l, this.formatValues = g.erect2DArray2, null) : (this.TextureConstructor = f, this.formatValues = g.erectArray2, null);
                  case "Array(3)":
                    return this.output[2] > 0 ? (this.TextureConstructor = i, this.formatValues = g.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = t, this.formatValues = g.erect2DArray3, null) : (this.TextureConstructor = s, this.formatValues = g.erectArray3, null);
                  case "Array(4)":
                    return this.output[2] > 0 ? (this.TextureConstructor = w, this.formatValues = g.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = x2, this.formatValues = g.erect2DArray4, null) : (this.TextureConstructor = u, this.formatValues = g.erectArray4, null);
                }
            } else
              throw new Error(\`unhandled precision of "\${this.precision}"\`);
            throw new Error(\`unhandled return type "\${this.returnType}"\`);
          }
          getKernelString() {
            throw new Error("abstract method call");
          }
          getMainResultTexture() {
            switch (this.returnType) {
              case "LiteralInteger":
              case "Float":
              case "Integer":
              case "Number":
                return this.getMainResultNumberTexture();
              case "Array(2)":
                return this.getMainResultArray2Texture();
              case "Array(3)":
                return this.getMainResultArray3Texture();
              case "Array(4)":
                return this.getMainResultArray4Texture();
              default:
                throw new Error(\`unhandled returnType type \${this.returnType}\`);
            }
          }
          getMainResultKernelNumberTexture() {
            throw new Error("abstract method call");
          }
          getMainResultSubKernelNumberTexture() {
            throw new Error("abstract method call");
          }
          getMainResultKernelArray2Texture() {
            throw new Error("abstract method call");
          }
          getMainResultSubKernelArray2Texture() {
            throw new Error("abstract method call");
          }
          getMainResultKernelArray3Texture() {
            throw new Error("abstract method call");
          }
          getMainResultSubKernelArray3Texture() {
            throw new Error("abstract method call");
          }
          getMainResultKernelArray4Texture() {
            throw new Error("abstract method call");
          }
          getMainResultSubKernelArray4Texture() {
            throw new Error("abstract method call");
          }
          getMainResultGraphical() {
            throw new Error("abstract method call");
          }
          getMainResultMemoryOptimizedFloats() {
            throw new Error("abstract method call");
          }
          getMainResultPackedPixels() {
            throw new Error("abstract method call");
          }
          getMainResultString() {
            return this.graphical ? this.getMainResultGraphical() : this.precision === "single" ? this.optimizeFloatMemory ? this.getMainResultMemoryOptimizedFloats() : this.getMainResultTexture() : this.getMainResultPackedPixels();
          }
          getMainResultNumberTexture() {
            return g.linesToString(this.getMainResultKernelNumberTexture()) + g.linesToString(this.getMainResultSubKernelNumberTexture());
          }
          getMainResultArray2Texture() {
            return g.linesToString(this.getMainResultKernelArray2Texture()) + g.linesToString(this.getMainResultSubKernelArray2Texture());
          }
          getMainResultArray3Texture() {
            return g.linesToString(this.getMainResultKernelArray3Texture()) + g.linesToString(this.getMainResultSubKernelArray3Texture());
          }
          getMainResultArray4Texture() {
            return g.linesToString(this.getMainResultKernelArray4Texture()) + g.linesToString(this.getMainResultSubKernelArray4Texture());
          }
          getFloatTacticDeclaration() {
            return \`precision \${this.getVariablePrecisionString(this.texSize, this.tactic)} float;
\`;
          }
          getIntTacticDeclaration() {
            return \`precision \${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;
\`;
          }
          getSampler2DTacticDeclaration() {
            return \`precision \${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;
\`;
          }
          getSampler2DArrayTacticDeclaration() {
            return \`precision \${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;
\`;
          }
          renderTexture() {
            return this.immutable ? this.texture.clone() : this.texture;
          }
          readPackedPixelsToUint8Array() {
            if (this.precision !== "unsigned")
              throw new Error('Requires this.precision to be "unsigned"');
            let { texSize: F, context: L } = this, K = new Uint8Array(F[0] * F[1] * 4);
            return L.readPixels(0, 0, F[0], F[1], L.RGBA, L.UNSIGNED_BYTE, K), K;
          }
          readPackedPixelsToFloat32Array() {
            return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
          }
          readFloatPixelsToFloat32Array() {
            if (this.precision !== "single")
              throw new Error('Requires this.precision to be "single"');
            let { texSize: F, context: L } = this, K = F[0], O = F[1], X = new Float32Array(K * O * 4);
            return L.readPixels(0, 0, K, O, L.RGBA, L.FLOAT, X), X;
          }
          getPixels(F) {
            let { context: L, output: K } = this, [O, X] = K, B = new Uint8Array(O * X * 4);
            return L.readPixels(0, 0, O, X, L.RGBA, L.UNSIGNED_BYTE, B), new Uint8ClampedArray((F ? B : g.flipPixels(B, O, X)).buffer);
          }
          renderKernelsToArrays() {
            let F = { result: this.renderOutput() };
            for (let L = 0; L < this.subKernels.length; L++)
              F[this.subKernels[L].property] = this.mappedTextures[L].toArray();
            return F;
          }
          renderKernelsToTextures() {
            let F = { result: this.renderOutput() };
            if (this.immutable)
              for (let L = 0; L < this.subKernels.length; L++)
                F[this.subKernels[L].property] = this.mappedTextures[L].clone();
            else
              for (let L = 0; L < this.subKernels.length; L++)
                F[this.subKernels[L].property] = this.mappedTextures[L];
            return F;
          }
          resetSwitchingKernels() {
            let F = this.switchingKernels;
            return this.switchingKernels = null, F;
          }
          setOutput(F) {
            let L = this.toKernelOutput(F);
            if (this.program) {
              if (!this.dynamicOutput)
                throw new Error("Resizing a kernel with dynamicOutput: false is not possible");
              let K = [L[0], L[1] || 1, L[2] || 1], O = g.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, precision: this.precision }, K), X = this.texSize;
              if (X) {
                let P = this.getVariablePrecisionString(X, this.tactic), Y = this.getVariablePrecisionString(O, this.tactic);
                if (P !== Y) {
                  this.debug && console.warn("Precision requirement changed, asking GPU instance to recompile"), this.switchKernels({ type: "outputPrecisionMismatch", precision: Y, needed: F });
                  return;
                }
              }
              this.output = L, this.threadDim = K, this.texSize = O;
              let { context: B } = this;
              if (B.bindFramebuffer(B.FRAMEBUFFER, this.framebuffer), this.updateMaxTexSize(), this.framebuffer.width = this.texSize[0], this.framebuffer.height = this.texSize[1], B.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), this.canvas.width = this.maxTexSize[0], this.canvas.height = this.maxTexSize[1], this.texture && this.texture.delete(), this.texture = null, this._setupOutputTexture(), this.mappedTextures && this.mappedTextures.length > 0) {
                for (let P = 0; P < this.mappedTextures.length; P++)
                  this.mappedTextures[P].delete();
                this.mappedTextures = null, this._setupSubOutputTextures();
              }
            } else
              this.output = L;
            return this;
          }
          renderValues() {
            return this.formatValues(this.transferValues(), this.output[0], this.output[1], this.output[2]);
          }
          switchKernels(F) {
            this.switchingKernels ? this.switchingKernels.push(F) : this.switchingKernels = [F];
          }
          getVariablePrecisionString(F = this.texSize, L = this.tactic, K = false) {
            if (!L) {
              if (!this.constructor.features.isSpeedTacticSupported)
                return "highp";
              let O = this.constructor.features[K ? "lowIntPrecision" : "lowFloatPrecision"], X = this.constructor.features[K ? "mediumIntPrecision" : "mediumFloatPrecision"], B = this.constructor.features[K ? "highIntPrecision" : "highFloatPrecision"], P = Math.log2(F[0] * F[1]);
              if (P <= O.rangeMax)
                return "lowp";
              if (P <= X.rangeMax)
                return "mediump";
              if (P <= B.rangeMax)
                return "highp";
              throw new Error("The required size exceeds that of the ability of your system");
            }
            switch (L) {
              case "speed":
                return "lowp";
              case "balanced":
                return "mediump";
              case "precision":
                return "highp";
              default:
                throw new Error(\`Unknown tactic "\${L}" use "speed", "balanced", "precision", or empty for auto\`);
            }
          }
          updateTextureArgumentRefs(F, L) {
            if (!!this.immutable) {
              if (this.texture.texture === L.texture) {
                let { prevArg: K } = F;
                K && (K.texture._refs === 1 && (this.texture.delete(), this.texture = K.clone(), this._textureSwitched = true), K.delete()), F.prevArg = L.clone();
              } else if (this.mappedTextures && this.mappedTextures.length > 0) {
                let { mappedTextures: K } = this;
                for (let O = 0; O < K.length; O++) {
                  let X = K[O];
                  if (X.texture === L.texture) {
                    let { prevArg: B } = F;
                    B && (B.texture._refs === 1 && (X.delete(), K[O] = B.clone(), this._mappedTextureSwitched[O] = true), B.delete()), F.prevArg = L.clone();
                    return;
                  }
                }
              }
            }
          }
          onActivate(F) {
            if (this._textureSwitched = true, this.texture = F.texture, this.mappedTextures) {
              for (let L = 0; L < this.mappedTextures.length; L++)
                this._mappedTextureSwitched[L] = true;
              this.mappedTextures = F.mappedTextures;
            }
          }
          initCanvas() {
          }
        }
        let A = { int: "Integer", float: "Number", vec2: "Array(2)", vec3: "Array(3)", vec4: "Array(4)" };
        y.exports = { GLKernel: k };
      }, { "../../utils": 114, "../kernel": 36, "./texture/array-2-float": 16, "./texture/array-2-float-2d": 14, "./texture/array-2-float-3d": 15, "./texture/array-3-float": 19, "./texture/array-3-float-2d": 17, "./texture/array-3-float-3d": 18, "./texture/array-4-float": 22, "./texture/array-4-float-2d": 20, "./texture/array-4-float-3d": 21, "./texture/float": 25, "./texture/float-2d": 23, "./texture/float-3d": 24, "./texture/graphical": 26, "./texture/memory-optimized": 30, "./texture/memory-optimized-2d": 28, "./texture/memory-optimized-3d": 29, "./texture/unsigned": 33, "./texture/unsigned-2d": 31, "./texture/unsigned-3d": 32 }], 14: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(2)";
          }
          toArray() {
            return p.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureArray2Float2D: f };
      }, { "../../../utils": 114, "./float": 25 }], 15: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(2)";
          }
          toArray() {
            return p.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
          }
        }
        y.exports = { GLTextureArray2Float3D: f };
      }, { "../../../utils": 114, "./float": 25 }], 16: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(2)";
          }
          toArray() {
            return p.erectArray2(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureArray2Float: f };
      }, { "../../../utils": 114, "./float": 25 }], 17: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(3)";
          }
          toArray() {
            return p.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureArray3Float2D: f };
      }, { "../../../utils": 114, "./float": 25 }], 18: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(3)";
          }
          toArray() {
            return p.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
          }
        }
        y.exports = { GLTextureArray3Float3D: f };
      }, { "../../../utils": 114, "./float": 25 }], 19: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(3)";
          }
          toArray() {
            return p.erectArray3(this.renderValues(), this.output[0]);
          }
        }
        y.exports = { GLTextureArray3Float: f };
      }, { "../../../utils": 114, "./float": 25 }], 20: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(4)";
          }
          toArray() {
            return p.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureArray4Float2D: f };
      }, { "../../../utils": 114, "./float": 25 }], 21: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(4)";
          }
          toArray() {
            return p.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
          }
        }
        y.exports = { GLTextureArray4Float3D: f };
      }, { "../../../utils": 114, "./float": 25 }], 22: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(4)";
          }
          toArray() {
            return p.erectArray4(this.renderValues(), this.output[0]);
          }
        }
        y.exports = { GLTextureArray4Float: f };
      }, { "../../../utils": 114, "./float": 25 }], 23: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(1)";
          }
          toArray() {
            return p.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureFloat2D: f };
      }, { "../../../utils": 114, "./float": 25 }], 24: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "ArrayTexture(1)";
          }
          toArray() {
            return p.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
          }
        }
        y.exports = { GLTextureFloat3D: f };
      }, { "../../../utils": 114, "./float": 25 }], 25: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTexture: g } = o("./index");
        class f extends g {
          get textureType() {
            return this.context.FLOAT;
          }
          constructor(n) {
            super(n), this.type = "ArrayTexture(1)";
          }
          renderRawOutput() {
            let n = this.context, s = this.size;
            n.bindFramebuffer(n.FRAMEBUFFER, this.framebuffer()), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, this.texture, 0);
            let t = new Float32Array(s[0] * s[1] * 4);
            return n.readPixels(0, 0, s[0], s[1], n.RGBA, n.FLOAT, t), t;
          }
          renderValues() {
            return this._deleted ? null : this.renderRawOutput();
          }
          toArray() {
            return p.erectFloat(this.renderValues(), this.output[0]);
          }
        }
        y.exports = { GLTextureFloat: f };
      }, { "../../../utils": 114, "./index": 27 }], 26: [function(o, y, E) {
        let { GLTextureUnsigned: p } = o("./unsigned");
        class g extends p {
          constructor(l) {
            super(l), this.type = "ArrayTexture(4)";
          }
          toArray() {
            return this.renderValues();
          }
        }
        y.exports = { GLTextureGraphical: g };
      }, { "./unsigned": 33 }], 27: [function(o, y, E) {
        let { Texture: p } = o("../../../texture");
        class g extends p {
          get textureType() {
            throw new Error(\`"textureType" not implemented on \${this.name}\`);
          }
          clone() {
            return new this.constructor(this);
          }
          beforeMutate() {
            return this.texture._refs > 1 ? (this.newTexture(), true) : false;
          }
          cloneTexture() {
            this.texture._refs--;
            let { context: n, size: s, texture: t, kernel: i } = this;
            i.debug && console.warn("cloning internal texture"), n.bindFramebuffer(n.FRAMEBUFFER, this.framebuffer()), f(n, t), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0);
            let u = n.createTexture();
            f(n, u), n.texImage2D(n.TEXTURE_2D, 0, this.internalFormat, s[0], s[1], 0, this.textureFormat, this.textureType, null), n.copyTexSubImage2D(n.TEXTURE_2D, 0, 0, 0, 0, 0, s[0], s[1]), u._refs = 1, this.texture = u;
          }
          newTexture() {
            this.texture._refs--;
            let n = this.context, s = this.size;
            this.kernel.debug && console.warn("new internal texture");
            let i = n.createTexture();
            f(n, i), n.texImage2D(n.TEXTURE_2D, 0, this.internalFormat, s[0], s[1], 0, this.textureFormat, this.textureType, null), i._refs = 1, this.texture = i;
          }
          clear() {
            if (this.texture._refs) {
              this.texture._refs--;
              let t = this.context, i = this.texture = t.createTexture();
              f(t, i);
              let u = this.size;
              i._refs = 1, t.texImage2D(t.TEXTURE_2D, 0, this.internalFormat, u[0], u[1], 0, this.textureFormat, this.textureType, null);
            }
            let { context: n, texture: s } = this;
            n.bindFramebuffer(n.FRAMEBUFFER, this.framebuffer()), n.bindTexture(n.TEXTURE_2D, s), f(n, s), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, s, 0), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT);
          }
          delete() {
            this._deleted || (this._deleted = true, !(this.texture._refs && (this.texture._refs--, this.texture._refs)) && this.context.deleteTexture(this.texture));
          }
          framebuffer() {
            return this._framebuffer || (this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1])), this._framebuffer;
          }
        }
        function f(l, n) {
          l.activeTexture(l.TEXTURE15), l.bindTexture(l.TEXTURE_2D, n), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST);
        }
        y.exports = { GLTexture: g };
      }, { "../../../texture": 113 }], 28: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "MemoryOptimizedNumberTexture";
          }
          toArray() {
            return p.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureMemoryOptimized2D: f };
      }, { "../../../utils": 114, "./float": 25 }], 29: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "MemoryOptimizedNumberTexture";
          }
          toArray() {
            return p.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
          }
        }
        y.exports = { GLTextureMemoryOptimized3D: f };
      }, { "../../../utils": 114, "./float": 25 }], 30: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureFloat: g } = o("./float");
        class f extends g {
          constructor(n) {
            super(n), this.type = "MemoryOptimizedNumberTexture";
          }
          toArray() {
            return p.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
          }
        }
        y.exports = { GLTextureMemoryOptimized: f };
      }, { "../../../utils": 114, "./float": 25 }], 31: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureUnsigned: g } = o("./unsigned");
        class f extends g {
          constructor(n) {
            super(n), this.type = "NumberTexture";
          }
          toArray() {
            return p.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
          }
        }
        y.exports = { GLTextureUnsigned2D: f };
      }, { "../../../utils": 114, "./unsigned": 33 }], 32: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTextureUnsigned: g } = o("./unsigned");
        class f extends g {
          constructor(n) {
            super(n), this.type = "NumberTexture";
          }
          toArray() {
            return p.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
          }
        }
        y.exports = { GLTextureUnsigned3D: f };
      }, { "../../../utils": 114, "./unsigned": 33 }], 33: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { GLTexture: g } = o("./index");
        class f extends g {
          get textureType() {
            return this.context.UNSIGNED_BYTE;
          }
          constructor(n) {
            super(n), this.type = "NumberTexture";
          }
          renderRawOutput() {
            let { context: n } = this;
            n.bindFramebuffer(n.FRAMEBUFFER, this.framebuffer()), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, this.texture, 0);
            let s = new Uint8Array(this.size[0] * this.size[1] * 4);
            return n.readPixels(0, 0, this.size[0], this.size[1], n.RGBA, n.UNSIGNED_BYTE, s), s;
          }
          renderValues() {
            return this._deleted ? null : new Float32Array(this.renderRawOutput().buffer);
          }
          toArray() {
            return p.erectPackedFloat(this.renderValues(), this.output[0]);
          }
        }
        y.exports = { GLTextureUnsigned: f };
      }, { "../../../utils": 114, "./index": 27 }], 34: [function(o, y, E) {
        let p = o("gl"), { WebGLKernel: g } = o("../web-gl/kernel"), { glKernelString: f } = o("../gl/kernel-string"), l = null, n = null, s = null, t = null, i = null;
        class u extends g {
          static get isSupported() {
            return l !== null || (this.setupFeatureChecks(), l = s !== null), l;
          }
          static setupFeatureChecks() {
            if (n = null, t = null, typeof p == "function")
              try {
                if (s = p(2, 2, { preserveDrawingBuffer: true }), !s || !s.getExtension)
                  return;
                t = { STACKGL_resize_drawingbuffer: s.getExtension("STACKGL_resize_drawingbuffer"), STACKGL_destroy_context: s.getExtension("STACKGL_destroy_context"), OES_texture_float: s.getExtension("OES_texture_float"), OES_texture_float_linear: s.getExtension("OES_texture_float_linear"), OES_element_index_uint: s.getExtension("OES_element_index_uint"), WEBGL_draw_buffers: s.getExtension("WEBGL_draw_buffers"), WEBGL_color_buffer_float: s.getExtension("WEBGL_color_buffer_float") }, i = this.getFeatures();
              } catch (w) {
                console.warn(w);
              }
          }
          static isContextMatch(w) {
            try {
              return w.getParameter(w.RENDERER) === "ANGLE";
            } catch {
              return false;
            }
          }
          static getIsTextureFloat() {
            return Boolean(t.OES_texture_float);
          }
          static getIsDrawBuffers() {
            return Boolean(t.WEBGL_draw_buffers);
          }
          static getChannelCount() {
            return t.WEBGL_draw_buffers ? s.getParameter(t.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
          }
          static getMaxTextureSize() {
            return s.getParameter(s.MAX_TEXTURE_SIZE);
          }
          static get testCanvas() {
            return n;
          }
          static get testContext() {
            return s;
          }
          static get features() {
            return i;
          }
          initCanvas() {
            return {};
          }
          initContext() {
            return p(2, 2, { preserveDrawingBuffer: true });
          }
          initExtensions() {
            this.extensions = { STACKGL_resize_drawingbuffer: this.context.getExtension("STACKGL_resize_drawingbuffer"), STACKGL_destroy_context: this.context.getExtension("STACKGL_destroy_context"), OES_texture_float: this.context.getExtension("OES_texture_float"), OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear"), OES_element_index_uint: this.context.getExtension("OES_element_index_uint"), WEBGL_draw_buffers: this.context.getExtension("WEBGL_draw_buffers") };
          }
          build() {
            super.build.apply(this, arguments), this.fallbackRequested || this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
          }
          destroyExtensions() {
            this.extensions.STACKGL_resize_drawingbuffer = null, this.extensions.STACKGL_destroy_context = null, this.extensions.OES_texture_float = null, this.extensions.OES_texture_float_linear = null, this.extensions.OES_element_index_uint = null, this.extensions.WEBGL_draw_buffers = null;
          }
          static destroyContext(w) {
            let m = w.getExtension("STACKGL_destroy_context");
            m && m.destroy && m.destroy();
          }
          toString() {
            let w = \`const gl = context || require('gl')(1, 1);
\`, m = \`    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }
\`;
            return f(this.constructor, arguments, this, w, m);
          }
          setOutput(w) {
            return super.setOutput(w), this.graphical && this.extensions.STACKGL_resize_drawingbuffer && this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]), this;
          }
        }
        y.exports = { HeadlessGLKernel: u };
      }, { "../gl/kernel-string": 12, "../web-gl/kernel": 70, gl: 2 }], 35: [function(o, y, E) {
        class p {
          constructor(f, l) {
            let { name: n, kernel: s, context: t, checkContext: i, onRequestContextHandle: u, onUpdateValueMismatch: x2, origin: w, strictIntegers: m, type: S, tactic: v } = l;
            if (!n)
              throw new Error("name not set");
            if (!S)
              throw new Error("type not set");
            if (!w)
              throw new Error("origin not set");
            if (w !== "user" && w !== "constants")
              throw new Error(\`origin must be "user" or "constants" value is "\${w}"\`);
            if (!u)
              throw new Error("onRequestContextHandle is not set");
            this.name = n, this.origin = w, this.tactic = v, this.varName = w === "constants" ? \`constants.\${n}\` : n, this.kernel = s, this.strictIntegers = m, this.type = f.type || S, this.size = f.size || null, this.index = null, this.context = t, this.checkContext = i ?? true, this.contextHandle = null, this.onRequestContextHandle = u, this.onUpdateValueMismatch = x2, this.forceUploadEachRun = null;
          }
          get id() {
            return \`\${this.origin}_\${name}\`;
          }
          getSource() {
            throw new Error(\`"getSource" not defined on \${this.constructor.name}\`);
          }
          updateValue(f) {
            throw new Error(\`"updateValue" not defined on \${this.constructor.name}\`);
          }
        }
        y.exports = { KernelValue: p };
      }, {}], 36: [function(o, y, E) {
        let { utils: p } = o("../utils"), { Input: g } = o("../input");
        class f {
          static get isSupported() {
            throw new Error(\`"isSupported" not implemented on \${this.name}\`);
          }
          static isContextMatch(s) {
            throw new Error(\`"isContextMatch" not implemented on \${this.name}\`);
          }
          static getFeatures() {
            throw new Error(\`"getFeatures" not implemented on \${this.name}\`);
          }
          static destroyContext(s) {
            throw new Error(\`"destroyContext" called on \${this.name}\`);
          }
          static nativeFunctionArguments() {
            throw new Error(\`"nativeFunctionArguments" called on \${this.name}\`);
          }
          static nativeFunctionReturnType() {
            throw new Error(\`"nativeFunctionReturnType" called on \${this.name}\`);
          }
          static combineKernels() {
            throw new Error(\`"combineKernels" called on \${this.name}\`);
          }
          constructor(s, t) {
            if (typeof s != "object") {
              if (typeof s != "string")
                throw new Error("source not a string");
              if (!p.isFunctionString(s))
                throw new Error("source not a function string");
            }
            this.useLegacyEncoder = false, this.fallbackRequested = false, this.onRequestFallback = null, this.argumentNames = typeof s == "string" ? p.getArgumentNamesFromString(s) : null, this.argumentTypes = null, this.argumentSizes = null, this.argumentBitRatios = null, this.kernelArguments = null, this.kernelConstants = null, this.forceUploadKernelConstants = null, this.source = s, this.output = null, this.debug = false, this.graphical = false, this.loopMaxIterations = 0, this.constants = null, this.constantTypes = null, this.constantBitRatios = null, this.dynamicArguments = false, this.dynamicOutput = false, this.canvas = null, this.context = null, this.checkContext = null, this.gpu = null, this.functions = null, this.nativeFunctions = null, this.injectedNative = null, this.subKernels = null, this.validate = true, this.immutable = false, this.pipeline = false, this.precision = null, this.tactic = null, this.plugins = null, this.returnType = null, this.leadingReturnStatement = null, this.followingReturnStatement = null, this.optimizeFloatMemory = null, this.strictIntegers = false, this.fixIntegerDivisionAccuracy = null, this.built = false, this.signature = null;
          }
          mergeSettings(s) {
            for (let t in s)
              if (!(!s.hasOwnProperty(t) || !this.hasOwnProperty(t))) {
                switch (t) {
                  case "output":
                    if (!Array.isArray(s.output)) {
                      this.setOutput(s.output);
                      continue;
                    }
                    break;
                  case "functions":
                    this.functions = [];
                    for (let i = 0; i < s.functions.length; i++)
                      this.addFunction(s.functions[i]);
                    continue;
                  case "graphical":
                    s[t] && !s.hasOwnProperty("precision") && (this.precision = "unsigned"), this[t] = s[t];
                    continue;
                  case "nativeFunctions":
                    if (!s.nativeFunctions)
                      continue;
                    this.nativeFunctions = [];
                    for (let i = 0; i < s.nativeFunctions.length; i++) {
                      let u = s.nativeFunctions[i], { name: x2, source: w } = u;
                      this.addNativeFunction(x2, w, u);
                    }
                    continue;
                }
                this[t] = s[t];
              }
            this.canvas || (this.canvas = this.initCanvas()), this.context || (this.context = this.initContext()), this.plugins || (this.plugins = this.initPlugins(s));
          }
          build() {
            throw new Error(\`"build" not defined on \${this.constructor.name}\`);
          }
          run() {
            throw new Error(\`"run" not defined on \${this.constructor.name}\`);
          }
          initCanvas() {
            throw new Error(\`"initCanvas" not defined on \${this.constructor.name}\`);
          }
          initContext() {
            throw new Error(\`"initContext" not defined on \${this.constructor.name}\`);
          }
          initPlugins(s) {
            throw new Error(\`"initPlugins" not defined on \${this.constructor.name}\`);
          }
          addFunction(s, t = {}) {
            if (s.name && s.source && s.argumentTypes && "returnType" in s)
              this.functions.push(s);
            else if ("settings" in s && "source" in s)
              this.functions.push(this.functionToIGPUFunction(s.source, s.settings));
            else if (typeof s == "string" || typeof s == "function")
              this.functions.push(this.functionToIGPUFunction(s, t));
            else
              throw new Error("function not properly defined");
            return this;
          }
          addNativeFunction(s, t, i = {}) {
            let { argumentTypes: u, argumentNames: x2 } = i.argumentTypes ? l(i.argumentTypes) : this.constructor.nativeFunctionArguments(t) || {};
            return this.nativeFunctions.push({ name: s, source: t, settings: i, argumentTypes: u, argumentNames: x2, returnType: i.returnType || this.constructor.nativeFunctionReturnType(t) }), this;
          }
          setupArguments(s) {
            if (this.kernelArguments = [], this.argumentTypes)
              for (let t = 0; t < this.argumentTypes.length; t++)
                this.kernelArguments.push({ type: this.argumentTypes[t] });
            else if (!this.argumentTypes) {
              this.argumentTypes = [];
              for (let t = 0; t < s.length; t++) {
                let i = p.getVariableType(s[t], this.strictIntegers), u = i === "Integer" ? "Number" : i;
                this.argumentTypes.push(u), this.kernelArguments.push({ type: u });
              }
            }
            this.argumentSizes = new Array(s.length), this.argumentBitRatios = new Int32Array(s.length);
            for (let t = 0; t < s.length; t++) {
              let i = s[t];
              this.argumentSizes[t] = i.constructor === g ? i.size : null, this.argumentBitRatios[t] = this.getBitRatio(i);
            }
            if (this.argumentNames.length !== s.length)
              throw new Error("arguments are miss-aligned");
          }
          setupConstants() {
            this.kernelConstants = [];
            let s = this.constantTypes === null;
            if (s && (this.constantTypes = {}), this.constantBitRatios = {}, this.constants)
              for (let t in this.constants) {
                if (s) {
                  let i = p.getVariableType(this.constants[t], this.strictIntegers);
                  this.constantTypes[t] = i, this.kernelConstants.push({ name: t, type: i });
                } else
                  this.kernelConstants.push({ name: t, type: this.constantTypes[t] });
                this.constantBitRatios[t] = this.getBitRatio(this.constants[t]);
              }
          }
          setOptimizeFloatMemory(s) {
            return this.optimizeFloatMemory = s, this;
          }
          toKernelOutput(s) {
            return s.hasOwnProperty("x") ? s.hasOwnProperty("y") ? s.hasOwnProperty("z") ? [s.x, s.y, s.z] : [s.x, s.y] : [s.x] : s;
          }
          setOutput(s) {
            return this.output = this.toKernelOutput(s), this;
          }
          setDebug(s) {
            return this.debug = s, this;
          }
          setGraphical(s) {
            return this.graphical = s, this.precision = "unsigned", this;
          }
          setLoopMaxIterations(s) {
            return this.loopMaxIterations = s, this;
          }
          setConstants(s) {
            return this.constants = s, this;
          }
          setConstantTypes(s) {
            return this.constantTypes = s, this;
          }
          setFunctions(s) {
            for (let t = 0; t < s.length; t++)
              this.addFunction(s[t]);
            return this;
          }
          setNativeFunctions(s) {
            for (let t = 0; t < s.length; t++) {
              let i = s[t], { name: u, source: x2 } = i;
              this.addNativeFunction(u, x2, i);
            }
            return this;
          }
          setInjectedNative(s) {
            return this.injectedNative = s, this;
          }
          setPipeline(s) {
            return this.pipeline = s, this;
          }
          setPrecision(s) {
            return this.precision = s, this;
          }
          setDimensions(s) {
            return p.warnDeprecated("method", "setDimensions", "setOutput"), this.output = s, this;
          }
          setOutputToTexture(s) {
            return p.warnDeprecated("method", "setOutputToTexture", "setPipeline"), this.pipeline = s, this;
          }
          setImmutable(s) {
            return this.immutable = s, this;
          }
          setCanvas(s) {
            return this.canvas = s, this;
          }
          setStrictIntegers(s) {
            return this.strictIntegers = s, this;
          }
          setDynamicOutput(s) {
            return this.dynamicOutput = s, this;
          }
          setHardcodeConstants(s) {
            return p.warnDeprecated("method", "setHardcodeConstants"), this.setDynamicOutput(s), this.setDynamicArguments(s), this;
          }
          setDynamicArguments(s) {
            return this.dynamicArguments = s, this;
          }
          setUseLegacyEncoder(s) {
            return this.useLegacyEncoder = s, this;
          }
          setWarnVarUsage(s) {
            return p.warnDeprecated("method", "setWarnVarUsage"), this;
          }
          getCanvas() {
            return p.warnDeprecated("method", "getCanvas"), this.canvas;
          }
          getWebGl() {
            return p.warnDeprecated("method", "getWebGl"), this.context;
          }
          setContext(s) {
            return this.context = s, this;
          }
          setArgumentTypes(s) {
            if (Array.isArray(s))
              this.argumentTypes = s;
            else {
              this.argumentTypes = [];
              for (let t in s) {
                if (!s.hasOwnProperty(t))
                  continue;
                let i = this.argumentNames.indexOf(t);
                if (i === -1)
                  throw new Error(\`unable to find argument \${t}\`);
                this.argumentTypes[i] = s[t];
              }
            }
            return this;
          }
          setTactic(s) {
            return this.tactic = s, this;
          }
          requestFallback(s) {
            if (!this.onRequestFallback)
              throw new Error(\`"onRequestFallback" not defined on \${this.constructor.name}\`);
            return this.fallbackRequested = true, this.onRequestFallback(s);
          }
          validateSettings() {
            throw new Error(\`"validateSettings" not defined on \${this.constructor.name}\`);
          }
          addSubKernel(s) {
            if (this.subKernels === null && (this.subKernels = []), !s.source)
              throw new Error('subKernel missing "source" property');
            if (!s.property && isNaN(s.property))
              throw new Error('subKernel missing "property" property');
            if (!s.name)
              throw new Error('subKernel missing "name" property');
            return this.subKernels.push(s), this;
          }
          destroy(s) {
            throw new Error(\`"destroy" called on \${this.constructor.name}\`);
          }
          getBitRatio(s) {
            if (this.precision === "single")
              return 4;
            if (Array.isArray(s[0]))
              return this.getBitRatio(s[0]);
            if (s.constructor === g)
              return this.getBitRatio(s.value);
            switch (s.constructor) {
              case Uint8ClampedArray:
              case Uint8Array:
              case Int8Array:
                return 1;
              case Uint16Array:
              case Int16Array:
                return 2;
              case Float32Array:
              case Int32Array:
              default:
                return 4;
            }
          }
          getPixels(s) {
            throw new Error(\`"getPixels" called on \${this.constructor.name}\`);
          }
          checkOutput() {
            if (!this.output || !p.isArray(this.output))
              throw new Error("kernel.output not an array");
            if (this.output.length < 1)
              throw new Error("kernel.output is empty, needs at least 1 value");
            for (let s = 0; s < this.output.length; s++)
              if (isNaN(this.output[s]) || this.output[s] < 1)
                throw new Error(\`\${this.constructor.name}.output[\${s}] incorrectly defined as \\\`\${this.output[s]}\\\`, needs to be numeric, and greater than 0\`);
          }
          prependString(s) {
            throw new Error(\`"prependString" called on \${this.constructor.name}\`);
          }
          hasPrependString(s) {
            throw new Error(\`"hasPrependString" called on \${this.constructor.name}\`);
          }
          toJSON() {
            return { settings: { output: this.output, pipeline: this.pipeline, argumentNames: this.argumentNames, argumentsTypes: this.argumentTypes, constants: this.constants, pluginNames: this.plugins ? this.plugins.map((s) => s.name) : null, returnType: this.returnType } };
          }
          buildSignature(s) {
            let t = this.constructor;
            this.signature = t.getSignature(this, t.getArgumentTypes(this, s));
          }
          static getArgumentTypes(s, t) {
            let i = new Array(t.length);
            for (let u = 0; u < t.length; u++) {
              let x2 = t[u], w = s.argumentTypes[u];
              if (x2.type)
                i[u] = x2.type;
              else
                switch (w) {
                  case "Number":
                  case "Integer":
                  case "Float":
                  case "ArrayTexture(1)":
                    i[u] = p.getVariableType(x2);
                    break;
                  default:
                    i[u] = w;
                }
            }
            return i;
          }
          static getSignature(s, t) {
            throw new Error(\`"getSignature" not implemented on \${this.name}\`);
          }
          functionToIGPUFunction(s, t = {}) {
            if (typeof s != "string" && typeof s != "function")
              throw new Error("source not a string or function");
            let i = typeof s == "string" ? s : s.toString(), u = [];
            return Array.isArray(t.argumentTypes) ? u = t.argumentTypes : typeof t.argumentTypes == "object" ? u = p.getArgumentNamesFromString(i).map((x2) => t.argumentTypes[x2]) || [] : u = t.argumentTypes || [], { name: p.getFunctionNameFromString(i) || null, source: i, argumentTypes: u, returnType: t.returnType || null };
          }
          onActivate(s) {
          }
        }
        function l(n) {
          let s = Object.keys(n), t = [];
          for (let i = 0; i < s.length; i++) {
            let u = s[i];
            t.push(n[u]);
          }
          return { argumentTypes: t, argumentNames: s };
        }
        y.exports = { Kernel: f };
      }, { "../input": 110, "../utils": 114 }], 37: [function(o, y, E) {
        let p = \`__HEADER__;
      __FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      
      const int LOOP_MAX = __LOOP_MAX__;
      
      __PLUGINS__;
      __CONSTANTS__;
      
      varying vec2 vTexCoord;
      
      float acosh(float x) {
        return log(x + sqrt(x * x - 1.0));
      }
      
      float sinh(float x) {
        return (pow(\${Math.E}, x) - pow(\${Math.E}, -x)) / 2.0;
      }
      
      float asinh(float x) {
        return log(x + sqrt(x * x + 1.0));
      }
      
      float atan2(float v1, float v2) {
        if (v1 == 0.0 || v2 == 0.0) return 0.0;
        return atan(v1 / v2);
      }
      
      float atanh(float x) {
        x = (x + 1.0) / (x - 1.0);
        if (x < 0.0) {
          return 0.5 * log(-x);
        }
        return 0.5 * log(x);
      }
      
      float cbrt(float x) {
        if (x >= 0.0) {
          return pow(x, 1.0 / 3.0);
        } else {
          return -pow(x, 1.0 / 3.0);
        }
      }
      
      float cosh(float x) {
        return (pow(\${Math.E}, x) + pow(\${Math.E}, -x)) / 2.0; 
      }
      
      float expm1(float x) {
        return pow(\${Math.E}, x) - 1.0; 
      }
      
      float fround(highp float x) {
        return x;
      }
      
      float imul(float v1, float v2) {
        return float(int(v1) * int(v2));
      }
      
      float log10(float x) {
        return log2(x) * (1.0 / log2(10.0));
      }
      
      float log1p(float x) {
        return log(1.0 + x);
      }
      
      float _pow(float v1, float v2) {
        if (v2 == 0.0) return 1.0;
        return pow(v1, v2);
      }
      
      float tanh(float x) {
        float e = exp(2.0 * x);
        return (e - 1.0) / (e + 1.0);
      }
      
      float trunc(float x) {
        if (x >= 0.0) {
          return floor(x); 
        } else {
          return ceil(x);
        }
      }
      
      vec4 _round(vec4 x) {
        return floor(x + 0.5);
      }
      
      float _round(float x) {
        return floor(x + 0.5);
      }
      
      const int BIT_COUNT = 32;
      int modi(int x, int y) {
        return x - y * (x / y);
      }
      
      int bitwiseOr(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseXOR(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseAnd(int a, int b) {
        int result = 0;
        int n = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 && b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseNot(int a) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if (modi(a, 2) == 0) {
            result += n;    
          }
          a = a / 2;
          n = n * 2;
        }
        return result;
      }
      int bitwiseZeroFillLeftShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n *= 2;
        }
      
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      int bitwiseSignedRightShift(int num, int shifts) {
        return int(floor(float(num) / pow(2.0, float(shifts))));
      }
      
      int bitwiseZeroFillRightShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n /= 2;
        }
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      vec2 integerMod(vec2 x, float y) {
        vec2 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec3 integerMod(vec3 x, float y) {
        vec3 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec4 integerMod(vec4 x, vec4 y) {
        vec4 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      float integerMod(float x, float y) {
        float res = floor(mod(x, y));
        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
      }
      
      int integerMod(int x, int y) {
        return x - (y * int(x / y));
      }
      
      __DIVIDE_WITH_INTEGER_CHECK__;
      
      // Here be dragons!
      // DO NOT OPTIMIZE THIS CODE
      // YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
      const vec2 MAGIC_VEC = vec2(1.0, -256.0);
      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
      float decode32(vec4 texel) {
        __DECODE32_ENDIANNESS__;
        texel *= 255.0;
        vec2 gte128;
        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
        float res = exp2(_round(exponent));
        texel.b = texel.b - 128.0 * gte128.x;
        res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
        res *= gte128.y * -2.0 + 1.0;
        return res;
      }
      
      float decode16(vec4 texel, int index) {
        int channel = integerMod(index, 2);
        if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
        if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
        return 0.0;
      }
      
      float decode8(vec4 texel, int index) {
        int channel = integerMod(index, 4);
        if (channel == 0) return texel.r * 255.0;
        if (channel == 1) return texel.g * 255.0;
        if (channel == 2) return texel.b * 255.0;
        if (channel == 3) return texel.a * 255.0;
        return 0.0;
      }
      
      vec4 legacyEncode32(float f) {
        float F = abs(f);
        float sign = f < 0.0 ? 1.0 : 0.0;
        float exponent = floor(log2(F));
        float mantissa = (exp2(-exponent) * F);
        // exponent += floor(log2(mantissa));
        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
        texel.rg = integerMod(texel.rg, 256.0);
        texel.b = integerMod(texel.b, 128.0);
        texel.a = exponent*0.5 + 63.5;
        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
        texel = floor(texel);
        texel *= 0.003921569; // 1/255
        __ENCODE32_ENDIANNESS__;
        return texel;
      }
      
      // https://github.com/gpujs/gpu.js/wiki/Encoder-details
      vec4 encode32(float value) {
        if (value == 0.0) return vec4(0, 0, 0, 0);
      
        float exponent;
        float mantissa;
        vec4  result;
        float sgn;
      
        sgn = step(0.0, -value);
        value = abs(value);
      
        exponent = floor(log2(value));
      
        mantissa = value*pow(2.0, -exponent)-1.0;
        exponent = exponent+127.0;
        result   = vec4(0,0,0,0);
      
        result.a = floor(exponent/2.0);
        exponent = exponent - result.a*2.0;
        result.a = result.a + 128.0*sgn;
      
        result.b = floor(mantissa * 128.0);
        mantissa = mantissa - result.b / 128.0;
        result.b = result.b + exponent*128.0;
      
        result.g = floor(mantissa*32768.0);
        mantissa = mantissa - result.g/32768.0;
      
        result.r = floor(mantissa*8388608.0);
        return result/255.0;
      }
      // Dragons end here
      
      int index;
      ivec3 threadId;
      
      ivec3 indexTo3D(int idx, ivec3 texDim) {
        int z = int(idx / (texDim.x * texDim.y));
        idx -= z * int(texDim.x * texDim.y);
        int y = int(idx / texDim.x);
        int x = int(integerMod(idx, texDim.x));
        return ivec3(x, y, z);
      }
      
      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        return decode32(texel);
      }
      
      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x * 2;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
        return decode16(texel, index);
      }
      
      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x * 4;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
        return decode8(texel, index);
      }
      
      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 4);
        index = index / 4;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        if (channel == 0) return texel.r;
        if (channel == 1) return texel.g;
        if (channel == 2) return texel.b;
        if (channel == 3) return texel.a;
        return 0.0;
      }
      
      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        return texture2D(tex, st / vec2(texSize));
      }
      
      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return result[0];
      }
      
      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec2(result[0], result[1]);
      }
      
      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int channel = integerMod(index, 2);
        index = index / 2;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        if (channel == 0) return vec2(texel.r, texel.g);
        if (channel == 1) return vec2(texel.b, texel.a);
        return vec2(0.0, 0.0);
      }
      
      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec3(result[0], result[1], result[2]);
      }
      
      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
        int vectorIndex = fieldIndex / 4;
        int vectorOffset = fieldIndex - vectorIndex * 4;
        int readY = vectorIndex / texSize.x;
        int readX = vectorIndex - readY * texSize.x;
        vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
        
        if (vectorOffset == 0) {
          return tex1.xyz;
        } else if (vectorOffset == 1) {
          return tex1.yzw;
        } else {
          readX++;
          if (readX >= texSize.x) {
            readX = 0;
            readY++;
          }
          vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
          if (vectorOffset == 2) {
            return vec3(tex1.z, tex1.w, tex2.x);
          } else {
            return vec3(tex1.w, tex2.x, tex2.y);
          }
        }
      }
      
      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        return getImage2D(tex, texSize, texDim, z, y, x);
      }
      
      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 2);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture2D(tex, st / vec2(texSize));
        return vec4(texel.r, texel.g, texel.b, texel.a);
      }
      
      vec4 actualColor;
      void color(float r, float g, float b, float a) {
        actualColor = vec4(r,g,b,a);
      }
      
      void color(float r, float g, float b) {
        color(r,g,b,1.0);
      }
      
      void color(sampler2D image) {
        actualColor = texture2D(image, vTexCoord);
      }
      
      float modulo(float number, float divisor) {
        if (number < 0.0) {
          number = abs(number);
          if (divisor < 0.0) {
            divisor = abs(divisor);
          }
          return -mod(number, divisor);
        }
        if (divisor < 0.0) {
          divisor = abs(divisor);
        }
        return mod(number, divisor);
      }
      
      __INJECTED_NATIVE__;
      __MAIN_CONSTANTS__;
      __MAIN_ARGUMENTS__;
      __KERNEL__;
      
      void main(void) {
        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
        __MAIN_RESULT__;
      }\`;
        y.exports = { fragmentShader: p };
      }, {}], 38: [function(o, y, E) {
        let { utils: p } = o("../../utils"), { FunctionNode: g } = o("../function-node");
        class f extends g {
          constructor(t, i) {
            super(t, i), i && i.hasOwnProperty("fixIntegerDivisionAccuracy") && (this.fixIntegerDivisionAccuracy = i.fixIntegerDivisionAccuracy);
          }
          astConditionalExpression(t, i) {
            if (t.type !== "ConditionalExpression")
              throw this.astErrorOutput("Not a conditional expression", t);
            let u = this.getType(t.consequent), x2 = this.getType(t.alternate);
            return u === null && x2 === null ? (i.push("if ("), this.astGeneric(t.test, i), i.push(") {"), this.astGeneric(t.consequent, i), i.push(";"), i.push("} else {"), this.astGeneric(t.alternate, i), i.push(";"), i.push("}"), i) : (i.push("("), this.astGeneric(t.test, i), i.push("?"), this.astGeneric(t.consequent, i), i.push(":"), this.astGeneric(t.alternate, i), i.push(")"), i);
          }
          astFunction(t, i) {
            if (this.isRootKernel)
              i.push("void");
            else {
              this.returnType || this.findLastReturn() && (this.returnType = this.getType(t.body), this.returnType === "LiteralInteger" && (this.returnType = "Number"));
              let { returnType: u } = this;
              if (!u)
                i.push("void");
              else {
                let x2 = l[u];
                if (!x2)
                  throw new Error(\`unknown type \${u}\`);
                i.push(x2);
              }
            }
            if (i.push(" "), i.push(this.name), i.push("("), !this.isRootKernel)
              for (let u = 0; u < this.argumentNames.length; ++u) {
                let x2 = this.argumentNames[u];
                u > 0 && i.push(", ");
                let w = this.argumentTypes[this.argumentNames.indexOf(x2)];
                if (!w)
                  throw this.astErrorOutput(\`Unknown argument \${x2} type\`, t);
                w === "LiteralInteger" && (this.argumentTypes[u] = w = "Number");
                let m = l[w];
                if (!m)
                  throw this.astErrorOutput("Unexpected expression", t);
                let S = p.sanitizeName(x2);
                m === "sampler2D" || m === "sampler2DArray" ? i.push(\`\${m} user_\${S},ivec2 user_\${S}Size,ivec3 user_\${S}Dim\`) : i.push(\`\${m} user_\${S}\`);
              }
            i.push(\`) {
\`);
            for (let u = 0; u < t.body.body.length; ++u)
              this.astGeneric(t.body.body[u], i), i.push(\`
\`);
            return i.push(\`}
\`), i;
          }
          astReturnStatement(t, i) {
            if (!t.argument)
              throw this.astErrorOutput("Unexpected return statement", t);
            this.pushState("skip-literal-correction");
            let u = this.getType(t.argument);
            this.popState("skip-literal-correction");
            let x2 = [];
            switch (this.returnType || (u === "LiteralInteger" || u === "Integer" ? this.returnType = "Number" : this.returnType = u), this.returnType) {
              case "LiteralInteger":
              case "Number":
              case "Float":
                switch (u) {
                  case "Integer":
                    x2.push("float("), this.astGeneric(t.argument, x2), x2.push(")");
                    break;
                  case "LiteralInteger":
                    this.castLiteralToFloat(t.argument, x2), this.getType(t) === "Integer" && (x2.unshift("float("), x2.push(")"));
                    break;
                  default:
                    this.astGeneric(t.argument, x2);
                }
                break;
              case "Integer":
                switch (u) {
                  case "Float":
                  case "Number":
                    this.castValueToInteger(t.argument, x2);
                    break;
                  case "LiteralInteger":
                    this.castLiteralToInteger(t.argument, x2);
                    break;
                  default:
                    this.astGeneric(t.argument, x2);
                }
                break;
              case "Array(4)":
              case "Array(3)":
              case "Array(2)":
              case "Matrix(2)":
              case "Matrix(3)":
              case "Matrix(4)":
              case "Input":
                this.astGeneric(t.argument, x2);
                break;
              default:
                throw this.astErrorOutput(\`unhandled return type \${this.returnType}\`, t);
            }
            return this.isRootKernel ? (i.push(\`kernelResult = \${x2.join("")};\`), i.push("return;")) : this.isSubKernel ? (i.push(\`subKernelResult_\${this.name} = \${x2.join("")};\`), i.push(\`return subKernelResult_\${this.name};\`)) : i.push(\`return \${x2.join("")};\`), i;
          }
          astLiteral(t, i) {
            if (isNaN(t.value))
              throw this.astErrorOutput("Non-numeric literal not supported : " + t.value, t);
            let u = this.astKey(t);
            return Number.isInteger(t.value) ? this.isState("casting-to-integer") || this.isState("building-integer") ? (this.literalTypes[u] = "Integer", i.push(\`\${t.value}\`)) : this.isState("casting-to-float") || this.isState("building-float") ? (this.literalTypes[u] = "Number", i.push(\`\${t.value}.0\`)) : (this.literalTypes[u] = "Number", i.push(\`\${t.value}.0\`)) : this.isState("casting-to-integer") || this.isState("building-integer") ? (this.literalTypes[u] = "Integer", i.push(Math.round(t.value))) : (this.literalTypes[u] = "Number", i.push(\`\${t.value}\`)), i;
          }
          astBinaryExpression(t, i) {
            if (this.checkAndUpconvertOperator(t, i))
              return i;
            if (this.fixIntegerDivisionAccuracy && t.operator === "/") {
              switch (i.push("divWithIntCheck("), this.pushState("building-float"), this.getType(t.left)) {
                case "Integer":
                  this.castValueToFloat(t.left, i);
                  break;
                case "LiteralInteger":
                  this.castLiteralToFloat(t.left, i);
                  break;
                default:
                  this.astGeneric(t.left, i);
              }
              switch (i.push(", "), this.getType(t.right)) {
                case "Integer":
                  this.castValueToFloat(t.right, i);
                  break;
                case "LiteralInteger":
                  this.castLiteralToFloat(t.right, i);
                  break;
                default:
                  this.astGeneric(t.right, i);
              }
              return this.popState("building-float"), i.push(")"), i;
            }
            i.push("(");
            let u = this.getType(t.left) || "Number", x2 = this.getType(t.right) || "Number";
            if (!u || !x2)
              throw this.astErrorOutput("Unhandled binary expression", t);
            let w = u + " & " + x2;
            switch (w) {
              case "Integer & Integer":
                this.pushState("building-integer"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.astGeneric(t.right, i), this.popState("building-integer");
                break;
              case "Number & Float":
              case "Float & Number":
              case "Float & Float":
              case "Number & Number":
                this.pushState("building-float"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.astGeneric(t.right, i), this.popState("building-float");
                break;
              case "LiteralInteger & LiteralInteger":
                this.isState("casting-to-integer") || this.isState("building-integer") ? (this.pushState("building-integer"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.astGeneric(t.right, i), this.popState("building-integer")) : (this.pushState("building-float"), this.castLiteralToFloat(t.left, i), i.push(n[t.operator] || t.operator), this.castLiteralToFloat(t.right, i), this.popState("building-float"));
                break;
              case "Integer & Float":
              case "Integer & Number":
                if ((t.operator === ">" || t.operator === "<" && t.right.type === "Literal") && !Number.isInteger(t.right.value)) {
                  this.pushState("building-float"), this.castValueToFloat(t.left, i), i.push(n[t.operator] || t.operator), this.astGeneric(t.right, i), this.popState("building-float");
                  break;
                }
                if (this.pushState("building-integer"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.pushState("casting-to-integer"), t.right.type === "Literal") {
                  let m = [];
                  if (this.astGeneric(t.right, m), this.getType(t.right) === "Integer")
                    i.push(m.join(""));
                  else
                    throw this.astErrorOutput("Unhandled binary expression with literal", t);
                } else
                  i.push("int("), this.astGeneric(t.right, i), i.push(")");
                this.popState("casting-to-integer"), this.popState("building-integer");
                break;
              case "Integer & LiteralInteger":
                this.pushState("building-integer"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.castLiteralToInteger(t.right, i), this.popState("building-integer");
                break;
              case "Number & Integer":
                this.pushState("building-float"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.castValueToFloat(t.right, i), this.popState("building-float");
                break;
              case "Float & LiteralInteger":
              case "Number & LiteralInteger":
                this.pushState("building-float"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.castLiteralToFloat(t.right, i), this.popState("building-float");
                break;
              case "LiteralInteger & Float":
              case "LiteralInteger & Number":
                this.isState("casting-to-integer") ? (this.pushState("building-integer"), this.castLiteralToInteger(t.left, i), i.push(n[t.operator] || t.operator), this.castValueToInteger(t.right, i), this.popState("building-integer")) : (this.pushState("building-float"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.pushState("casting-to-float"), this.astGeneric(t.right, i), this.popState("casting-to-float"), this.popState("building-float"));
                break;
              case "LiteralInteger & Integer":
                this.pushState("building-integer"), this.castLiteralToInteger(t.left, i), i.push(n[t.operator] || t.operator), this.astGeneric(t.right, i), this.popState("building-integer");
                break;
              case "Boolean & Boolean":
                this.pushState("building-boolean"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.astGeneric(t.right, i), this.popState("building-boolean");
                break;
              case "Float & Integer":
                this.pushState("building-float"), this.astGeneric(t.left, i), i.push(n[t.operator] || t.operator), this.castValueToFloat(t.right, i), this.popState("building-float");
                break;
              default:
                throw this.astErrorOutput(\`Unhandled binary expression between \${w}\`, t);
            }
            return i.push(")"), i;
          }
          checkAndUpconvertOperator(t, i) {
            let u = this.checkAndUpconvertBitwiseOperators(t, i);
            if (u)
              return u;
            let w = { "%": this.fixIntegerDivisionAccuracy ? "integerCorrectionModulo" : "modulo", "**": "pow" }[t.operator];
            if (!w)
              return null;
            switch (i.push(w), i.push("("), this.getType(t.left)) {
              case "Integer":
                this.castValueToFloat(t.left, i);
                break;
              case "LiteralInteger":
                this.castLiteralToFloat(t.left, i);
                break;
              default:
                this.astGeneric(t.left, i);
            }
            switch (i.push(","), this.getType(t.right)) {
              case "Integer":
                this.castValueToFloat(t.right, i);
                break;
              case "LiteralInteger":
                this.castLiteralToFloat(t.right, i);
                break;
              default:
                this.astGeneric(t.right, i);
            }
            return i.push(")"), i;
          }
          checkAndUpconvertBitwiseOperators(t, i) {
            let x2 = { "&": "bitwiseAnd", "|": "bitwiseOr", "^": "bitwiseXOR", "<<": "bitwiseZeroFillLeftShift", ">>": "bitwiseSignedRightShift", ">>>": "bitwiseZeroFillRightShift" }[t.operator];
            if (!x2)
              return null;
            switch (i.push(x2), i.push("("), this.getType(t.left)) {
              case "Number":
              case "Float":
                this.castValueToInteger(t.left, i);
                break;
              case "LiteralInteger":
                this.castLiteralToInteger(t.left, i);
                break;
              default:
                this.astGeneric(t.left, i);
            }
            switch (i.push(","), this.getType(t.right)) {
              case "Number":
              case "Float":
                this.castValueToInteger(t.right, i);
                break;
              case "LiteralInteger":
                this.castLiteralToInteger(t.right, i);
                break;
              default:
                this.astGeneric(t.right, i);
            }
            return i.push(")"), i;
          }
          checkAndUpconvertBitwiseUnary(t, i) {
            let x2 = { "~": "bitwiseNot" }[t.operator];
            if (!x2)
              return null;
            switch (i.push(x2), i.push("("), this.getType(t.argument)) {
              case "Number":
              case "Float":
                this.castValueToInteger(t.argument, i);
                break;
              case "LiteralInteger":
                this.castLiteralToInteger(t.argument, i);
                break;
              default:
                this.astGeneric(t.argument, i);
            }
            return i.push(")"), i;
          }
          castLiteralToInteger(t, i) {
            return this.pushState("casting-to-integer"), this.astGeneric(t, i), this.popState("casting-to-integer"), i;
          }
          castLiteralToFloat(t, i) {
            return this.pushState("casting-to-float"), this.astGeneric(t, i), this.popState("casting-to-float"), i;
          }
          castValueToInteger(t, i) {
            return this.pushState("casting-to-integer"), i.push("int("), this.astGeneric(t, i), i.push(")"), this.popState("casting-to-integer"), i;
          }
          castValueToFloat(t, i) {
            return this.pushState("casting-to-float"), i.push("float("), this.astGeneric(t, i), i.push(")"), this.popState("casting-to-float"), i;
          }
          astIdentifierExpression(t, i) {
            if (t.type !== "Identifier")
              throw this.astErrorOutput("IdentifierExpression - not an Identifier", t);
            let u = this.getType(t), x2 = p.sanitizeName(t.name);
            return t.name === "Infinity" ? i.push("3.402823466e+38") : u === "Boolean" ? this.argumentNames.indexOf(x2) > -1 ? i.push(\`bool(user_\${x2})\`) : i.push(\`user_\${x2}\`) : i.push(\`user_\${x2}\`), i;
          }
          astForStatement(t, i) {
            if (t.type !== "ForStatement")
              throw this.astErrorOutput("Invalid for statement", t);
            let u = [], x2 = [], w = [], m = [], S = null;
            if (t.init) {
              let { declarations: v } = t.init;
              v.length > 1 && (S = false), this.astGeneric(t.init, u);
              for (let h = 0; h < v.length; h++)
                v[h].init && v[h].init.type !== "Literal" && (S = false);
            } else
              S = false;
            if (t.test ? this.astGeneric(t.test, x2) : S = false, t.update ? this.astGeneric(t.update, w) : S = false, t.body && (this.pushState("loop-body"), this.astGeneric(t.body, m), this.popState("loop-body")), S === null && (S = this.isSafe(t.init) && this.isSafe(t.test)), S) {
              let v = u.join(""), h = v[v.length - 1] !== ";";
              i.push(\`for (\${v}\${h ? ";" : ""}\${x2.join("")};\${w.join("")}){
\`), i.push(m.join("")), i.push(\`}
\`);
            } else {
              let v = this.getInternalVariableName("safeI");
              u.length > 0 && i.push(u.join(""), \`
\`), i.push(\`for (int \${v}=0;\${v}<LOOP_MAX;\${v}++){
\`), x2.length > 0 && i.push(\`if (!\${x2.join("")}) break;
\`), i.push(m.join("")), i.push(\`
\${w.join("")};\`), i.push(\`}
\`);
            }
            return i;
          }
          astWhileStatement(t, i) {
            if (t.type !== "WhileStatement")
              throw this.astErrorOutput("Invalid while statement", t);
            let u = this.getInternalVariableName("safeI");
            return i.push(\`for (int \${u}=0;\${u}<LOOP_MAX;\${u}++){
\`), i.push("if (!"), this.astGeneric(t.test, i), i.push(\`) break;
\`), this.astGeneric(t.body, i), i.push(\`}
\`), i;
          }
          astDoWhileStatement(t, i) {
            if (t.type !== "DoWhileStatement")
              throw this.astErrorOutput("Invalid while statement", t);
            let u = this.getInternalVariableName("safeI");
            return i.push(\`for (int \${u}=0;\${u}<LOOP_MAX;\${u}++){
\`), this.astGeneric(t.body, i), i.push("if (!"), this.astGeneric(t.test, i), i.push(\`) break;
\`), i.push(\`}
\`), i;
          }
          astAssignmentExpression(t, i) {
            if (t.operator === "%=")
              this.astGeneric(t.left, i), i.push("="), i.push("mod("), this.astGeneric(t.left, i), i.push(","), this.astGeneric(t.right, i), i.push(")");
            else if (t.operator === "**=")
              this.astGeneric(t.left, i), i.push("="), i.push("pow("), this.astGeneric(t.left, i), i.push(","), this.astGeneric(t.right, i), i.push(")");
            else {
              let u = this.getType(t.left), x2 = this.getType(t.right);
              return this.astGeneric(t.left, i), i.push(t.operator), u !== "Integer" && x2 === "Integer" ? (i.push("float("), this.astGeneric(t.right, i), i.push(")")) : this.astGeneric(t.right, i), i;
            }
          }
          astBlockStatement(t, i) {
            if (this.isState("loop-body")) {
              this.pushState("block-body");
              for (let u = 0; u < t.body.length; u++)
                this.astGeneric(t.body[u], i);
              this.popState("block-body");
            } else {
              i.push(\`{
\`);
              for (let u = 0; u < t.body.length; u++)
                this.astGeneric(t.body[u], i);
              i.push(\`}
\`);
            }
            return i;
          }
          astVariableDeclaration(t, i) {
            let u = t.declarations;
            if (!u || !u[0] || !u[0].init)
              throw this.astErrorOutput("Unexpected expression", t);
            let x2 = [], w = null, m = [], S = [];
            for (let v = 0; v < u.length; v++) {
              let h = u[v], b = h.init, T = this.getDeclaration(h.id), C = this.getType(h.init), V = C;
              V === "LiteralInteger" && (T.suggestedType === "Integer" ? V = "Integer" : V = "Number");
              let c = l[V];
              if (!c)
                throw this.astErrorOutput(\`Markup type \${V} not handled\`, t);
              let a = [];
              if (C === "Integer" && V === "Integer") {
                if (T.valueType = "Number", v === 0 || w === null)
                  a.push("float ");
                else if (V !== w)
                  throw new Error("Unhandled declaration");
                w = V, a.push(\`user_\${p.sanitizeName(h.id.name)}=\`), a.push("float("), this.astGeneric(b, a), a.push(")");
              } else
                T.valueType = V, v === 0 || w === null ? a.push(\`\${c} \`) : V !== w && (m.push(S.join(",")), S = [], a.push(\`\${c} \`)), w = V, a.push(\`user_\${p.sanitizeName(h.id.name)}=\`), C === "Number" && V === "Integer" ? b.left && b.left.type === "Literal" ? this.astGeneric(b, a) : (a.push("int("), this.astGeneric(b, a), a.push(")")) : C === "LiteralInteger" && V === "Integer" ? this.castLiteralToInteger(b, a) : this.astGeneric(b, a);
              S.push(a.join(""));
            }
            return S.length > 0 && m.push(S.join(",")), x2.push(m.join(";")), i.push(x2.join("")), i.push(";"), i;
          }
          astIfStatement(t, i) {
            return i.push("if ("), this.astGeneric(t.test, i), i.push(")"), t.consequent.type === "BlockStatement" ? this.astGeneric(t.consequent, i) : (i.push(\` {
\`), this.astGeneric(t.consequent, i), i.push(\`
}
\`)), t.alternate && (i.push("else "), t.alternate.type === "BlockStatement" || t.alternate.type === "IfStatement" ? this.astGeneric(t.alternate, i) : (i.push(\` {
\`), this.astGeneric(t.alternate, i), i.push(\`
}
\`))), i;
          }
          astSwitchStatement(t, i) {
            if (t.type !== "SwitchStatement")
              throw this.astErrorOutput("Invalid switch statement", t);
            let { discriminant: u, cases: x2 } = t, w = this.getType(u), m = \`switchDiscriminant\${this.astKey(t, "_")}\`;
            switch (w) {
              case "Float":
              case "Number":
                i.push(\`float \${m} = \`), this.astGeneric(u, i), i.push(\`;
\`);
                break;
              case "Integer":
                i.push(\`int \${m} = \`), this.astGeneric(u, i), i.push(\`;
\`);
                break;
            }
            if (x2.length === 1 && !x2[0].test)
              return this.astGeneric(x2[0].consequent, i), i;
            let S = false, v = [], h = false, b = false;
            for (let T = 0; T < x2.length; T++) {
              if (x2[T].test) {
                if (T === 0 || !b ? (b = true, i.push(\`if (\${m} == \`)) : S ? (i.push(\`\${m} == \`), S = false) : i.push(\` else if (\${m} == \`), w === "Integer")
                  switch (this.getType(x2[T].test)) {
                    case "Number":
                    case "Float":
                      this.castValueToInteger(x2[T].test, i);
                      break;
                    case "LiteralInteger":
                      this.castLiteralToInteger(x2[T].test, i);
                      break;
                  }
                else if (w === "Float")
                  switch (this.getType(x2[T].test)) {
                    case "LiteralInteger":
                      this.castLiteralToFloat(x2[T].test, i);
                      break;
                    case "Integer":
                      this.castValueToFloat(x2[T].test, i);
                      break;
                  }
                else
                  throw new Error("unhanlded");
                if (!x2[T].consequent || x2[T].consequent.length === 0) {
                  S = true, i.push(" || ");
                  continue;
                }
                i.push(\`) {
\`);
              } else if (x2.length > T + 1) {
                h = true, this.astGeneric(x2[T].consequent, v);
                continue;
              } else
                i.push(\` else {
\`);
              this.astGeneric(x2[T].consequent, i), i.push(\`
}\`);
            }
            return h && (i.push(" else {"), i.push(v.join("")), i.push("}")), i;
          }
          astThisExpression(t, i) {
            return i.push("this"), i;
          }
          astMemberExpression(t, i) {
            let { property: u, name: x2, signature: w, origin: m, type: S, xProperty: v, yProperty: h, zProperty: b } = this.getMemberExpressionDetails(t);
            switch (w) {
              case "value.thread.value":
              case "this.thread.value":
                if (x2 !== "x" && x2 !== "y" && x2 !== "z")
                  throw this.astErrorOutput("Unexpected expression, expected \`this.thread.x\`, \`this.thread.y\`, or \`this.thread.z\`", t);
                return i.push(\`threadId.\${x2}\`), i;
              case "this.output.value":
                if (this.dynamicOutput)
                  switch (x2) {
                    case "x":
                      this.isState("casting-to-float") ? i.push("float(uOutputDim.x)") : i.push("uOutputDim.x");
                      break;
                    case "y":
                      this.isState("casting-to-float") ? i.push("float(uOutputDim.y)") : i.push("uOutputDim.y");
                      break;
                    case "z":
                      this.isState("casting-to-float") ? i.push("float(uOutputDim.z)") : i.push("uOutputDim.z");
                      break;
                    default:
                      throw this.astErrorOutput("Unexpected expression", t);
                  }
                else
                  switch (x2) {
                    case "x":
                      this.isState("casting-to-integer") ? i.push(this.output[0]) : i.push(this.output[0], ".0");
                      break;
                    case "y":
                      this.isState("casting-to-integer") ? i.push(this.output[1]) : i.push(this.output[1], ".0");
                      break;
                    case "z":
                      this.isState("casting-to-integer") ? i.push(this.output[2]) : i.push(this.output[2], ".0");
                      break;
                    default:
                      throw this.astErrorOutput("Unexpected expression", t);
                  }
                return i;
              case "value":
                throw this.astErrorOutput("Unexpected expression", t);
              case "value[]":
              case "value[][]":
              case "value[][][]":
              case "value[][][][]":
              case "value.value":
                if (m === "Math")
                  return i.push(Math[x2]), i;
                let C = p.sanitizeName(x2);
                switch (u) {
                  case "r":
                    return i.push(\`user_\${C}.r\`), i;
                  case "g":
                    return i.push(\`user_\${C}.g\`), i;
                  case "b":
                    return i.push(\`user_\${C}.b\`), i;
                  case "a":
                    return i.push(\`user_\${C}.a\`), i;
                }
                break;
              case "this.constants.value":
                if (typeof v > "u")
                  switch (S) {
                    case "Array(2)":
                    case "Array(3)":
                    case "Array(4)":
                      return i.push(\`constants_\${p.sanitizeName(x2)}\`), i;
                  }
              case "this.constants.value[]":
              case "this.constants.value[][]":
              case "this.constants.value[][][]":
              case "this.constants.value[][][][]":
                break;
              case "fn()[]":
                return this.astCallExpression(t.object, i), i.push("["), i.push(this.memberExpressionPropertyMarkup(u)), i.push("]"), i;
              case "fn()[][]":
                return this.astCallExpression(t.object.object, i), i.push("["), i.push(this.memberExpressionPropertyMarkup(t.object.property)), i.push("]"), i.push("["), i.push(this.memberExpressionPropertyMarkup(t.property)), i.push("]"), i;
              case "[][]":
                return this.astArrayExpression(t.object, i), i.push("["), i.push(this.memberExpressionPropertyMarkup(u)), i.push("]"), i;
              default:
                throw this.astErrorOutput("Unexpected expression", t);
            }
            if (t.computed === false)
              switch (S) {
                case "Number":
                case "Integer":
                case "Float":
                case "Boolean":
                  return i.push(\`\${m}_\${p.sanitizeName(x2)}\`), i;
              }
            let T = \`\${m}_\${p.sanitizeName(x2)}\`;
            switch (S) {
              case "Array(2)":
              case "Array(3)":
              case "Array(4)":
                this.astGeneric(t.object, i), i.push("["), i.push(this.memberExpressionPropertyMarkup(v)), i.push("]");
                break;
              case "HTMLImageArray":
                i.push(\`getImage3D(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "ArrayTexture(1)":
                i.push(\`getFloatFromSampler2D(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "Array1D(2)":
              case "Array2D(2)":
              case "Array3D(2)":
                i.push(\`getMemoryOptimizedVec2(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "ArrayTexture(2)":
                i.push(\`getVec2FromSampler2D(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "Array1D(3)":
              case "Array2D(3)":
              case "Array3D(3)":
                i.push(\`getMemoryOptimizedVec3(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "ArrayTexture(3)":
                i.push(\`getVec3FromSampler2D(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "Array1D(4)":
              case "Array2D(4)":
              case "Array3D(4)":
                i.push(\`getMemoryOptimizedVec4(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "ArrayTexture(4)":
              case "HTMLCanvas":
              case "HTMLImage":
              case "HTMLVideo":
                i.push(\`getVec4FromSampler2D(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "NumberTexture":
              case "Array":
              case "Array2D":
              case "Array3D":
              case "Array4D":
              case "Input":
              case "Number":
              case "Float":
              case "Integer":
                if (this.precision === "single")
                  i.push(\`getMemoryOptimized32(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                else {
                  let C = m === "user" ? this.lookupFunctionArgumentBitRatio(this.name, x2) : this.constantBitRatios[x2];
                  switch (C) {
                    case 1:
                      i.push(\`get8(\${T}, \${T}Size, \${T}Dim, \`);
                      break;
                    case 2:
                      i.push(\`get16(\${T}, \${T}Size, \${T}Dim, \`);
                      break;
                    case 4:
                    case 0:
                      i.push(\`get32(\${T}, \${T}Size, \${T}Dim, \`);
                      break;
                    default:
                      throw new Error(\`unhandled bit ratio of \${C}\`);
                  }
                  this.memberExpressionXYZ(v, h, b, i), i.push(")");
                }
                break;
              case "MemoryOptimizedNumberTexture":
                i.push(\`getMemoryOptimized32(\${T}, \${T}Size, \${T}Dim, \`), this.memberExpressionXYZ(v, h, b, i), i.push(")");
                break;
              case "Matrix(2)":
              case "Matrix(3)":
              case "Matrix(4)":
                i.push(\`\${T}[\${this.memberExpressionPropertyMarkup(h)}]\`), h && i.push(\`[\${this.memberExpressionPropertyMarkup(v)}]\`);
                break;
              default:
                throw new Error(\`unhandled member expression "\${S}"\`);
            }
            return i;
          }
          astCallExpression(t, i) {
            if (!t.callee)
              throw this.astErrorOutput("Unknown CallExpression", t);
            let u = null, x2 = this.isAstMathFunction(t);
            if (x2 || t.callee.object && t.callee.object.type === "ThisExpression" ? u = t.callee.property.name : t.callee.type === "SequenceExpression" && t.callee.expressions[0].type === "Literal" && !isNaN(t.callee.expressions[0].raw) ? u = t.callee.expressions[1].property.name : u = t.callee.name, !u)
              throw this.astErrorOutput("Unhandled function, couldn't find name", t);
            switch (u) {
              case "pow":
                u = "_pow";
                break;
              case "round":
                u = "_round";
                break;
            }
            if (this.calledFunctions.indexOf(u) < 0 && this.calledFunctions.push(u), u === "random" && this.plugins && this.plugins.length > 0)
              for (let w = 0; w < this.plugins.length; w++) {
                let m = this.plugins[w];
                if (m.functionMatch === "Math.random()" && m.functionReplace)
                  return i.push(m.functionReplace), i;
              }
            if (this.onFunctionCall && this.onFunctionCall(this.name, u, t.arguments), i.push(u), i.push("("), x2)
              for (let w = 0; w < t.arguments.length; ++w) {
                let m = t.arguments[w], S = this.getType(m);
                switch (w > 0 && i.push(", "), S) {
                  case "Integer":
                    this.castValueToFloat(m, i);
                    break;
                  default:
                    this.astGeneric(m, i);
                    break;
                }
              }
            else {
              let w = this.lookupFunctionArgumentTypes(u) || [];
              for (let m = 0; m < t.arguments.length; ++m) {
                let S = t.arguments[m], v = w[m];
                m > 0 && i.push(", ");
                let h = this.getType(S);
                switch (v || (this.triggerImplyArgumentType(u, m, h, this), v = h), h) {
                  case "Boolean":
                    this.astGeneric(S, i);
                    continue;
                  case "Number":
                  case "Float":
                    if (v === "Integer") {
                      i.push("int("), this.astGeneric(S, i), i.push(")");
                      continue;
                    } else if (v === "Number" || v === "Float") {
                      this.astGeneric(S, i);
                      continue;
                    } else if (v === "LiteralInteger") {
                      this.castLiteralToFloat(S, i);
                      continue;
                    }
                    break;
                  case "Integer":
                    if (v === "Number" || v === "Float") {
                      i.push("float("), this.astGeneric(S, i), i.push(")");
                      continue;
                    } else if (v === "Integer") {
                      this.astGeneric(S, i);
                      continue;
                    }
                    break;
                  case "LiteralInteger":
                    if (v === "Integer") {
                      this.castLiteralToInteger(S, i);
                      continue;
                    } else if (v === "Number" || v === "Float") {
                      this.castLiteralToFloat(S, i);
                      continue;
                    } else if (v === "LiteralInteger") {
                      this.astGeneric(S, i);
                      continue;
                    }
                    break;
                  case "Array(2)":
                  case "Array(3)":
                  case "Array(4)":
                    if (v === h) {
                      if (S.type === "Identifier")
                        i.push(\`user_\${p.sanitizeName(S.name)}\`);
                      else if (S.type === "ArrayExpression" || S.type === "MemberExpression" || S.type === "CallExpression")
                        this.astGeneric(S, i);
                      else
                        throw this.astErrorOutput(\`Unhandled argument type \${S.type}\`, t);
                      continue;
                    }
                    break;
                  case "HTMLCanvas":
                  case "HTMLImage":
                  case "HTMLImageArray":
                  case "HTMLVideo":
                  case "ArrayTexture(1)":
                  case "ArrayTexture(2)":
                  case "ArrayTexture(3)":
                  case "ArrayTexture(4)":
                  case "Array":
                  case "Input":
                    if (v === h) {
                      if (S.type !== "Identifier")
                        throw this.astErrorOutput(\`Unhandled argument type \${S.type}\`, t);
                      this.triggerImplyArgumentBitRatio(this.name, S.name, u, m);
                      let b = p.sanitizeName(S.name);
                      i.push(\`user_\${b},user_\${b}Size,user_\${b}Dim\`);
                      continue;
                    }
                    break;
                }
                throw this.astErrorOutput(\`Unhandled argument combination of \${h} and \${v} for argument named "\${S.name}"\`, t);
              }
            }
            return i.push(")"), i;
          }
          astArrayExpression(t, i) {
            let u = this.getType(t), x2 = t.elements.length;
            switch (u) {
              case "Matrix(2)":
              case "Matrix(3)":
              case "Matrix(4)":
                i.push(\`mat\${x2}(\`);
                break;
              default:
                i.push(\`vec\${x2}(\`);
            }
            for (let w = 0; w < x2; ++w) {
              w > 0 && i.push(", ");
              let m = t.elements[w];
              this.astGeneric(m, i);
            }
            return i.push(")"), i;
          }
          memberExpressionXYZ(t, i, u, x2) {
            return u ? x2.push(this.memberExpressionPropertyMarkup(u), ", ") : x2.push("0, "), i ? x2.push(this.memberExpressionPropertyMarkup(i), ", ") : x2.push("0, "), x2.push(this.memberExpressionPropertyMarkup(t)), x2;
          }
          memberExpressionPropertyMarkup(t) {
            if (!t)
              throw new Error("Property not set");
            let i = this.getType(t), u = [];
            switch (i) {
              case "Number":
              case "Float":
                this.castValueToInteger(t, u);
                break;
              case "LiteralInteger":
                this.castLiteralToInteger(t, u);
                break;
              default:
                this.astGeneric(t, u);
            }
            return u.join("");
          }
        }
        let l = { Array: "sampler2D", "Array(2)": "vec2", "Array(3)": "vec3", "Array(4)": "vec4", "Matrix(2)": "mat2", "Matrix(3)": "mat3", "Matrix(4)": "mat4", Array2D: "sampler2D", Array3D: "sampler2D", Boolean: "bool", Float: "float", Input: "sampler2D", Integer: "int", Number: "float", LiteralInteger: "float", NumberTexture: "sampler2D", MemoryOptimizedNumberTexture: "sampler2D", "ArrayTexture(1)": "sampler2D", "ArrayTexture(2)": "sampler2D", "ArrayTexture(3)": "sampler2D", "ArrayTexture(4)": "sampler2D", HTMLVideo: "sampler2D", HTMLCanvas: "sampler2D", HTMLImage: "sampler2D", HTMLImageArray: "sampler2DArray" }, n = { "===": "==", "!==": "!=" };
        y.exports = { WebGLFunctionNode: f };
      }, { "../../utils": 114, "../function-node": 10 }], 39: [function(o, y, E) {
        let { WebGLKernelValueBoolean: p } = o("./kernel-value/boolean"), { WebGLKernelValueFloat: g } = o("./kernel-value/float"), { WebGLKernelValueInteger: f } = o("./kernel-value/integer"), { WebGLKernelValueHTMLImage: l } = o("./kernel-value/html-image"), { WebGLKernelValueDynamicHTMLImage: n } = o("./kernel-value/dynamic-html-image"), { WebGLKernelValueHTMLVideo: s } = o("./kernel-value/html-video"), { WebGLKernelValueDynamicHTMLVideo: t } = o("./kernel-value/dynamic-html-video"), { WebGLKernelValueSingleInput: i } = o("./kernel-value/single-input"), { WebGLKernelValueDynamicSingleInput: u } = o("./kernel-value/dynamic-single-input"), { WebGLKernelValueUnsignedInput: x2 } = o("./kernel-value/unsigned-input"), { WebGLKernelValueDynamicUnsignedInput: w } = o("./kernel-value/dynamic-unsigned-input"), { WebGLKernelValueMemoryOptimizedNumberTexture: m } = o("./kernel-value/memory-optimized-number-texture"), { WebGLKernelValueDynamicMemoryOptimizedNumberTexture: S } = o("./kernel-value/dynamic-memory-optimized-number-texture"), { WebGLKernelValueNumberTexture: v } = o("./kernel-value/number-texture"), { WebGLKernelValueDynamicNumberTexture: h } = o("./kernel-value/dynamic-number-texture"), { WebGLKernelValueSingleArray: b } = o("./kernel-value/single-array"), { WebGLKernelValueDynamicSingleArray: T } = o("./kernel-value/dynamic-single-array"), { WebGLKernelValueSingleArray1DI: C } = o("./kernel-value/single-array1d-i"), { WebGLKernelValueDynamicSingleArray1DI: V } = o("./kernel-value/dynamic-single-array1d-i"), { WebGLKernelValueSingleArray2DI: c } = o("./kernel-value/single-array2d-i"), { WebGLKernelValueDynamicSingleArray2DI: a } = o("./kernel-value/dynamic-single-array2d-i"), { WebGLKernelValueSingleArray3DI: k } = o("./kernel-value/single-array3d-i"), { WebGLKernelValueDynamicSingleArray3DI: A } = o("./kernel-value/dynamic-single-array3d-i"), { WebGLKernelValueSingleArray2: N } = o("./kernel-value/single-array2"), { WebGLKernelValueSingleArray3: F } = o("./kernel-value/single-array3"), { WebGLKernelValueSingleArray4: L } = o("./kernel-value/single-array4"), { WebGLKernelValueUnsignedArray: K } = o("./kernel-value/unsigned-array"), { WebGLKernelValueDynamicUnsignedArray: O } = o("./kernel-value/dynamic-unsigned-array"), X = { unsigned: { dynamic: { Boolean: p, Integer: f, Float: g, Array: O, "Array(2)": false, "Array(3)": false, "Array(4)": false, "Array1D(2)": false, "Array1D(3)": false, "Array1D(4)": false, "Array2D(2)": false, "Array2D(3)": false, "Array2D(4)": false, "Array3D(2)": false, "Array3D(3)": false, "Array3D(4)": false, Input: w, NumberTexture: h, "ArrayTexture(1)": h, "ArrayTexture(2)": h, "ArrayTexture(3)": h, "ArrayTexture(4)": h, MemoryOptimizedNumberTexture: S, HTMLCanvas: n, HTMLImage: n, HTMLImageArray: false, HTMLVideo: t }, static: { Boolean: p, Float: g, Integer: f, Array: K, "Array(2)": false, "Array(3)": false, "Array(4)": false, "Array1D(2)": false, "Array1D(3)": false, "Array1D(4)": false, "Array2D(2)": false, "Array2D(3)": false, "Array2D(4)": false, "Array3D(2)": false, "Array3D(3)": false, "Array3D(4)": false, Input: x2, NumberTexture: v, "ArrayTexture(1)": v, "ArrayTexture(2)": v, "ArrayTexture(3)": v, "ArrayTexture(4)": v, MemoryOptimizedNumberTexture: m, HTMLCanvas: l, HTMLImage: l, HTMLImageArray: false, HTMLVideo: s } }, single: { dynamic: { Boolean: p, Integer: f, Float: g, Array: T, "Array(2)": N, "Array(3)": F, "Array(4)": L, "Array1D(2)": V, "Array1D(3)": V, "Array1D(4)": V, "Array2D(2)": a, "Array2D(3)": a, "Array2D(4)": a, "Array3D(2)": A, "Array3D(3)": A, "Array3D(4)": A, Input: u, NumberTexture: h, "ArrayTexture(1)": h, "ArrayTexture(2)": h, "ArrayTexture(3)": h, "ArrayTexture(4)": h, MemoryOptimizedNumberTexture: S, HTMLCanvas: n, HTMLImage: n, HTMLImageArray: false, HTMLVideo: t }, static: { Boolean: p, Float: g, Integer: f, Array: b, "Array(2)": N, "Array(3)": F, "Array(4)": L, "Array1D(2)": C, "Array1D(3)": C, "Array1D(4)": C, "Array2D(2)": c, "Array2D(3)": c, "Array2D(4)": c, "Array3D(2)": k, "Array3D(3)": k, "Array3D(4)": k, Input: i, NumberTexture: v, "ArrayTexture(1)": v, "ArrayTexture(2)": v, "ArrayTexture(3)": v, "ArrayTexture(4)": v, MemoryOptimizedNumberTexture: m, HTMLCanvas: l, HTMLImage: l, HTMLImageArray: false, HTMLVideo: s } } };
        function B(P, Y, J, q) {
          if (!P)
            throw new Error("type missing");
          if (!Y)
            throw new Error("dynamic missing");
          if (!J)
            throw new Error("precision missing");
          q.type && (P = q.type);
          let j = X[J][Y];
          if (j[P] === false)
            return null;
          if (j[P] === void 0)
            throw new Error(\`Could not find a KernelValue for \${P}\`);
          return j[P];
        }
        y.exports = { lookupKernelValueType: B, kernelValueMaps: X };
      }, { "./kernel-value/boolean": 41, "./kernel-value/dynamic-html-image": 42, "./kernel-value/dynamic-html-video": 43, "./kernel-value/dynamic-memory-optimized-number-texture": 44, "./kernel-value/dynamic-number-texture": 45, "./kernel-value/dynamic-single-array": 46, "./kernel-value/dynamic-single-array1d-i": 47, "./kernel-value/dynamic-single-array2d-i": 48, "./kernel-value/dynamic-single-array3d-i": 49, "./kernel-value/dynamic-single-input": 50, "./kernel-value/dynamic-unsigned-array": 51, "./kernel-value/dynamic-unsigned-input": 52, "./kernel-value/float": 53, "./kernel-value/html-image": 54, "./kernel-value/html-video": 55, "./kernel-value/integer": 57, "./kernel-value/memory-optimized-number-texture": 58, "./kernel-value/number-texture": 59, "./kernel-value/single-array": 60, "./kernel-value/single-array1d-i": 61, "./kernel-value/single-array2": 62, "./kernel-value/single-array2d-i": 63, "./kernel-value/single-array3": 64, "./kernel-value/single-array3d-i": 65, "./kernel-value/single-array4": 66, "./kernel-value/single-input": 67, "./kernel-value/unsigned-array": 68, "./kernel-value/unsigned-input": 69 }], 40: [function(o, y, E) {
        let { WebGLKernelValue: p } = o("./index"), { Input: g } = o("../../../input");
        class f extends p {
          checkSize(n, s) {
            if (!this.kernel.validate)
              return;
            let { maxTextureSize: t } = this.kernel.constructor.features;
            if (n > t || s > t)
              throw n > s ? new Error(\`Argument texture width of \${n} larger than maximum size of \${t} for your GPU\`) : n < s ? new Error(\`Argument texture height of \${s} larger than maximum size of \${t} for your GPU\`) : new Error(\`Argument texture height and width of \${s} larger than maximum size of \${t} for your GPU\`);
          }
          setup() {
            this.requestTexture(), this.setupTexture(), this.defineTexture();
          }
          requestTexture() {
            this.texture = this.onRequestTexture();
          }
          defineTexture() {
            let { context: n } = this;
            n.activeTexture(this.contextHandle), n.bindTexture(n.TEXTURE_2D, this.texture), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
          }
          setupTexture() {
            this.contextHandle = this.onRequestContextHandle(), this.index = this.onRequestIndex(), this.dimensionsId = this.id + "Dim", this.sizeId = this.id + "Size";
          }
          getBitRatio(n) {
            if (Array.isArray(n[0]))
              return this.getBitRatio(n[0]);
            if (n.constructor === g)
              return this.getBitRatio(n.value);
            switch (n.constructor) {
              case Uint8ClampedArray:
              case Uint8Array:
              case Int8Array:
                return 1;
              case Uint16Array:
              case Int16Array:
                return 2;
              case Float32Array:
              case Int32Array:
              default:
                return 4;
            }
          }
          destroy() {
            this.prevArg && this.prevArg.delete(), this.context.deleteTexture(this.texture);
          }
        }
        y.exports = { WebGLKernelArray: f };
      }, { "../../../input": 110, "./index": 56 }], 41: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValue: g } = o("./index");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.uploadValue = n;
          }
          getSource(n) {
            return this.origin === "constants" ? \`const bool \${this.id} = \${n};
\` : \`uniform bool \${this.id};
\`;
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          updateValue(n) {
            this.origin !== "constants" && this.kernel.setUniform1i(this.id, this.uploadValue = n);
          }
        }
        y.exports = { WebGLKernelValueBoolean: f };
      }, { "../../../utils": 114, "./index": 56 }], 42: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueHTMLImage: g } = o("./html-image");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            let { width: s, height: t } = n;
            this.checkSize(s, t), this.dimensions = [s, t, 1], this.textureSize = [s, t], this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicHTMLImage: f };
      }, { "../../../utils": 114, "./html-image": 54 }], 43: [function(o, y, E) {
        let { WebGLKernelValueDynamicHTMLImage: p } = o("./dynamic-html-image");
        class g extends p {
        }
        y.exports = { WebGLKernelValueDynamicHTMLVideo: g };
      }, { "./dynamic-html-image": 42 }], 44: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueMemoryOptimizedNumberTexture: g } = o("./memory-optimized-number-texture");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.dimensions = n.dimensions, this.checkSize(n.size[0], n.size[1]), this.textureSize = n.size, this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicMemoryOptimizedNumberTexture: f };
      }, { "../../../utils": 114, "./memory-optimized-number-texture": 58 }], 45: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueNumberTexture: g } = o("./number-texture");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.dimensions = n.dimensions, this.checkSize(n.size[0], n.size[1]), this.textureSize = n.size, this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicNumberTexture: f };
      }, { "../../../utils": 114, "./number-texture": 59 }], 46: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray: g } = o("./single-array");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.dimensions = p.getDimensions(n, true), this.textureSize = p.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicSingleArray: f };
      }, { "../../../utils": 114, "./single-array": 60 }], 47: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray1DI: g } = o("./single-array1d-i");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.setShape(n), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicSingleArray1DI: f };
      }, { "../../../utils": 114, "./single-array1d-i": 61 }], 48: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray2DI: g } = o("./single-array2d-i");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.setShape(n), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicSingleArray2DI: f };
      }, { "../../../utils": 114, "./single-array2d-i": 63 }], 49: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray3DI: g } = o("./single-array3d-i");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.setShape(n), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicSingleArray3DI: f };
      }, { "../../../utils": 114, "./single-array3d-i": 65 }], 50: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleInput: g } = o("./single-input");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            let [s, t, i] = n.size;
            this.dimensions = new Int32Array([s || 1, t || 1, i || 1]), this.textureSize = p.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicSingleInput: f };
      }, { "../../../utils": 114, "./single-input": 67 }], 51: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueUnsignedArray: g } = o("./unsigned-array");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.dimensions = p.getDimensions(n, true), this.textureSize = p.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);
            let s = this.getTransferArrayType(n);
            this.preUploadValue = new s(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicUnsignedArray: f };
      }, { "../../../utils": 114, "./unsigned-array": 68 }], 52: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueUnsignedInput: g } = o("./unsigned-input");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            let [s, t, i] = n.size;
            this.dimensions = new Int32Array([s || 1, t || 1, i || 1]), this.textureSize = p.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);
            let u = this.getTransferArrayType(n.value);
            this.preUploadValue = new u(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGLKernelValueDynamicUnsignedInput: f };
      }, { "../../../utils": 114, "./unsigned-input": 69 }], 53: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValue: g } = o("./index");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.uploadValue = n;
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          getSource(n) {
            return this.origin === "constants" ? Number.isInteger(n) ? \`const float \${this.id} = \${n}.0;
\` : \`const float \${this.id} = \${n};
\` : \`uniform float \${this.id};
\`;
          }
          updateValue(n) {
            this.origin !== "constants" && this.kernel.setUniform1f(this.id, this.uploadValue = n);
          }
        }
        y.exports = { WebGLKernelValueFloat: f };
      }, { "../../../utils": 114, "./index": 56 }], 54: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s);
            let { width: t, height: i } = n;
            this.checkSize(t, i), this.dimensions = [t, i, 1], this.textureSize = [t, i], this.uploadValue = n;
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, true), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, this.uploadValue = n), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueHTMLImage: f };
      }, { "../../../utils": 114, "./array": 40 }], 55: [function(o, y, E) {
        let { WebGLKernelValueHTMLImage: p } = o("./html-image");
        class g extends p {
        }
        y.exports = { WebGLKernelValueHTMLVideo: g };
      }, { "./html-image": 54 }], 56: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { KernelValue: g } = o("../../kernel-value");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.dimensionsId = null, this.sizeId = null, this.initialValueConstructor = n.constructor, this.onRequestTexture = s.onRequestTexture, this.onRequestIndex = s.onRequestIndex, this.uploadValue = null, this.textureSize = null, this.bitRatio = null, this.prevArg = null;
          }
          get id() {
            return \`\${this.origin}_\${p.sanitizeName(this.name)}\`;
          }
          setup() {
          }
          getTransferArrayType(n) {
            if (Array.isArray(n[0]))
              return this.getTransferArrayType(n[0]);
            switch (n.constructor) {
              case Array:
              case Int32Array:
              case Int16Array:
              case Int8Array:
                return Float32Array;
              case Uint8ClampedArray:
              case Uint8Array:
              case Uint16Array:
              case Uint32Array:
              case Float32Array:
              case Float64Array:
                return n.constructor;
            }
            return console.warn("Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros"), n.constructor;
          }
          getStringValueHandler() {
            throw new Error(\`"getStringValueHandler" not implemented on \${this.constructor.name}\`);
          }
          getVariablePrecisionString() {
            return this.kernel.getVariablePrecisionString(this.textureSize || void 0, this.tactic || void 0);
          }
          destroy() {
          }
        }
        y.exports = { WebGLKernelValue: f };
      }, { "../../../utils": 114, "../../kernel-value": 35 }], 57: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValue: g } = o("./index");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.uploadValue = n;
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          getSource(n) {
            return this.origin === "constants" ? \`const int \${this.id} = \${parseInt(n)};
\` : \`uniform int \${this.id};
\`;
          }
          updateValue(n) {
            this.origin !== "constants" && this.kernel.setUniform1i(this.id, this.uploadValue = n);
          }
        }
        y.exports = { WebGLKernelValueInteger: f };
      }, { "../../../utils": 114, "./index": 56 }], 58: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array"), f = "Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()";
        class l extends g {
          constructor(s, t) {
            super(s, t);
            let [i, u] = s.size;
            this.checkSize(i, u), this.dimensions = s.dimensions, this.textureSize = s.size, this.uploadValue = s.texture, this.forceUploadEachRun = true;
          }
          setup() {
            this.setupTexture();
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName}.texture;
\`;
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(s) {
            if (s.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(s.constructor);
              return;
            }
            if (this.checkContext && s.context !== this.context)
              throw new Error(\`Value \${this.name} (\${this.type}) must be from same context\`);
            let { kernel: t, context: i } = this;
            if (t.pipeline)
              if (t.immutable)
                t.updateTextureArgumentRefs(this, s);
              else {
                if (t.texture.texture === s.texture)
                  throw new Error(f);
                if (t.mappedTextures) {
                  let { mappedTextures: u } = t;
                  for (let x2 = 0; x2 < u.length; x2++)
                    if (u[x2].texture === s.texture)
                      throw new Error(f);
                }
              }
            i.activeTexture(this.contextHandle), i.bindTexture(i.TEXTURE_2D, this.uploadValue = s.texture), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueMemoryOptimizedNumberTexture: l, sameError: f };
      }, { "../../../utils": 114, "./array": 40 }], 59: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array"), { sameError: f } = o("./memory-optimized-number-texture");
        class l extends g {
          constructor(s, t) {
            super(s, t);
            let [i, u] = s.size;
            this.checkSize(i, u);
            let { size: x2, dimensions: w } = s;
            this.bitRatio = this.getBitRatio(s), this.dimensions = w, this.textureSize = x2, this.uploadValue = s.texture, this.forceUploadEachRun = true;
          }
          setup() {
            this.setupTexture();
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName}.texture;
\`;
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(s) {
            if (s.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(s.constructor);
              return;
            }
            if (this.checkContext && s.context !== this.context)
              throw new Error(\`Value \${this.name} (\${this.type}) must be from same context\`);
            let { kernel: t, context: i } = this;
            if (t.pipeline)
              if (t.immutable)
                t.updateTextureArgumentRefs(this, s);
              else {
                if (t.texture.texture === s.texture)
                  throw new Error(f);
                if (t.mappedTextures) {
                  let { mappedTextures: u } = t;
                  for (let x2 = 0; x2 < u.length; x2++)
                    if (u[x2].texture === s.texture)
                      throw new Error(f);
                }
              }
            i.activeTexture(this.contextHandle), i.bindTexture(i.TEXTURE_2D, this.uploadValue = s.texture), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueNumberTexture: l };
      }, { "../../../utils": 114, "./array": 40, "./memory-optimized-number-texture": 58 }], 60: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = 4, this.dimensions = p.getDimensions(n, true), this.textureSize = p.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
          }
          getStringValueHandler() {
            return p.linesToString([\`const uploadValue_\${this.name} = new Float32Array(\${this.uploadArrayLength})\`, \`flattenTo(\${this.varName}, uploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueSingleArray: f };
      }, { "../../../utils": 114, "./array": 40 }], 61: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = 4, this.setShape(n);
          }
          setShape(n) {
            let s = p.getDimensions(n, true);
            this.textureSize = p.getMemoryOptimizedFloatTextureSize(s, this.bitRatio), this.dimensions = new Int32Array([s[1], 1, 1]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
          }
          getStringValueHandler() {
            return p.linesToString([\`const uploadValue_\${this.name} = new Float32Array(\${this.uploadArrayLength})\`, \`flattenTo(\${this.varName}, uploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flatten2dArrayTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueSingleArray1DI: f };
      }, { "../../../utils": 114, "./array": 40 }], 62: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValue: g } = o("./index");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.uploadValue = n;
          }
          getSource(n) {
            return this.origin === "constants" ? \`const vec2 \${this.id} = vec2(\${n[0]},\${n[1]});
\` : \`uniform vec2 \${this.id};
\`;
          }
          getStringValueHandler() {
            return this.origin === "constants" ? "" : \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          updateValue(n) {
            this.origin !== "constants" && this.kernel.setUniform2fv(this.id, this.uploadValue = n);
          }
        }
        y.exports = { WebGLKernelValueSingleArray2: f };
      }, { "../../../utils": 114, "./index": 56 }], 63: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = 4, this.setShape(n);
          }
          setShape(n) {
            let s = p.getDimensions(n, true);
            this.textureSize = p.getMemoryOptimizedFloatTextureSize(s, this.bitRatio), this.dimensions = new Int32Array([s[1], s[2], 1]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
          }
          getStringValueHandler() {
            return p.linesToString([\`const uploadValue_\${this.name} = new Float32Array(\${this.uploadArrayLength})\`, \`flattenTo(\${this.varName}, uploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flatten3dArrayTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueSingleArray2DI: f };
      }, { "../../../utils": 114, "./array": 40 }], 64: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValue: g } = o("./index");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.uploadValue = n;
          }
          getSource(n) {
            return this.origin === "constants" ? \`const vec3 \${this.id} = vec3(\${n[0]},\${n[1]},\${n[2]});
\` : \`uniform vec3 \${this.id};
\`;
          }
          getStringValueHandler() {
            return this.origin === "constants" ? "" : \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          updateValue(n) {
            this.origin !== "constants" && this.kernel.setUniform3fv(this.id, this.uploadValue = n);
          }
        }
        y.exports = { WebGLKernelValueSingleArray3: f };
      }, { "../../../utils": 114, "./index": 56 }], 65: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = 4, this.setShape(n);
          }
          setShape(n) {
            let s = p.getDimensions(n, true);
            this.textureSize = p.getMemoryOptimizedFloatTextureSize(s, this.bitRatio), this.dimensions = new Int32Array([s[1], s[2], s[3]]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
          }
          getStringValueHandler() {
            return p.linesToString([\`const uploadValue_\${this.name} = new Float32Array(\${this.uploadArrayLength})\`, \`flattenTo(\${this.varName}, uploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flatten4dArrayTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueSingleArray3DI: f };
      }, { "../../../utils": 114, "./array": 40 }], 66: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValue: g } = o("./index");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.uploadValue = n;
          }
          getSource(n) {
            return this.origin === "constants" ? \`const vec4 \${this.id} = vec4(\${n[0]},\${n[1]},\${n[2]},\${n[3]});
\` : \`uniform vec4 \${this.id};
\`;
          }
          getStringValueHandler() {
            return this.origin === "constants" ? "" : \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          updateValue(n) {
            this.origin !== "constants" && this.kernel.setUniform4fv(this.id, this.uploadValue = n);
          }
        }
        y.exports = { WebGLKernelValueSingleArray4: f };
      }, { "../../../utils": 114, "./index": 56 }], 67: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = 4;
            let [t, i, u] = n.size;
            this.dimensions = new Int32Array([t || 1, i || 1, u || 1]), this.textureSize = p.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
          }
          getStringValueHandler() {
            return p.linesToString([\`const uploadValue_\${this.name} = new Float32Array(\${this.uploadArrayLength})\`, \`flattenTo(\${this.varName}.value, uploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n.value, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueSingleInput: f };
      }, { "../../../utils": 114, "./array": 40 }], 68: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = this.getBitRatio(n), this.dimensions = p.getDimensions(n, true), this.textureSize = p.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), this.TranserArrayType = this.getTransferArrayType(n), this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
          }
          getStringValueHandler() {
            return p.linesToString([\`const preUploadValue_\${this.name} = new \${this.TranserArrayType.name}(\${this.uploadArrayLength})\`, \`const uploadValue_\${this.name} = new Uint8Array(preUploadValue_\${this.name}.buffer)\`, \`flattenTo(\${this.varName}, preUploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n, this.preUploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.UNSIGNED_BYTE, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueUnsignedArray: f };
      }, { "../../../utils": 114, "./array": 40 }], 69: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("./array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.bitRatio = this.getBitRatio(n);
            let [t, i, u] = n.size;
            this.dimensions = new Int32Array([t || 1, i || 1, u || 1]), this.textureSize = p.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), this.TranserArrayType = this.getTransferArrayType(n.value), this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
          }
          getStringValueHandler() {
            return p.linesToString([\`const preUploadValue_\${this.name} = new \${this.TranserArrayType.name}(\${this.uploadArrayLength})\`, \`const uploadValue_\${this.name} = new Uint8Array(preUploadValue_\${this.name}.buffer)\`, \`flattenTo(\${this.varName}.value, preUploadValue_\${this.name})\`]);
          }
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(value.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n.value, this.preUploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.UNSIGNED_BYTE, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGLKernelValueUnsignedInput: f };
      }, { "../../../utils": 114, "./array": 40 }], 70: [function(o, y, E) {
        let { GLKernel: p } = o("../gl/kernel"), { FunctionBuilder: g } = o("../function-builder"), { WebGLFunctionNode: f } = o("./function-node"), { utils: l } = o("../../utils"), n = o("../../plugins/math-random-uniformly-distributed"), { fragmentShader: s } = o("./fragment-shader"), { vertexShader: t } = o("./vertex-shader"), { glKernelString: i } = o("../gl/kernel-string"), { lookupKernelValueType: u } = o("./kernel-value-maps"), x2 = null, w = null, m = null, S = null, v = null, h = [n], b = [], T = {};
        class C extends p {
          static get isSupported() {
            return x2 !== null || (this.setupFeatureChecks(), x2 = this.isContextMatch(m)), x2;
          }
          static setupFeatureChecks() {
            typeof document < "u" ? w = document.createElement("canvas") : typeof OffscreenCanvas < "u" && (w = new OffscreenCanvas(0, 0)), w && (m = w.getContext("webgl") || w.getContext("experimental-webgl"), !(!m || !m.getExtension) && (S = { OES_texture_float: m.getExtension("OES_texture_float"), OES_texture_float_linear: m.getExtension("OES_texture_float_linear"), OES_element_index_uint: m.getExtension("OES_element_index_uint"), WEBGL_draw_buffers: m.getExtension("WEBGL_draw_buffers") }, v = this.getFeatures()));
          }
          static isContextMatch(c) {
            return typeof WebGLRenderingContext < "u" ? c instanceof WebGLRenderingContext : false;
          }
          static getIsTextureFloat() {
            return Boolean(S.OES_texture_float);
          }
          static getIsDrawBuffers() {
            return Boolean(S.WEBGL_draw_buffers);
          }
          static getChannelCount() {
            return S.WEBGL_draw_buffers ? m.getParameter(S.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
          }
          static getMaxTextureSize() {
            return m.getParameter(m.MAX_TEXTURE_SIZE);
          }
          static lookupKernelValueType(c, a, k, A) {
            return u(c, a, k, A);
          }
          static get testCanvas() {
            return w;
          }
          static get testContext() {
            return m;
          }
          static get features() {
            return v;
          }
          static get fragmentShader() {
            return s;
          }
          static get vertexShader() {
            return t;
          }
          constructor(c, a) {
            super(c, a), this.program = null, this.pipeline = a.pipeline, this.endianness = l.systemEndianness(), this.extensions = {}, this.argumentTextureCount = 0, this.constantTextureCount = 0, this.fragShader = null, this.vertShader = null, this.drawBuffersMap = null, this.maxTexSize = null, this.onRequestSwitchKernel = null, this.texture = null, this.mappedTextures = null, this.mergeSettings(c.settings || a), this.threadDim = null, this.framebuffer = null, this.buffer = null, this.textureCache = [], this.programUniformLocationCache = {}, this.uniform1fCache = {}, this.uniform1iCache = {}, this.uniform2fCache = {}, this.uniform2fvCache = {}, this.uniform2ivCache = {}, this.uniform3fvCache = {}, this.uniform3ivCache = {}, this.uniform4fvCache = {}, this.uniform4ivCache = {};
          }
          initCanvas() {
            if (typeof document < "u") {
              let c = document.createElement("canvas");
              return c.width = 2, c.height = 2, c;
            } else if (typeof OffscreenCanvas < "u")
              return new OffscreenCanvas(0, 0);
          }
          initContext() {
            let c = { alpha: false, depth: false, antialias: false };
            return this.canvas.getContext("webgl", c) || this.canvas.getContext("experimental-webgl", c);
          }
          initPlugins(c) {
            let a = [], { source: k } = this;
            if (typeof k == "string")
              for (let A = 0; A < h.length; A++) {
                let N = h[A];
                k.match(N.functionMatch) && a.push(N);
              }
            else if (typeof k == "object" && c.pluginNames)
              for (let A = 0; A < h.length; A++) {
                let N = h[A];
                c.pluginNames.some((L) => L === N.name) && a.push(N);
              }
            return a;
          }
          initExtensions() {
            this.extensions = { OES_texture_float: this.context.getExtension("OES_texture_float"), OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear"), OES_element_index_uint: this.context.getExtension("OES_element_index_uint"), WEBGL_draw_buffers: this.context.getExtension("WEBGL_draw_buffers"), WEBGL_color_buffer_float: this.context.getExtension("WEBGL_color_buffer_float") };
          }
          validateSettings(c) {
            if (!this.validate) {
              this.texSize = l.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, precision: this.precision }, this.output);
              return;
            }
            let { features: a } = this.constructor;
            if (this.optimizeFloatMemory === true && !a.isTextureFloat)
              throw new Error("Float textures are not supported");
            if (this.precision === "single" && !a.isFloatRead)
              throw new Error("Single precision not supported");
            if (!this.graphical && this.precision === null && a.isTextureFloat && (this.precision = a.isFloatRead ? "single" : "unsigned"), this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers)
              throw new Error("could not instantiate draw buffers extension");
            if (this.fixIntegerDivisionAccuracy === null ? this.fixIntegerDivisionAccuracy = !a.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && a.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = false), this.checkOutput(), !this.output || this.output.length === 0) {
              if (c.length !== 1)
                throw new Error("Auto output only supported for kernels with only one input");
              let k = l.getVariableType(c[0], this.strictIntegers);
              switch (k) {
                case "Array":
                  this.output = l.getDimensions(k);
                  break;
                case "NumberTexture":
                case "MemoryOptimizedNumberTexture":
                case "ArrayTexture(1)":
                case "ArrayTexture(2)":
                case "ArrayTexture(3)":
                case "ArrayTexture(4)":
                  this.output = c[0].output;
                  break;
                default:
                  throw new Error("Auto output not supported for input type: " + k);
              }
            }
            if (this.graphical) {
              if (this.output.length !== 2)
                throw new Error("Output must have 2 dimensions on graphical mode");
              this.precision === "precision" && (this.precision = "unsigned", console.warn("Cannot use graphical mode and single precision at the same time")), this.texSize = l.clone(this.output);
              return;
            } else
              this.precision === null && a.isTextureFloat && (this.precision = "single");
            this.texSize = l.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, precision: this.precision }, this.output), this.checkTextureSize();
          }
          updateMaxTexSize() {
            let { texSize: c, canvas: a } = this;
            if (this.maxTexSize === null) {
              let k = b.indexOf(a);
              k === -1 && (k = b.length, b.push(a), T[k] = [c[0], c[1]]), this.maxTexSize = T[k];
            }
            this.maxTexSize[0] < c[0] && (this.maxTexSize[0] = c[0]), this.maxTexSize[1] < c[1] && (this.maxTexSize[1] = c[1]);
          }
          setupArguments(c) {
            this.kernelArguments = [], this.argumentTextureCount = 0;
            let a = this.argumentTypes === null;
            if (a && (this.argumentTypes = []), this.argumentSizes = [], this.argumentBitRatios = [], c.length < this.argumentNames.length)
              throw new Error("not enough arguments for kernel");
            if (c.length > this.argumentNames.length)
              throw new Error("too many arguments for kernel");
            let { context: k } = this, A = 0, N = () => this.createTexture(), F = () => this.constantTextureCount + A++, L = (O) => {
              this.switchKernels({ type: "argumentMismatch", needed: O });
            }, K = () => k.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
            for (let O = 0; O < c.length; O++) {
              let X = c[O], B = this.argumentNames[O], P;
              a ? (P = l.getVariableType(X, this.strictIntegers), this.argumentTypes.push(P)) : P = this.argumentTypes[O];
              let Y = this.constructor.lookupKernelValueType(P, this.dynamicArguments ? "dynamic" : "static", this.precision, c[O]);
              if (Y === null)
                return this.requestFallback(c);
              let J = new Y(X, { name: B, type: P, tactic: this.tactic, origin: "user", context: k, checkContext: this.checkContext, kernel: this, strictIntegers: this.strictIntegers, onRequestTexture: N, onRequestIndex: F, onUpdateValueMismatch: L, onRequestContextHandle: K });
              this.kernelArguments.push(J), J.setup(), this.argumentSizes.push(J.textureSize), this.argumentBitRatios[O] = J.bitRatio;
            }
          }
          createTexture() {
            let c = this.context.createTexture();
            return this.textureCache.push(c), c;
          }
          setupConstants(c) {
            let { context: a } = this;
            this.kernelConstants = [], this.forceUploadKernelConstants = [];
            let k = this.constantTypes === null;
            k && (this.constantTypes = {}), this.constantBitRatios = {};
            let A = 0;
            for (let N in this.constants) {
              let F = this.constants[N], L;
              k ? (L = l.getVariableType(F, this.strictIntegers), this.constantTypes[N] = L) : L = this.constantTypes[N];
              let K = this.constructor.lookupKernelValueType(L, "static", this.precision, F);
              if (K === null)
                return this.requestFallback(c);
              let O = new K(F, { name: N, type: L, tactic: this.tactic, origin: "constants", context: this.context, checkContext: this.checkContext, kernel: this, strictIntegers: this.strictIntegers, onRequestTexture: () => this.createTexture(), onRequestIndex: () => A++, onRequestContextHandle: () => a.TEXTURE0 + this.constantTextureCount++ });
              this.constantBitRatios[N] = O.bitRatio, this.kernelConstants.push(O), O.setup(), O.forceUploadEachRun && this.forceUploadKernelConstants.push(O);
            }
          }
          build() {
            if (this.built || (this.initExtensions(), this.validateSettings(arguments), this.setupConstants(arguments), this.fallbackRequested) || (this.setupArguments(arguments), this.fallbackRequested))
              return;
            this.updateMaxTexSize(), this.translateSource();
            let c = this.pickRenderStrategy(arguments);
            if (c)
              return c;
            let { texSize: a, context: k, canvas: A } = this;
            k.enable(k.SCISSOR_TEST), this.pipeline && this.precision === "single" ? (k.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), A.width = this.maxTexSize[0], A.height = this.maxTexSize[1]) : (k.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), A.width = this.maxTexSize[0], A.height = this.maxTexSize[1]);
            let N = this.threadDim = Array.from(this.output);
            for (; N.length < 3; )
              N.push(1);
            let F = this.getVertexShader(arguments), L = k.createShader(k.VERTEX_SHADER);
            k.shaderSource(L, F), k.compileShader(L), this.vertShader = L;
            let K = this.getFragmentShader(arguments), O = k.createShader(k.FRAGMENT_SHADER);
            if (k.shaderSource(O, K), k.compileShader(O), this.fragShader = O, this.debug && (console.log("GLSL Shader Output:"), console.log(K)), !k.getShaderParameter(L, k.COMPILE_STATUS))
              throw new Error("Error compiling vertex shader: " + k.getShaderInfoLog(L));
            if (!k.getShaderParameter(O, k.COMPILE_STATUS))
              throw new Error("Error compiling fragment shader: " + k.getShaderInfoLog(O));
            let X = this.program = k.createProgram();
            k.attachShader(X, L), k.attachShader(X, O), k.linkProgram(X), this.framebuffer = k.createFramebuffer(), this.framebuffer.width = a[0], this.framebuffer.height = a[1], this.rawValueFramebuffers = {};
            let B = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), P = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), Y = B.byteLength, J = this.buffer;
            J ? k.bindBuffer(k.ARRAY_BUFFER, J) : (J = this.buffer = k.createBuffer(), k.bindBuffer(k.ARRAY_BUFFER, J), k.bufferData(k.ARRAY_BUFFER, B.byteLength + P.byteLength, k.STATIC_DRAW)), k.bufferSubData(k.ARRAY_BUFFER, 0, B), k.bufferSubData(k.ARRAY_BUFFER, Y, P);
            let q = k.getAttribLocation(this.program, "aPos");
            k.enableVertexAttribArray(q), k.vertexAttribPointer(q, 2, k.FLOAT, false, 0, 0);
            let j = k.getAttribLocation(this.program, "aTexCoord");
            k.enableVertexAttribArray(j), k.vertexAttribPointer(j, 2, k.FLOAT, false, 0, Y), k.bindFramebuffer(k.FRAMEBUFFER, this.framebuffer);
            let U = 0;
            k.useProgram(this.program);
            for (let oe in this.constants)
              this.kernelConstants[U++].updateValue(this.constants[oe]);
            this._setupOutputTexture(), this.subKernels !== null && this.subKernels.length > 0 && (this._mappedTextureSwitched = {}, this._setupSubOutputTextures()), this.buildSignature(arguments), this.built = true;
          }
          translateSource() {
            let c = g.fromKernel(this, f, { fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy });
            this.translatedSource = c.getPrototypeString("kernel"), this.setupReturnTypes(c);
          }
          setupReturnTypes(c) {
            if (!this.graphical && !this.returnType && (this.returnType = c.getKernelResultType()), this.subKernels && this.subKernels.length > 0)
              for (let a = 0; a < this.subKernels.length; a++) {
                let k = this.subKernels[a];
                k.returnType || (k.returnType = c.getSubKernelResultType(a));
              }
          }
          run() {
            let { kernelArguments: c, texSize: a, forceUploadKernelConstants: k, context: A } = this;
            A.useProgram(this.program), A.scissor(0, 0, a[0], a[1]), this.dynamicOutput && (this.setUniform3iv("uOutputDim", new Int32Array(this.threadDim)), this.setUniform2iv("uTexSize", a)), this.setUniform2f("ratio", a[0] / this.maxTexSize[0], a[1] / this.maxTexSize[1]);
            for (let N = 0; N < k.length; N++) {
              let F = k[N];
              if (F.updateValue(this.constants[F.name]), this.switchingKernels)
                return;
            }
            for (let N = 0; N < c.length; N++)
              if (c[N].updateValue(arguments[N]), this.switchingKernels)
                return;
            if (this.plugins)
              for (let N = 0; N < this.plugins.length; N++) {
                let F = this.plugins[N];
                F.onBeforeRun && F.onBeforeRun(this);
              }
            if (this.graphical) {
              if (this.pipeline)
                return A.bindRenderbuffer(A.RENDERBUFFER, null), A.bindFramebuffer(A.FRAMEBUFFER, this.framebuffer), this.immutable && this._replaceOutputTexture(), A.drawArrays(A.TRIANGLE_STRIP, 0, 4), this.immutable ? this.texture.clone() : this.texture;
              A.bindRenderbuffer(A.RENDERBUFFER, null), A.bindFramebuffer(A.FRAMEBUFFER, null), A.drawArrays(A.TRIANGLE_STRIP, 0, 4);
              return;
            }
            A.bindFramebuffer(A.FRAMEBUFFER, this.framebuffer), this.immutable && this._replaceOutputTexture(), this.subKernels !== null && (this.immutable && this._replaceSubOutputTextures(), this.drawBuffers()), A.drawArrays(A.TRIANGLE_STRIP, 0, 4);
          }
          drawBuffers() {
            this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
          }
          getInternalFormat() {
            return this.context.RGBA;
          }
          getTextureFormat() {
            let { context: c } = this;
            switch (this.getInternalFormat()) {
              case c.RGBA:
                return c.RGBA;
              default:
                throw new Error("Unknown internal format");
            }
          }
          _replaceOutputTexture() {
            if (this.texture.beforeMutate() || this._textureSwitched) {
              let c = this.context;
              c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, this.texture.texture, 0), this._textureSwitched = false;
            }
          }
          _setupOutputTexture() {
            let c = this.context, a = this.texSize;
            if (this.texture) {
              c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, this.texture.texture, 0);
              return;
            }
            let k = this.createTexture();
            c.activeTexture(c.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount), c.bindTexture(c.TEXTURE_2D, k), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST);
            let A = this.getInternalFormat();
            this.precision === "single" ? c.texImage2D(c.TEXTURE_2D, 0, A, a[0], a[1], 0, c.RGBA, c.FLOAT, null) : c.texImage2D(c.TEXTURE_2D, 0, A, a[0], a[1], 0, A, c.UNSIGNED_BYTE, null), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, k, 0), this.texture = new this.TextureConstructor({ texture: k, size: a, dimensions: this.threadDim, output: this.output, context: this.context, internalFormat: this.getInternalFormat(), textureFormat: this.getTextureFormat(), kernel: this });
          }
          _replaceSubOutputTextures() {
            let c = this.context;
            for (let a = 0; a < this.mappedTextures.length; a++) {
              let k = this.mappedTextures[a];
              (k.beforeMutate() || this._mappedTextureSwitched[a]) && (c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0 + a + 1, c.TEXTURE_2D, k.texture, 0), this._mappedTextureSwitched[a] = false);
            }
          }
          _setupSubOutputTextures() {
            let c = this.context;
            if (this.mappedTextures) {
              for (let k = 0; k < this.subKernels.length; k++)
                c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0 + k + 1, c.TEXTURE_2D, this.mappedTextures[k].texture, 0);
              return;
            }
            let a = this.texSize;
            this.drawBuffersMap = [c.COLOR_ATTACHMENT0], this.mappedTextures = [];
            for (let k = 0; k < this.subKernels.length; k++) {
              let A = this.createTexture();
              this.drawBuffersMap.push(c.COLOR_ATTACHMENT0 + k + 1), c.activeTexture(c.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + k), c.bindTexture(c.TEXTURE_2D, A), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), this.precision === "single" ? c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a[0], a[1], 0, c.RGBA, c.FLOAT, null) : c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a[0], a[1], 0, c.RGBA, c.UNSIGNED_BYTE, null), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0 + k + 1, c.TEXTURE_2D, A, 0), this.mappedTextures.push(new this.TextureConstructor({ texture: A, size: a, dimensions: this.threadDim, output: this.output, context: this.context, internalFormat: this.getInternalFormat(), textureFormat: this.getTextureFormat(), kernel: this }));
            }
          }
          setUniform1f(c, a) {
            if (this.uniform1fCache.hasOwnProperty(c)) {
              let A = this.uniform1fCache[c];
              if (a === A)
                return;
            }
            this.uniform1fCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform1f(k, a);
          }
          setUniform1i(c, a) {
            if (this.uniform1iCache.hasOwnProperty(c)) {
              let A = this.uniform1iCache[c];
              if (a === A)
                return;
            }
            this.uniform1iCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform1i(k, a);
          }
          setUniform2f(c, a, k) {
            if (this.uniform2fCache.hasOwnProperty(c)) {
              let N = this.uniform2fCache[c];
              if (a === N[0] && k === N[1])
                return;
            }
            this.uniform2fCache[c] = [a, k];
            let A = this.getUniformLocation(c);
            this.context.uniform2f(A, a, k);
          }
          setUniform2fv(c, a) {
            if (this.uniform2fvCache.hasOwnProperty(c)) {
              let A = this.uniform2fvCache[c];
              if (a[0] === A[0] && a[1] === A[1])
                return;
            }
            this.uniform2fvCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform2fv(k, a);
          }
          setUniform2iv(c, a) {
            if (this.uniform2ivCache.hasOwnProperty(c)) {
              let A = this.uniform2ivCache[c];
              if (a[0] === A[0] && a[1] === A[1])
                return;
            }
            this.uniform2ivCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform2iv(k, a);
          }
          setUniform3fv(c, a) {
            if (this.uniform3fvCache.hasOwnProperty(c)) {
              let A = this.uniform3fvCache[c];
              if (a[0] === A[0] && a[1] === A[1] && a[2] === A[2])
                return;
            }
            this.uniform3fvCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform3fv(k, a);
          }
          setUniform3iv(c, a) {
            if (this.uniform3ivCache.hasOwnProperty(c)) {
              let A = this.uniform3ivCache[c];
              if (a[0] === A[0] && a[1] === A[1] && a[2] === A[2])
                return;
            }
            this.uniform3ivCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform3iv(k, a);
          }
          setUniform4fv(c, a) {
            if (this.uniform4fvCache.hasOwnProperty(c)) {
              let A = this.uniform4fvCache[c];
              if (a[0] === A[0] && a[1] === A[1] && a[2] === A[2] && a[3] === A[3])
                return;
            }
            this.uniform4fvCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform4fv(k, a);
          }
          setUniform4iv(c, a) {
            if (this.uniform4ivCache.hasOwnProperty(c)) {
              let A = this.uniform4ivCache[c];
              if (a[0] === A[0] && a[1] === A[1] && a[2] === A[2] && a[3] === A[3])
                return;
            }
            this.uniform4ivCache[c] = a;
            let k = this.getUniformLocation(c);
            this.context.uniform4iv(k, a);
          }
          getUniformLocation(c) {
            return this.programUniformLocationCache.hasOwnProperty(c) ? this.programUniformLocationCache[c] : this.programUniformLocationCache[c] = this.context.getUniformLocation(this.program, c);
          }
          _getFragShaderArtifactMap(c) {
            return { HEADER: this._getHeaderString(), LOOP_MAX: this._getLoopMaxString(), PLUGINS: this._getPluginsString(), CONSTANTS: this._getConstantsString(), DECODE32_ENDIANNESS: this._getDecode32EndiannessString(), ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(), DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(), INJECTED_NATIVE: this._getInjectedNative(), MAIN_CONSTANTS: this._getMainConstantsString(), MAIN_ARGUMENTS: this._getMainArgumentsString(c), KERNEL: this.getKernelString(), MAIN_RESULT: this.getMainResultString(), FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(), INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(), SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(), SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration() };
          }
          _getVertShaderArtifactMap(c) {
            return { FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(), INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(), SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(), SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration() };
          }
          _getHeaderString() {
            return this.subKernels !== null ? \`#extension GL_EXT_draw_buffers : require
\` : "";
          }
          _getLoopMaxString() {
            return this.loopMaxIterations ? \` \${parseInt(this.loopMaxIterations)};
\` : \` 1000;
\`;
          }
          _getPluginsString() {
            return this.plugins ? this.plugins.map((c) => c.source && this.source.match(c.functionMatch) ? c.source : "").join(\`
\`) : \`
\`;
          }
          _getConstantsString() {
            let c = [], { threadDim: a, texSize: k } = this;
            return this.dynamicOutput ? c.push("uniform ivec3 uOutputDim", "uniform ivec2 uTexSize") : c.push(\`ivec3 uOutputDim = ivec3(\${a[0]}, \${a[1]}, \${a[2]})\`, \`ivec2 uTexSize = ivec2(\${k[0]}, \${k[1]})\`), l.linesToString(c);
          }
          _getTextureCoordinate() {
            let c = this.subKernels;
            return c === null || c.length < 1 ? \`varying vec2 vTexCoord;
\` : \`out vec2 vTexCoord;
\`;
          }
          _getDecode32EndiannessString() {
            return this.endianness === "LE" ? "" : \`  texel.rgba = texel.abgr;
\`;
          }
          _getEncode32EndiannessString() {
            return this.endianness === "LE" ? "" : \`  texel.rgba = texel.abgr;
\`;
          }
          _getDivideWithIntegerCheckString() {
            return this.fixIntegerDivisionAccuracy ? \`float divWithIntCheck(float x, float y) {
        if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
          return float(int(x) / int(y));
        }
        return x / y;
      }
      
      float integerCorrectionModulo(float number, float divisor) {
        if (number < 0.0) {
          number = abs(number);
          if (divisor < 0.0) {
            divisor = abs(divisor);
          }
          return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
        }
        if (divisor < 0.0) {
          divisor = abs(divisor);
        }
        return number - (divisor * floor(divWithIntCheck(number, divisor)));
      }\` : "";
          }
          _getMainArgumentsString(c) {
            let a = [], { argumentNames: k } = this;
            for (let A = 0; A < k.length; A++)
              a.push(this.kernelArguments[A].getSource(c[A]));
            return a.join("");
          }
          _getInjectedNative() {
            return this.injectedNative || "";
          }
          _getMainConstantsString() {
            let c = [], { constants: a } = this;
            if (a) {
              let k = 0;
              for (let A in a)
                !this.constants.hasOwnProperty(A) || c.push(this.kernelConstants[k++].getSource(this.constants[A]));
            }
            return c.join("");
          }
          getRawValueFramebuffer(c, a) {
            if (this.rawValueFramebuffers[c] || (this.rawValueFramebuffers[c] = {}), !this.rawValueFramebuffers[c][a]) {
              let k = this.context.createFramebuffer();
              k.width = c, k.height = a, this.rawValueFramebuffers[c][a] = k;
            }
            return this.rawValueFramebuffers[c][a];
          }
          getKernelResultDeclaration() {
            switch (this.returnType) {
              case "Array(2)":
                return "vec2 kernelResult";
              case "Array(3)":
                return "vec3 kernelResult";
              case "Array(4)":
                return "vec4 kernelResult";
              case "LiteralInteger":
              case "Float":
              case "Number":
              case "Integer":
                return "float kernelResult";
              default:
                if (this.graphical)
                  return "float kernelResult";
                throw new Error(\`unrecognized output type "\${this.returnType}"\`);
            }
          }
          getKernelString() {
            let c = [this.getKernelResultDeclaration()], { subKernels: a } = this;
            if (a !== null)
              switch (this.returnType) {
                case "Number":
                case "Float":
                case "Integer":
                  for (let k = 0; k < a.length; k++) {
                    let A = a[k];
                    c.push(A.returnType === "Integer" ? \`int subKernelResult_\${A.name} = 0\` : \`float subKernelResult_\${A.name} = 0.0\`);
                  }
                  break;
                case "Array(2)":
                  for (let k = 0; k < a.length; k++)
                    c.push(\`vec2 subKernelResult_\${a[k].name}\`);
                  break;
                case "Array(3)":
                  for (let k = 0; k < a.length; k++)
                    c.push(\`vec3 subKernelResult_\${a[k].name}\`);
                  break;
                case "Array(4)":
                  for (let k = 0; k < a.length; k++)
                    c.push(\`vec4 subKernelResult_\${a[k].name}\`);
                  break;
              }
            return l.linesToString(c) + this.translatedSource;
          }
          getMainResultGraphical() {
            return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragColor = actualColor"]);
          }
          getMainResultPackedPixels() {
            switch (this.returnType) {
              case "LiteralInteger":
              case "Number":
              case "Integer":
              case "Float":
                return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();
              default:
                throw new Error(\`packed output only usable with Numbers, "\${this.returnType}" specified\`);
            }
          }
          getMainResultKernelPackedPixels() {
            return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", \`  gl_FragData[0] = \${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(kernelResult)\`]);
          }
          getMainResultSubKernelPackedPixels() {
            let c = [];
            if (!this.subKernels)
              return "";
            for (let a = 0; a < this.subKernels.length; a++)
              this.subKernels[a].returnType === "Integer" ? c.push(\`  gl_FragData[\${a + 1}] = \${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(float(subKernelResult_\${this.subKernels[a].name}))\`) : c.push(\`  gl_FragData[\${a + 1}] = \${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(subKernelResult_\${this.subKernels[a].name})\`);
            return l.linesToString(c);
          }
          getMainResultMemoryOptimizedFloats() {
            let c = ["  index *= 4"];
            switch (this.returnType) {
              case "Number":
              case "Integer":
              case "Float":
                let a = ["r", "g", "b", "a"];
                for (let k = 0; k < a.length; k++) {
                  let A = a[k];
                  this.getMainResultKernelMemoryOptimizedFloats(c, A), this.getMainResultSubKernelMemoryOptimizedFloats(c, A), k + 1 < a.length && c.push("  index += 1");
                }
                break;
              default:
                throw new Error(\`optimized output only usable with Numbers, \${this.returnType} specified\`);
            }
            return l.linesToString(c);
          }
          getMainResultKernelMemoryOptimizedFloats(c, a) {
            c.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", \`  gl_FragData[0].\${a} = kernelResult\`);
          }
          getMainResultSubKernelMemoryOptimizedFloats(c, a) {
            if (!this.subKernels)
              return c;
            for (let k = 0; k < this.subKernels.length; k++)
              this.subKernels[k].returnType === "Integer" ? c.push(\`  gl_FragData[\${k + 1}].\${a} = float(subKernelResult_\${this.subKernels[k].name})\`) : c.push(\`  gl_FragData[\${k + 1}].\${a} = subKernelResult_\${this.subKernels[k].name}\`);
          }
          getMainResultKernelNumberTexture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0][0] = kernelResult"];
          }
          getMainResultSubKernelNumberTexture() {
            let c = [];
            if (!this.subKernels)
              return c;
            for (let a = 0; a < this.subKernels.length; ++a) {
              let k = this.subKernels[a];
              k.returnType === "Integer" ? c.push(\`  gl_FragData[\${a + 1}][0] = float(subKernelResult_\${k.name})\`) : c.push(\`  gl_FragData[\${a + 1}][0] = subKernelResult_\${k.name}\`);
            }
            return c;
          }
          getMainResultKernelArray2Texture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0][0] = kernelResult[0]", "  gl_FragData[0][1] = kernelResult[1]"];
          }
          getMainResultSubKernelArray2Texture() {
            let c = [];
            if (!this.subKernels)
              return c;
            for (let a = 0; a < this.subKernels.length; ++a)
              c.push(\`  gl_FragData[\${a + 1}][0] = subKernelResult_\${this.subKernels[a].name}[0]\`, \`  gl_FragData[\${a + 1}][1] = subKernelResult_\${this.subKernels[a].name}[1]\`);
            return c;
          }
          getMainResultKernelArray3Texture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0][0] = kernelResult[0]", "  gl_FragData[0][1] = kernelResult[1]", "  gl_FragData[0][2] = kernelResult[2]"];
          }
          getMainResultSubKernelArray3Texture() {
            let c = [];
            if (!this.subKernels)
              return c;
            for (let a = 0; a < this.subKernels.length; ++a)
              c.push(\`  gl_FragData[\${a + 1}][0] = subKernelResult_\${this.subKernels[a].name}[0]\`, \`  gl_FragData[\${a + 1}][1] = subKernelResult_\${this.subKernels[a].name}[1]\`, \`  gl_FragData[\${a + 1}][2] = subKernelResult_\${this.subKernels[a].name}[2]\`);
            return c;
          }
          getMainResultKernelArray4Texture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0] = kernelResult"];
          }
          getMainResultSubKernelArray4Texture() {
            let c = [];
            if (!this.subKernels)
              return c;
            switch (this.returnType) {
              case "Number":
              case "Float":
              case "Integer":
                for (let a = 0; a < this.subKernels.length; ++a)
                  this.subKernels[a].returnType === "Integer" ? c.push(\`  gl_FragData[\${a + 1}] = float(subKernelResult_\${this.subKernels[a].name})\`) : c.push(\`  gl_FragData[\${a + 1}] = subKernelResult_\${this.subKernels[a].name}\`);
                break;
              case "Array(2)":
                for (let a = 0; a < this.subKernels.length; ++a)
                  c.push(\`  gl_FragData[\${a + 1}][0] = subKernelResult_\${this.subKernels[a].name}[0]\`, \`  gl_FragData[\${a + 1}][1] = subKernelResult_\${this.subKernels[a].name}[1]\`);
                break;
              case "Array(3)":
                for (let a = 0; a < this.subKernels.length; ++a)
                  c.push(\`  gl_FragData[\${a + 1}][0] = subKernelResult_\${this.subKernels[a].name}[0]\`, \`  gl_FragData[\${a + 1}][1] = subKernelResult_\${this.subKernels[a].name}[1]\`, \`  gl_FragData[\${a + 1}][2] = subKernelResult_\${this.subKernels[a].name}[2]\`);
                break;
              case "Array(4)":
                for (let a = 0; a < this.subKernels.length; ++a)
                  c.push(\`  gl_FragData[\${a + 1}][0] = subKernelResult_\${this.subKernels[a].name}[0]\`, \`  gl_FragData[\${a + 1}][1] = subKernelResult_\${this.subKernels[a].name}[1]\`, \`  gl_FragData[\${a + 1}][2] = subKernelResult_\${this.subKernels[a].name}[2]\`, \`  gl_FragData[\${a + 1}][3] = subKernelResult_\${this.subKernels[a].name}[3]\`);
                break;
            }
            return c;
          }
          replaceArtifacts(c, a) {
            return c.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\\n/g, (k, A) => {
              if (a.hasOwnProperty(A))
                return a[A];
              throw \`unhandled artifact \${A}\`;
            });
          }
          getFragmentShader(c) {
            return this.compiledFragmentShader !== null ? this.compiledFragmentShader : this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(c));
          }
          getVertexShader(c) {
            return this.compiledVertexShader !== null ? this.compiledVertexShader : this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(c));
          }
          toString() {
            let c = l.linesToString(["const gl = context"]);
            return i(this.constructor, arguments, this, c);
          }
          destroy(c) {
            if (!this.context)
              return;
            this.buffer && this.context.deleteBuffer(this.buffer), this.framebuffer && this.context.deleteFramebuffer(this.framebuffer);
            for (let k in this.rawValueFramebuffers) {
              for (let A in this.rawValueFramebuffers[k])
                this.context.deleteFramebuffer(this.rawValueFramebuffers[k][A]), delete this.rawValueFramebuffers[k][A];
              delete this.rawValueFramebuffers[k];
            }
            if (this.vertShader && this.context.deleteShader(this.vertShader), this.fragShader && this.context.deleteShader(this.fragShader), this.program && this.context.deleteProgram(this.program), this.texture) {
              this.texture.delete();
              let k = this.textureCache.indexOf(this.texture.texture);
              k > -1 && this.textureCache.splice(k, 1), this.texture = null;
            }
            if (this.mappedTextures && this.mappedTextures.length) {
              for (let k = 0; k < this.mappedTextures.length; k++) {
                let A = this.mappedTextures[k];
                A.delete();
                let N = this.textureCache.indexOf(A.texture);
                N > -1 && this.textureCache.splice(N, 1);
              }
              this.mappedTextures = null;
            }
            if (this.kernelArguments)
              for (let k = 0; k < this.kernelArguments.length; k++)
                this.kernelArguments[k].destroy();
            if (this.kernelConstants)
              for (let k = 0; k < this.kernelConstants.length; k++)
                this.kernelConstants[k].destroy();
            for (; this.textureCache.length > 0; ) {
              let k = this.textureCache.pop();
              this.context.deleteTexture(k);
            }
            if (c) {
              let k = b.indexOf(this.canvas);
              k >= 0 && (b[k] = null, T[k] = null);
            }
            if (this.destroyExtensions(), delete this.context, delete this.canvas, !this.gpu)
              return;
            let a = this.gpu.kernels.indexOf(this);
            a !== -1 && this.gpu.kernels.splice(a, 1);
          }
          destroyExtensions() {
            this.extensions.OES_texture_float = null, this.extensions.OES_texture_float_linear = null, this.extensions.OES_element_index_uint = null, this.extensions.WEBGL_draw_buffers = null;
          }
          static destroyContext(c) {
            let a = c.getExtension("WEBGL_lose_context");
            a && a.loseContext();
          }
          toJSON() {
            let c = super.toJSON();
            return c.functionNodes = g.fromKernel(this, f).toJSON(), c.settings.threadDim = this.threadDim, c;
          }
        }
        y.exports = { WebGLKernel: C };
      }, { "../../plugins/math-random-uniformly-distributed": 112, "../../utils": 114, "../function-builder": 9, "../gl/kernel": 13, "../gl/kernel-string": 12, "./fragment-shader": 37, "./function-node": 38, "./kernel-value-maps": 39, "./vertex-shader": 71 }], 71: [function(o, y, E) {
        let p = \`__FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      
      attribute vec2 aPos;
      attribute vec2 aTexCoord;
      
      varying vec2 vTexCoord;
      uniform vec2 ratio;
      
      void main(void) {
        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
        vTexCoord = aTexCoord;
      }\`;
        y.exports = { vertexShader: p };
      }, {}], 72: [function(o, y, E) {
        let p = \`#version 300 es
      __HEADER__;
      __FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      __SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;
      
      const int LOOP_MAX = __LOOP_MAX__;
      
      __PLUGINS__;
      __CONSTANTS__;
      
      in vec2 vTexCoord;
      
      float atan2(float v1, float v2) {
        if (v1 == 0.0 || v2 == 0.0) return 0.0;
        return atan(v1 / v2);
      }
      
      float cbrt(float x) {
        if (x >= 0.0) {
          return pow(x, 1.0 / 3.0);
        } else {
          return -pow(x, 1.0 / 3.0);
        }
      }
      
      float expm1(float x) {
        return pow(\${Math.E}, x) - 1.0; 
      }
      
      float fround(highp float x) {
        return x;
      }
      
      float imul(float v1, float v2) {
        return float(int(v1) * int(v2));
      }
      
      float log10(float x) {
        return log2(x) * (1.0 / log2(10.0));
      }
      
      float log1p(float x) {
        return log(1.0 + x);
      }
      
      float _pow(float v1, float v2) {
        if (v2 == 0.0) return 1.0;
        return pow(v1, v2);
      }
      
      float _round(float x) {
        return floor(x + 0.5);
      }
      
      
      const int BIT_COUNT = 32;
      int modi(int x, int y) {
        return x - y * (x / y);
      }
      
      int bitwiseOr(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseXOR(int a, int b) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 || b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseAnd(int a, int b) {
        int result = 0;
        int n = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
            result += n;
          }
          a = a / 2;
          b = b / 2;
          n = n * 2;
          if(!(a > 0 && b > 0)) {
            break;
          }
        }
        return result;
      }
      int bitwiseNot(int a) {
        int result = 0;
        int n = 1;
        
        for (int i = 0; i < BIT_COUNT; i++) {
          if (modi(a, 2) == 0) {
            result += n;    
          }
          a = a / 2;
          n = n * 2;
        }
        return result;
      }
      int bitwiseZeroFillLeftShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n *= 2;
        }
      
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      int bitwiseSignedRightShift(int num, int shifts) {
        return int(floor(float(num) / pow(2.0, float(shifts))));
      }
      
      int bitwiseZeroFillRightShift(int n, int shift) {
        int maxBytes = BIT_COUNT;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (maxBytes >= n) {
            break;
          }
          maxBytes *= 2;
        }
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= shift) {
            break;
          }
          n /= 2;
        }
        int result = 0;
        int byteVal = 1;
        for (int i = 0; i < BIT_COUNT; i++) {
          if (i >= maxBytes) break;
          if (modi(n, 2) > 0) { result += byteVal; }
          n = int(n / 2);
          byteVal *= 2;
        }
        return result;
      }
      
      vec2 integerMod(vec2 x, float y) {
        vec2 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec3 integerMod(vec3 x, float y) {
        vec3 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      vec4 integerMod(vec4 x, vec4 y) {
        vec4 res = floor(mod(x, y));
        return res * step(1.0 - floor(y), -res);
      }
      
      float integerMod(float x, float y) {
        float res = floor(mod(x, y));
        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
      }
      
      int integerMod(int x, int y) {
        return x - (y * int(x/y));
      }
      
      __DIVIDE_WITH_INTEGER_CHECK__;
      
      // Here be dragons!
      // DO NOT OPTIMIZE THIS CODE
      // YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
      const vec2 MAGIC_VEC = vec2(1.0, -256.0);
      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
      float decode32(vec4 texel) {
        __DECODE32_ENDIANNESS__;
        texel *= 255.0;
        vec2 gte128;
        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
        float res = exp2(round(exponent));
        texel.b = texel.b - 128.0 * gte128.x;
        res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
        res *= gte128.y * -2.0 + 1.0;
        return res;
      }
      
      float decode16(vec4 texel, int index) {
        int channel = integerMod(index, 2);
        return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
      }
      
      float decode8(vec4 texel, int index) {
        int channel = integerMod(index, 4);
        return texel[channel] * 255.0;
      }
      
      vec4 legacyEncode32(float f) {
        float F = abs(f);
        float sign = f < 0.0 ? 1.0 : 0.0;
        float exponent = floor(log2(F));
        float mantissa = (exp2(-exponent) * F);
        // exponent += floor(log2(mantissa));
        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
        texel.rg = integerMod(texel.rg, 256.0);
        texel.b = integerMod(texel.b, 128.0);
        texel.a = exponent*0.5 + 63.5;
        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
        texel = floor(texel);
        texel *= 0.003921569; // 1/255
        __ENCODE32_ENDIANNESS__;
        return texel;
      }
      
      // https://github.com/gpujs/gpu.js/wiki/Encoder-details
      vec4 encode32(float value) {
        if (value == 0.0) return vec4(0, 0, 0, 0);
      
        float exponent;
        float mantissa;
        vec4  result;
        float sgn;
      
        sgn = step(0.0, -value);
        value = abs(value);
      
        exponent = floor(log2(value));
      
        mantissa = value*pow(2.0, -exponent)-1.0;
        exponent = exponent+127.0;
        result   = vec4(0,0,0,0);
      
        result.a = floor(exponent/2.0);
        exponent = exponent - result.a*2.0;
        result.a = result.a + 128.0*sgn;
      
        result.b = floor(mantissa * 128.0);
        mantissa = mantissa - result.b / 128.0;
        result.b = result.b + exponent*128.0;
      
        result.g = floor(mantissa*32768.0);
        mantissa = mantissa - result.g/32768.0;
      
        result.r = floor(mantissa*8388608.0);
        return result/255.0;
      }
      // Dragons end here
      
      int index;
      ivec3 threadId;
      
      ivec3 indexTo3D(int idx, ivec3 texDim) {
        int z = int(idx / (texDim.x * texDim.y));
        idx -= z * int(texDim.x * texDim.y);
        int y = int(idx / texDim.x);
        int x = int(integerMod(idx, texDim.x));
        return ivec3(x, y, z);
      }
      
      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize));
        return decode32(texel);
      }
      
      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int w = texSize.x * 2;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
        return decode16(texel, index);
      }
      
      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int w = texSize.x * 4;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
        return decode8(texel, index);
      }
      
      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + (texDim.x * (y + (texDim.y * z)));
        int channel = integerMod(index, 4);
        index = index / 4;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        index = index / 4;
        vec4 texel = texture(tex, st / vec2(texSize));
        return texel[channel];
      }
      
      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        return texture(tex, st / vec2(texSize));
      }
      
      vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        return texture(tex, vec3(st / vec2(texSize), z));
      }
      
      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return result[0];
      }
      
      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec2(result[0], result[1]);
      }
      
      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 2);
        index = index / 2;
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize));
        if (channel == 0) return vec2(texel.r, texel.g);
        if (channel == 1) return vec2(texel.b, texel.a);
        return vec2(0.0, 0.0);
      }
      
      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
        return vec3(result[0], result[1], result[2]);
      }
      
      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
        int vectorIndex = fieldIndex / 4;
        int vectorOffset = fieldIndex - vectorIndex * 4;
        int readY = vectorIndex / texSize.x;
        int readX = vectorIndex - readY * texSize.x;
        vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
      
        if (vectorOffset == 0) {
          return tex1.xyz;
        } else if (vectorOffset == 1) {
          return tex1.yzw;
        } else {
          readX++;
          if (readX >= texSize.x) {
            readX = 0;
            readY++;
          }
          vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
          if (vectorOffset == 2) {
            return vec3(tex1.z, tex1.w, tex2.x);
          } else {
            return vec3(tex1.w, tex2.x, tex2.y);
          }
        }
      }
      
      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        return getImage2D(tex, texSize, texDim, z, y, x);
      }
      
      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
        int index = x + texDim.x * (y + texDim.y * z);
        int channel = integerMod(index, 2);
        int w = texSize.x;
        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
        vec4 texel = texture(tex, st / vec2(texSize));
        return vec4(texel.r, texel.g, texel.b, texel.a);
      }
      
      vec4 actualColor;
      void color(float r, float g, float b, float a) {
        actualColor = vec4(r,g,b,a);
      }
      
      void color(float r, float g, float b) {
        color(r,g,b,1.0);
      }
      
      float modulo(float number, float divisor) {
        if (number < 0.0) {
          number = abs(number);
          if (divisor < 0.0) {
            divisor = abs(divisor);
          }
          return -mod(number, divisor);
        }
        if (divisor < 0.0) {
          divisor = abs(divisor);
        }
        return mod(number, divisor);
      }
      
      __INJECTED_NATIVE__;
      __MAIN_CONSTANTS__;
      __MAIN_ARGUMENTS__;
      __KERNEL__;
      
      void main(void) {
        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
        __MAIN_RESULT__;
      }\`;
        y.exports = { fragmentShader: p };
      }, {}], 73: [function(o, y, E) {
        let { utils: p } = o("../../utils"), { WebGLFunctionNode: g } = o("../web-gl/function-node");
        class f extends g {
          astIdentifierExpression(n, s) {
            if (n.type !== "Identifier")
              throw this.astErrorOutput("IdentifierExpression - not an Identifier", n);
            let t = this.getType(n), i = p.sanitizeName(n.name);
            return n.name === "Infinity" ? s.push("intBitsToFloat(2139095039)") : t === "Boolean" ? this.argumentNames.indexOf(i) > -1 ? s.push(\`bool(user_\${i})\`) : s.push(\`user_\${i}\`) : s.push(\`user_\${i}\`), s;
          }
        }
        y.exports = { WebGL2FunctionNode: f };
      }, { "../../utils": 114, "../web-gl/function-node": 38 }], 74: [function(o, y, E) {
        let { WebGL2KernelValueBoolean: p } = o("./kernel-value/boolean"), { WebGL2KernelValueFloat: g } = o("./kernel-value/float"), { WebGL2KernelValueInteger: f } = o("./kernel-value/integer"), { WebGL2KernelValueHTMLImage: l } = o("./kernel-value/html-image"), { WebGL2KernelValueDynamicHTMLImage: n } = o("./kernel-value/dynamic-html-image"), { WebGL2KernelValueHTMLImageArray: s } = o("./kernel-value/html-image-array"), { WebGL2KernelValueDynamicHTMLImageArray: t } = o("./kernel-value/dynamic-html-image-array"), { WebGL2KernelValueHTMLVideo: i } = o("./kernel-value/html-video"), { WebGL2KernelValueDynamicHTMLVideo: u } = o("./kernel-value/dynamic-html-video"), { WebGL2KernelValueSingleInput: x2 } = o("./kernel-value/single-input"), { WebGL2KernelValueDynamicSingleInput: w } = o("./kernel-value/dynamic-single-input"), { WebGL2KernelValueUnsignedInput: m } = o("./kernel-value/unsigned-input"), { WebGL2KernelValueDynamicUnsignedInput: S } = o("./kernel-value/dynamic-unsigned-input"), { WebGL2KernelValueMemoryOptimizedNumberTexture: v } = o("./kernel-value/memory-optimized-number-texture"), { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: h } = o("./kernel-value/dynamic-memory-optimized-number-texture"), { WebGL2KernelValueNumberTexture: b } = o("./kernel-value/number-texture"), { WebGL2KernelValueDynamicNumberTexture: T } = o("./kernel-value/dynamic-number-texture"), { WebGL2KernelValueSingleArray: C } = o("./kernel-value/single-array"), { WebGL2KernelValueDynamicSingleArray: V } = o("./kernel-value/dynamic-single-array"), { WebGL2KernelValueSingleArray1DI: c } = o("./kernel-value/single-array1d-i"), { WebGL2KernelValueDynamicSingleArray1DI: a } = o("./kernel-value/dynamic-single-array1d-i"), { WebGL2KernelValueSingleArray2DI: k } = o("./kernel-value/single-array2d-i"), { WebGL2KernelValueDynamicSingleArray2DI: A } = o("./kernel-value/dynamic-single-array2d-i"), { WebGL2KernelValueSingleArray3DI: N } = o("./kernel-value/single-array3d-i"), { WebGL2KernelValueDynamicSingleArray3DI: F } = o("./kernel-value/dynamic-single-array3d-i"), { WebGL2KernelValueSingleArray2: L } = o("./kernel-value/single-array2"), { WebGL2KernelValueSingleArray3: K } = o("./kernel-value/single-array3"), { WebGL2KernelValueSingleArray4: O } = o("./kernel-value/single-array4"), { WebGL2KernelValueUnsignedArray: X } = o("./kernel-value/unsigned-array"), { WebGL2KernelValueDynamicUnsignedArray: B } = o("./kernel-value/dynamic-unsigned-array"), P = { unsigned: { dynamic: { Boolean: p, Integer: f, Float: g, Array: B, "Array(2)": false, "Array(3)": false, "Array(4)": false, "Array1D(2)": false, "Array1D(3)": false, "Array1D(4)": false, "Array2D(2)": false, "Array2D(3)": false, "Array2D(4)": false, "Array3D(2)": false, "Array3D(3)": false, "Array3D(4)": false, Input: S, NumberTexture: T, "ArrayTexture(1)": T, "ArrayTexture(2)": T, "ArrayTexture(3)": T, "ArrayTexture(4)": T, MemoryOptimizedNumberTexture: h, HTMLCanvas: n, HTMLImage: n, HTMLImageArray: t, HTMLVideo: u }, static: { Boolean: p, Float: g, Integer: f, Array: X, "Array(2)": false, "Array(3)": false, "Array(4)": false, "Array1D(2)": false, "Array1D(3)": false, "Array1D(4)": false, "Array2D(2)": false, "Array2D(3)": false, "Array2D(4)": false, "Array3D(2)": false, "Array3D(3)": false, "Array3D(4)": false, Input: m, NumberTexture: b, "ArrayTexture(1)": b, "ArrayTexture(2)": b, "ArrayTexture(3)": b, "ArrayTexture(4)": b, MemoryOptimizedNumberTexture: h, HTMLCanvas: l, HTMLImage: l, HTMLImageArray: s, HTMLVideo: i } }, single: { dynamic: { Boolean: p, Integer: f, Float: g, Array: V, "Array(2)": L, "Array(3)": K, "Array(4)": O, "Array1D(2)": a, "Array1D(3)": a, "Array1D(4)": a, "Array2D(2)": A, "Array2D(3)": A, "Array2D(4)": A, "Array3D(2)": F, "Array3D(3)": F, "Array3D(4)": F, Input: w, NumberTexture: T, "ArrayTexture(1)": T, "ArrayTexture(2)": T, "ArrayTexture(3)": T, "ArrayTexture(4)": T, MemoryOptimizedNumberTexture: h, HTMLCanvas: n, HTMLImage: n, HTMLImageArray: t, HTMLVideo: u }, static: { Boolean: p, Float: g, Integer: f, Array: C, "Array(2)": L, "Array(3)": K, "Array(4)": O, "Array1D(2)": c, "Array1D(3)": c, "Array1D(4)": c, "Array2D(2)": k, "Array2D(3)": k, "Array2D(4)": k, "Array3D(2)": N, "Array3D(3)": N, "Array3D(4)": N, Input: x2, NumberTexture: b, "ArrayTexture(1)": b, "ArrayTexture(2)": b, "ArrayTexture(3)": b, "ArrayTexture(4)": b, MemoryOptimizedNumberTexture: v, HTMLCanvas: l, HTMLImage: l, HTMLImageArray: s, HTMLVideo: i } } };
        function Y(J, q, j, U) {
          if (!J)
            throw new Error("type missing");
          if (!q)
            throw new Error("dynamic missing");
          if (!j)
            throw new Error("precision missing");
          U.type && (J = U.type);
          let oe = P[j][q];
          if (oe[J] === false)
            return null;
          if (oe[J] === void 0)
            throw new Error(\`Could not find a KernelValue for \${J}\`);
          return oe[J];
        }
        y.exports = { kernelValueMaps: P, lookupKernelValueType: Y };
      }, { "./kernel-value/boolean": 75, "./kernel-value/dynamic-html-image": 77, "./kernel-value/dynamic-html-image-array": 76, "./kernel-value/dynamic-html-video": 78, "./kernel-value/dynamic-memory-optimized-number-texture": 79, "./kernel-value/dynamic-number-texture": 80, "./kernel-value/dynamic-single-array": 81, "./kernel-value/dynamic-single-array1d-i": 82, "./kernel-value/dynamic-single-array2d-i": 83, "./kernel-value/dynamic-single-array3d-i": 84, "./kernel-value/dynamic-single-input": 85, "./kernel-value/dynamic-unsigned-array": 86, "./kernel-value/dynamic-unsigned-input": 87, "./kernel-value/float": 88, "./kernel-value/html-image": 90, "./kernel-value/html-image-array": 89, "./kernel-value/html-video": 91, "./kernel-value/integer": 92, "./kernel-value/memory-optimized-number-texture": 93, "./kernel-value/number-texture": 94, "./kernel-value/single-array": 95, "./kernel-value/single-array1d-i": 96, "./kernel-value/single-array2": 97, "./kernel-value/single-array2d-i": 98, "./kernel-value/single-array3": 99, "./kernel-value/single-array3d-i": 100, "./kernel-value/single-array4": 101, "./kernel-value/single-input": 102, "./kernel-value/unsigned-array": 103, "./kernel-value/unsigned-input": 104 }], 75: [function(o, y, E) {
        let { WebGLKernelValueBoolean: p } = o("../../web-gl/kernel-value/boolean");
        class g extends p {
        }
        y.exports = { WebGL2KernelValueBoolean: g };
      }, { "../../web-gl/kernel-value/boolean": 41 }], 76: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueHTMLImageArray: g } = o("./html-image-array");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2DArray \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            let { width: s, height: t } = n[0];
            this.checkSize(s, t), this.dimensions = [s, t, n.length], this.textureSize = [s, t], this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGL2KernelValueDynamicHTMLImageArray: f };
      }, { "../../../utils": 114, "./html-image-array": 89 }], 77: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueDynamicHTMLImage: g } = o("../../web-gl/kernel-value/dynamic-html-image");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
        }
        y.exports = { WebGL2KernelValueDynamicHTMLImage: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/dynamic-html-image": 42 }], 78: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueDynamicHTMLImage: g } = o("./dynamic-html-image");
        class f extends g {
        }
        y.exports = { WebGL2KernelValueDynamicHTMLVideo: f };
      }, { "../../../utils": 114, "./dynamic-html-image": 77 }], 79: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueDynamicMemoryOptimizedNumberTexture: g } = o("../../web-gl/kernel-value/dynamic-memory-optimized-number-texture");
        class f extends g {
          getSource() {
            return p.linesToString([\`uniform sampler2D \${this.id}\`, \`uniform ivec2 \${this.sizeId}\`, \`uniform ivec3 \${this.dimensionsId}\`]);
          }
        }
        y.exports = { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/dynamic-memory-optimized-number-texture": 44 }], 80: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueDynamicNumberTexture: g } = o("../../web-gl/kernel-value/dynamic-number-texture");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
        }
        y.exports = { WebGL2KernelValueDynamicNumberTexture: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/dynamic-number-texture": 45 }], 81: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueSingleArray: g } = o("../../web-gl2/kernel-value/single-array");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.dimensions = p.getDimensions(n, true), this.textureSize = p.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGL2KernelValueDynamicSingleArray: f };
      }, { "../../../utils": 114, "../../web-gl2/kernel-value/single-array": 95 }], 82: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueSingleArray1DI: g } = o("../../web-gl2/kernel-value/single-array1d-i");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.setShape(n), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGL2KernelValueDynamicSingleArray1DI: f };
      }, { "../../../utils": 114, "../../web-gl2/kernel-value/single-array1d-i": 96 }], 83: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueSingleArray2DI: g } = o("../../web-gl2/kernel-value/single-array2d-i");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.setShape(n), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGL2KernelValueDynamicSingleArray2DI: f };
      }, { "../../../utils": 114, "../../web-gl2/kernel-value/single-array2d-i": 98 }], 84: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueSingleArray3DI: g } = o("../../web-gl2/kernel-value/single-array3d-i");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            this.setShape(n), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGL2KernelValueDynamicSingleArray3DI: f };
      }, { "../../../utils": 114, "../../web-gl2/kernel-value/single-array3d-i": 100 }], 85: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueSingleInput: g } = o("../../web-gl2/kernel-value/single-input");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
          updateValue(n) {
            let [s, t, i] = n.size;
            this.dimensions = new Int32Array([s || 1, t || 1, i || 1]), this.textureSize = p.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(n);
          }
        }
        y.exports = { WebGL2KernelValueDynamicSingleInput: f };
      }, { "../../../utils": 114, "../../web-gl2/kernel-value/single-input": 102 }], 86: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueDynamicUnsignedArray: g } = o("../../web-gl/kernel-value/dynamic-unsigned-array");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
        }
        y.exports = { WebGL2KernelValueDynamicUnsignedArray: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/dynamic-unsigned-array": 51 }], 87: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueDynamicUnsignedInput: g } = o("../../web-gl/kernel-value/dynamic-unsigned-input");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`uniform \${n} ivec2 \${this.sizeId}\`, \`uniform \${n} ivec3 \${this.dimensionsId}\`]);
          }
        }
        y.exports = { WebGL2KernelValueDynamicUnsignedInput: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/dynamic-unsigned-input": 52 }], 88: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueFloat: g } = o("../../web-gl/kernel-value/float");
        class f extends g {
        }
        y.exports = { WebGL2KernelValueFloat: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/float": 53 }], 89: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelArray: g } = o("../../web-gl/kernel-value/array");
        class f extends g {
          constructor(n, s) {
            super(n, s), this.checkSize(n[0].width, n[0].height), this.dimensions = [n[0].width, n[0].height, n.length], this.textureSize = [n[0].width, n[0].height];
          }
          defineTexture() {
            let { context: n } = this;
            n.activeTexture(this.contextHandle), n.bindTexture(n.TEXTURE_2D_ARRAY, this.texture), n.texParameteri(n.TEXTURE_2D_ARRAY, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D_ARRAY, n.TEXTURE_MIN_FILTER, n.NEAREST);
          }
          getStringValueHandler() {
            return \`const uploadValue_\${this.name} = \${this.varName};
\`;
          }
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2DArray \${this.id}\`, \`\${n} ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`\${n} ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            let { context: s } = this;
            s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D_ARRAY, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, true), s.texImage3D(s.TEXTURE_2D_ARRAY, 0, s.RGBA, n[0].width, n[0].height, n.length, 0, s.RGBA, s.UNSIGNED_BYTE, null);
            for (let t = 0; t < n.length; t++)
              s.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, t, n[t].width, n[t].height, 1, s.RGBA, s.UNSIGNED_BYTE, this.uploadValue = n[t]);
            this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGL2KernelValueHTMLImageArray: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/array": 40 }], 90: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueHTMLImage: g } = o("../../web-gl/kernel-value/html-image");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`\${n} ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`\${n} ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
        }
        y.exports = { WebGL2KernelValueHTMLImage: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/html-image": 54 }], 91: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGL2KernelValueHTMLImage: g } = o("./html-image");
        class f extends g {
        }
        y.exports = { WebGL2KernelValueHTMLVideo: f };
      }, { "../../../utils": 114, "./html-image": 90 }], 92: [function(o, y, E) {
        let { WebGLKernelValueInteger: p } = o("../../web-gl/kernel-value/integer");
        class g extends p {
          getSource(l) {
            let n = this.getVariablePrecisionString();
            return this.origin === "constants" ? \`const \${n} int \${this.id} = \${parseInt(l)};
\` : \`uniform \${n} int \${this.id};
\`;
          }
          updateValue(l) {
            this.origin !== "constants" && this.kernel.setUniform1i(this.id, this.uploadValue = l);
          }
        }
        y.exports = { WebGL2KernelValueInteger: g };
      }, { "../../web-gl/kernel-value/integer": 57 }], 93: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueMemoryOptimizedNumberTexture: g } = o("../../web-gl/kernel-value/memory-optimized-number-texture");
        class f extends g {
          getSource() {
            let { id: n, sizeId: s, textureSize: t, dimensionsId: i, dimensions: u } = this, x2 = this.getVariablePrecisionString();
            return p.linesToString([\`uniform sampler2D \${n}\`, \`\${x2} ivec2 \${s} = ivec2(\${t[0]}, \${t[1]})\`, \`\${x2} ivec3 \${i} = ivec3(\${u[0]}, \${u[1]}, \${u[2]})\`]);
          }
        }
        y.exports = { WebGL2KernelValueMemoryOptimizedNumberTexture: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/memory-optimized-number-texture": 58 }], 94: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueNumberTexture: g } = o("../../web-gl/kernel-value/number-texture");
        class f extends g {
          getSource() {
            let { id: n, sizeId: s, textureSize: t, dimensionsId: i, dimensions: u } = this, x2 = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${x2} sampler2D \${n}\`, \`\${x2} ivec2 \${s} = ivec2(\${t[0]}, \${t[1]})\`, \`\${x2} ivec3 \${i} = ivec3(\${u[0]}, \${u[1]}, \${u[2]})\`]);
          }
        }
        y.exports = { WebGL2KernelValueNumberTexture: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/number-texture": 59 }], 95: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray: g } = o("../../web-gl/kernel-value/single-array");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`\${n} ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`\${n} ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA32F, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGL2KernelValueSingleArray: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/single-array": 60 }], 96: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray1DI: g } = o("../../web-gl/kernel-value/single-array1d-i");
        class f extends g {
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA32F, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGL2KernelValueSingleArray1DI: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/single-array1d-i": 61 }], 97: [function(o, y, E) {
        let { WebGLKernelValueSingleArray2: p } = o("../../web-gl/kernel-value/single-array2");
        class g extends p {
        }
        y.exports = { WebGL2KernelValueSingleArray2: g };
      }, { "../../web-gl/kernel-value/single-array2": 62 }], 98: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray2DI: g } = o("../../web-gl/kernel-value/single-array2d-i");
        class f extends g {
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA32F, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGL2KernelValueSingleArray2DI: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/single-array2d-i": 63 }], 99: [function(o, y, E) {
        let { WebGLKernelValueSingleArray3: p } = o("../../web-gl/kernel-value/single-array3");
        class g extends p {
        }
        y.exports = { WebGL2KernelValueSingleArray3: g };
      }, { "../../web-gl/kernel-value/single-array3": 64 }], 100: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleArray3DI: g } = o("../../web-gl/kernel-value/single-array3d-i");
        class f extends g {
          updateValue(n) {
            if (n.constructor !== this.initialValueConstructor) {
              this.onUpdateValueMismatch(n.constructor);
              return;
            }
            let { context: s } = this;
            p.flattenTo(n, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA32F, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGL2KernelValueSingleArray3DI: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/single-array3d-i": 65 }], 101: [function(o, y, E) {
        let { WebGLKernelValueSingleArray4: p } = o("../../web-gl/kernel-value/single-array4");
        class g extends p {
        }
        y.exports = { WebGL2KernelValueSingleArray4: g };
      }, { "../../web-gl/kernel-value/single-array4": 66 }], 102: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueSingleInput: g } = o("../../web-gl/kernel-value/single-input");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`\${n} ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`\${n} ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
          updateValue(n) {
            let { context: s } = this;
            p.flattenTo(n.value, this.uploadValue), s.activeTexture(this.contextHandle), s.bindTexture(s.TEXTURE_2D, this.texture), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, false), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA32F, this.textureSize[0], this.textureSize[1], 0, s.RGBA, s.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
          }
        }
        y.exports = { WebGL2KernelValueSingleInput: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/single-input": 67 }], 103: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueUnsignedArray: g } = o("../../web-gl/kernel-value/unsigned-array");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`\${n} ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`\${n} ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
        }
        y.exports = { WebGL2KernelValueUnsignedArray: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/unsigned-array": 68 }], 104: [function(o, y, E) {
        let { utils: p } = o("../../../utils"), { WebGLKernelValueUnsignedInput: g } = o("../../web-gl/kernel-value/unsigned-input");
        class f extends g {
          getSource() {
            let n = this.getVariablePrecisionString();
            return p.linesToString([\`uniform \${n} sampler2D \${this.id}\`, \`\${n} ivec2 \${this.sizeId} = ivec2(\${this.textureSize[0]}, \${this.textureSize[1]})\`, \`\${n} ivec3 \${this.dimensionsId} = ivec3(\${this.dimensions[0]}, \${this.dimensions[1]}, \${this.dimensions[2]})\`]);
          }
        }
        y.exports = { WebGL2KernelValueUnsignedInput: f };
      }, { "../../../utils": 114, "../../web-gl/kernel-value/unsigned-input": 69 }], 105: [function(o, y, E) {
        let { WebGLKernel: p } = o("../web-gl/kernel"), { WebGL2FunctionNode: g } = o("./function-node"), { FunctionBuilder: f } = o("../function-builder"), { utils: l } = o("../../utils"), { fragmentShader: n } = o("./fragment-shader"), { vertexShader: s } = o("./vertex-shader"), { lookupKernelValueType: t } = o("./kernel-value-maps"), i = null, u = null, x2 = null, w = null, m = null;
        class S extends p {
          static get isSupported() {
            return i !== null || (this.setupFeatureChecks(), i = this.isContextMatch(x2)), i;
          }
          static setupFeatureChecks() {
            typeof document < "u" ? u = document.createElement("canvas") : typeof OffscreenCanvas < "u" && (u = new OffscreenCanvas(0, 0)), u && (x2 = u.getContext("webgl2"), !(!x2 || !x2.getExtension) && (w = { EXT_color_buffer_float: x2.getExtension("EXT_color_buffer_float"), OES_texture_float_linear: x2.getExtension("OES_texture_float_linear") }, m = this.getFeatures()));
          }
          static isContextMatch(h) {
            return typeof WebGL2RenderingContext < "u" ? h instanceof WebGL2RenderingContext : false;
          }
          static getFeatures() {
            let h = this.testContext;
            return Object.freeze({ isFloatRead: this.getIsFloatRead(), isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(), isSpeedTacticSupported: this.getIsSpeedTacticSupported(), kernelMap: true, isTextureFloat: true, isDrawBuffers: true, channelCount: this.getChannelCount(), maxTextureSize: this.getMaxTextureSize(), lowIntPrecision: h.getShaderPrecisionFormat(h.FRAGMENT_SHADER, h.LOW_INT), lowFloatPrecision: h.getShaderPrecisionFormat(h.FRAGMENT_SHADER, h.LOW_FLOAT), mediumIntPrecision: h.getShaderPrecisionFormat(h.FRAGMENT_SHADER, h.MEDIUM_INT), mediumFloatPrecision: h.getShaderPrecisionFormat(h.FRAGMENT_SHADER, h.MEDIUM_FLOAT), highIntPrecision: h.getShaderPrecisionFormat(h.FRAGMENT_SHADER, h.HIGH_INT), highFloatPrecision: h.getShaderPrecisionFormat(h.FRAGMENT_SHADER, h.HIGH_FLOAT) });
          }
          static getIsTextureFloat() {
            return true;
          }
          static getChannelCount() {
            return x2.getParameter(x2.MAX_DRAW_BUFFERS);
          }
          static getMaxTextureSize() {
            return x2.getParameter(x2.MAX_TEXTURE_SIZE);
          }
          static lookupKernelValueType(h, b, T, C) {
            return t(h, b, T, C);
          }
          static get testCanvas() {
            return u;
          }
          static get testContext() {
            return x2;
          }
          static get features() {
            return m;
          }
          static get fragmentShader() {
            return n;
          }
          static get vertexShader() {
            return s;
          }
          initContext() {
            let h = { alpha: false, depth: false, antialias: false };
            return this.canvas.getContext("webgl2", h);
          }
          initExtensions() {
            this.extensions = { EXT_color_buffer_float: this.context.getExtension("EXT_color_buffer_float"), OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear") };
          }
          validateSettings(h) {
            if (!this.validate) {
              this.texSize = l.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, precision: this.precision }, this.output);
              return;
            }
            let { features: b } = this.constructor;
            if (this.precision === "single" && !b.isFloatRead)
              throw new Error("Float texture outputs are not supported");
            if (!this.graphical && this.precision === null && (this.precision = b.isFloatRead ? "single" : "unsigned"), this.fixIntegerDivisionAccuracy === null ? this.fixIntegerDivisionAccuracy = !b.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && b.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = false), this.checkOutput(), !this.output || this.output.length === 0) {
              if (h.length !== 1)
                throw new Error("Auto output only supported for kernels with only one input");
              let T = l.getVariableType(h[0], this.strictIntegers);
              switch (T) {
                case "Array":
                  this.output = l.getDimensions(T);
                  break;
                case "NumberTexture":
                case "MemoryOptimizedNumberTexture":
                case "ArrayTexture(1)":
                case "ArrayTexture(2)":
                case "ArrayTexture(3)":
                case "ArrayTexture(4)":
                  this.output = h[0].output;
                  break;
                default:
                  throw new Error("Auto output not supported for input type: " + T);
              }
            }
            if (this.graphical) {
              if (this.output.length !== 2)
                throw new Error("Output must have 2 dimensions on graphical mode");
              this.precision === "single" && (console.warn("Cannot use graphical mode and single precision at the same time"), this.precision = "unsigned"), this.texSize = l.clone(this.output);
              return;
            } else
              !this.graphical && this.precision === null && b.isTextureFloat && (this.precision = "single");
            this.texSize = l.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, precision: this.precision }, this.output), this.checkTextureSize();
          }
          translateSource() {
            let h = f.fromKernel(this, g, { fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy });
            this.translatedSource = h.getPrototypeString("kernel"), this.setupReturnTypes(h);
          }
          drawBuffers() {
            this.context.drawBuffers(this.drawBuffersMap);
          }
          getTextureFormat() {
            let { context: h } = this;
            switch (this.getInternalFormat()) {
              case h.R32F:
                return h.RED;
              case h.RG32F:
                return h.RG;
              case h.RGBA32F:
                return h.RGBA;
              case h.RGBA:
                return h.RGBA;
              default:
                throw new Error("Unknown internal format");
            }
          }
          getInternalFormat() {
            let { context: h } = this;
            if (this.precision === "single") {
              if (this.pipeline)
                switch (this.returnType) {
                  case "Number":
                  case "Float":
                  case "Integer":
                    return this.optimizeFloatMemory ? h.RGBA32F : h.R32F;
                  case "Array(2)":
                    return h.RG32F;
                  case "Array(3)":
                  case "Array(4)":
                    return h.RGBA32F;
                  default:
                    throw new Error("Unhandled return type");
                }
              return h.RGBA32F;
            }
            return h.RGBA;
          }
          _setupOutputTexture() {
            let h = this.context;
            if (this.texture) {
              h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, this.texture.texture, 0);
              return;
            }
            h.bindFramebuffer(h.FRAMEBUFFER, this.framebuffer);
            let b = h.createTexture(), T = this.texSize;
            h.activeTexture(h.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount), h.bindTexture(h.TEXTURE_2D, b), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.NEAREST), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.NEAREST);
            let C = this.getInternalFormat();
            this.precision === "single" ? h.texStorage2D(h.TEXTURE_2D, 1, C, T[0], T[1]) : h.texImage2D(h.TEXTURE_2D, 0, C, T[0], T[1], 0, C, h.UNSIGNED_BYTE, null), h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, b, 0), this.texture = new this.TextureConstructor({ texture: b, size: T, dimensions: this.threadDim, output: this.output, context: this.context, internalFormat: this.getInternalFormat(), textureFormat: this.getTextureFormat(), kernel: this });
          }
          _setupSubOutputTextures() {
            let h = this.context;
            if (this.mappedTextures) {
              for (let T = 0; T < this.subKernels.length; T++)
                h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0 + T + 1, h.TEXTURE_2D, this.mappedTextures[T].texture, 0);
              return;
            }
            let b = this.texSize;
            this.drawBuffersMap = [h.COLOR_ATTACHMENT0], this.mappedTextures = [];
            for (let T = 0; T < this.subKernels.length; T++) {
              let C = this.createTexture();
              this.drawBuffersMap.push(h.COLOR_ATTACHMENT0 + T + 1), h.activeTexture(h.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + T), h.bindTexture(h.TEXTURE_2D, C), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.NEAREST), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.NEAREST);
              let V = this.getInternalFormat();
              this.precision === "single" ? h.texStorage2D(h.TEXTURE_2D, 1, V, b[0], b[1]) : h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, b[0], b[1], 0, h.RGBA, h.UNSIGNED_BYTE, null), h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0 + T + 1, h.TEXTURE_2D, C, 0), this.mappedTextures.push(new this.TextureConstructor({ texture: C, size: b, dimensions: this.threadDim, output: this.output, context: this.context, internalFormat: this.getInternalFormat(), textureFormat: this.getTextureFormat(), kernel: this }));
            }
          }
          _getHeaderString() {
            return "";
          }
          _getTextureCoordinate() {
            let h = this.subKernels, b = this.getVariablePrecisionString(this.texSize, this.tactic);
            return h === null || h.length < 1 ? \`in \${b} vec2 vTexCoord;
\` : \`out \${b} vec2 vTexCoord;
\`;
          }
          _getMainArgumentsString(h) {
            let b = [], T = this.argumentNames;
            for (let C = 0; C < T.length; C++)
              b.push(this.kernelArguments[C].getSource(h[C]));
            return b.join("");
          }
          getKernelString() {
            let h = [this.getKernelResultDeclaration()], b = this.subKernels;
            if (b !== null)
              switch (h.push("layout(location = 0) out vec4 data0"), this.returnType) {
                case "Number":
                case "Float":
                case "Integer":
                  for (let T = 0; T < b.length; T++) {
                    let C = b[T];
                    h.push(C.returnType === "Integer" ? \`int subKernelResult_\${C.name} = 0\` : \`float subKernelResult_\${C.name} = 0.0\`, \`layout(location = \${T + 1}) out vec4 data\${T + 1}\`);
                  }
                  break;
                case "Array(2)":
                  for (let T = 0; T < b.length; T++)
                    h.push(\`vec2 subKernelResult_\${b[T].name}\`, \`layout(location = \${T + 1}) out vec4 data\${T + 1}\`);
                  break;
                case "Array(3)":
                  for (let T = 0; T < b.length; T++)
                    h.push(\`vec3 subKernelResult_\${b[T].name}\`, \`layout(location = \${T + 1}) out vec4 data\${T + 1}\`);
                  break;
                case "Array(4)":
                  for (let T = 0; T < b.length; T++)
                    h.push(\`vec4 subKernelResult_\${b[T].name}\`, \`layout(location = \${T + 1}) out vec4 data\${T + 1}\`);
                  break;
              }
            else
              h.push("out vec4 data0");
            return l.linesToString(h) + this.translatedSource;
          }
          getMainResultGraphical() {
            return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0 = actualColor"]);
          }
          getMainResultPackedPixels() {
            switch (this.returnType) {
              case "LiteralInteger":
              case "Number":
              case "Integer":
              case "Float":
                return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();
              default:
                throw new Error(\`packed output only usable with Numbers, "\${this.returnType}" specified\`);
            }
          }
          getMainResultKernelPackedPixels() {
            return l.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", \`  data0 = \${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(kernelResult)\`]);
          }
          getMainResultSubKernelPackedPixels() {
            let h = [];
            if (!this.subKernels)
              return "";
            for (let b = 0; b < this.subKernels.length; b++)
              this.subKernels[b].returnType === "Integer" ? h.push(\`  data\${b + 1} = \${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(float(subKernelResult_\${this.subKernels[b].name}))\`) : h.push(\`  data\${b + 1} = \${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(subKernelResult_\${this.subKernels[b].name})\`);
            return l.linesToString(h);
          }
          getMainResultKernelMemoryOptimizedFloats(h, b) {
            h.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", \`  data0.\${b} = kernelResult\`);
          }
          getMainResultSubKernelMemoryOptimizedFloats(h, b) {
            if (!this.subKernels)
              return h;
            for (let T = 0; T < this.subKernels.length; T++) {
              let C = this.subKernels[T];
              C.returnType === "Integer" ? h.push(\`  data\${T + 1}.\${b} = float(subKernelResult_\${C.name})\`) : h.push(\`  data\${T + 1}.\${b} = subKernelResult_\${C.name}\`);
            }
          }
          getMainResultKernelNumberTexture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0[0] = kernelResult"];
          }
          getMainResultSubKernelNumberTexture() {
            let h = [];
            if (!this.subKernels)
              return h;
            for (let b = 0; b < this.subKernels.length; ++b) {
              let T = this.subKernels[b];
              T.returnType === "Integer" ? h.push(\`  data\${b + 1}[0] = float(subKernelResult_\${T.name})\`) : h.push(\`  data\${b + 1}[0] = subKernelResult_\${T.name}\`);
            }
            return h;
          }
          getMainResultKernelArray2Texture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0[0] = kernelResult[0]", "  data0[1] = kernelResult[1]"];
          }
          getMainResultSubKernelArray2Texture() {
            let h = [];
            if (!this.subKernels)
              return h;
            for (let b = 0; b < this.subKernels.length; ++b) {
              let T = this.subKernels[b];
              h.push(\`  data\${b + 1}[0] = subKernelResult_\${T.name}[0]\`, \`  data\${b + 1}[1] = subKernelResult_\${T.name}[1]\`);
            }
            return h;
          }
          getMainResultKernelArray3Texture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0[0] = kernelResult[0]", "  data0[1] = kernelResult[1]", "  data0[2] = kernelResult[2]"];
          }
          getMainResultSubKernelArray3Texture() {
            let h = [];
            if (!this.subKernels)
              return h;
            for (let b = 0; b < this.subKernels.length; ++b) {
              let T = this.subKernels[b];
              h.push(\`  data\${b + 1}[0] = subKernelResult_\${T.name}[0]\`, \`  data\${b + 1}[1] = subKernelResult_\${T.name}[1]\`, \`  data\${b + 1}[2] = subKernelResult_\${T.name}[2]\`);
            }
            return h;
          }
          getMainResultKernelArray4Texture() {
            return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0 = kernelResult"];
          }
          getMainResultSubKernelArray4Texture() {
            let h = [];
            if (!this.subKernels)
              return h;
            for (let b = 0; b < this.subKernels.length; ++b)
              h.push(\`  data\${b + 1} = subKernelResult_\${this.subKernels[b].name}\`);
            return h;
          }
          destroyExtensions() {
            this.extensions.EXT_color_buffer_float = null, this.extensions.OES_texture_float_linear = null;
          }
          toJSON() {
            let h = super.toJSON();
            return h.functionNodes = f.fromKernel(this, g).toJSON(), h.settings.threadDim = this.threadDim, h;
          }
        }
        y.exports = { WebGL2Kernel: S };
      }, { "../../utils": 114, "../function-builder": 9, "../web-gl/kernel": 70, "./fragment-shader": 72, "./function-node": 73, "./kernel-value-maps": 74, "./vertex-shader": 106 }], 106: [function(o, y, E) {
        let p = \`#version 300 es
      __FLOAT_TACTIC_DECLARATION__;
      __INT_TACTIC_DECLARATION__;
      __SAMPLER_2D_TACTIC_DECLARATION__;
      
      in vec2 aPos;
      in vec2 aTexCoord;
      
      out vec2 vTexCoord;
      uniform vec2 ratio;
      
      void main(void) {
        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
        vTexCoord = aTexCoord;
      }\`;
        y.exports = { vertexShader: p };
      }, {}], 107: [function(o, y, E) {
        let p = o("./index"), g = p.GPU;
        for (let l in p)
          !p.hasOwnProperty(l) || l !== "GPU" && (g[l] = p[l]);
        typeof window < "u" && f(window), typeof self < "u" && f(self);
        function f(l) {
          l.GPU || Object.defineProperty(l, "GPU", { get() {
            return g;
          } });
        }
        y.exports = p;
      }, { "./index": 109 }], 108: [function(o, y, E) {
        let { gpuMock: p } = o("gpu-mock.js"), { utils: g } = o("./utils"), { Kernel: f } = o("./backend/kernel"), { CPUKernel: l } = o("./backend/cpu/kernel"), { HeadlessGLKernel: n } = o("./backend/headless-gl/kernel"), { WebGL2Kernel: s } = o("./backend/web-gl2/kernel"), { WebGLKernel: t } = o("./backend/web-gl/kernel"), { kernelRunShortcut: i } = o("./kernel-run-shortcut"), u = [n, s, t], x2 = ["gpu", "cpu"], w = { headlessgl: n, webgl2: s, webgl: t }, m = true;
        class S {
          static disableValidation() {
            m = false;
          }
          static enableValidation() {
            m = true;
          }
          static get isGPUSupported() {
            return u.some((b) => b.isSupported);
          }
          static get isKernelMapSupported() {
            return u.some((b) => b.isSupported && b.features.kernelMap);
          }
          static get isOffscreenCanvasSupported() {
            return typeof Worker < "u" && typeof OffscreenCanvas < "u" || typeof importScripts < "u";
          }
          static get isWebGLSupported() {
            return t.isSupported;
          }
          static get isWebGL2Supported() {
            return s.isSupported;
          }
          static get isHeadlessGLSupported() {
            return n.isSupported;
          }
          static get isCanvasSupported() {
            return typeof HTMLCanvasElement < "u";
          }
          static get isGPUHTMLImageArraySupported() {
            return s.isSupported;
          }
          static get isSinglePrecisionSupported() {
            return u.some((b) => b.isSupported && b.features.isFloatRead && b.features.isTextureFloat);
          }
          constructor(b) {
            if (b = b || {}, this.canvas = b.canvas || null, this.context = b.context || null, this.mode = b.mode, this.Kernel = null, this.kernels = [], this.functions = [], this.nativeFunctions = [], this.injectedNative = null, this.mode !== "dev") {
              if (this.chooseKernel(), b.functions)
                for (let T = 0; T < b.functions.length; T++)
                  this.addFunction(b.functions[T]);
              if (b.nativeFunctions)
                for (let T in b.nativeFunctions) {
                  if (!b.nativeFunctions.hasOwnProperty(T))
                    continue;
                  let C = b.nativeFunctions[T], { name: V, source: c } = C;
                  this.addNativeFunction(V, c, C);
                }
            }
          }
          chooseKernel() {
            if (this.Kernel)
              return;
            let b = null;
            if (this.context) {
              for (let T = 0; T < u.length; T++) {
                let C = u[T];
                if (C.isContextMatch(this.context)) {
                  if (!C.isSupported)
                    throw new Error(\`Kernel type \${C.name} not supported\`);
                  b = C;
                  break;
                }
              }
              if (b === null)
                throw new Error("unknown Context");
            } else if (this.mode) {
              if (this.mode in w)
                (!m || w[this.mode].isSupported) && (b = w[this.mode]);
              else if (this.mode === "gpu") {
                for (let T = 0; T < u.length; T++)
                  if (u[T].isSupported) {
                    b = u[T];
                    break;
                  }
              } else
                this.mode === "cpu" && (b = l);
              if (!b)
                throw new Error(\`A requested mode of "\${this.mode}" and is not supported\`);
            } else {
              for (let T = 0; T < u.length; T++)
                if (u[T].isSupported) {
                  b = u[T];
                  break;
                }
              b || (b = l);
            }
            this.mode || (this.mode = b.mode), this.Kernel = b;
          }
          createKernel(b, T) {
            if (typeof b > "u")
              throw new Error("Missing source parameter");
            if (typeof b != "object" && !g.isFunction(b) && typeof b != "string")
              throw new Error("source parameter not a function");
            let C = this.kernels;
            if (this.mode === "dev") {
              let L = p(b, v(T));
              return C.push(L), L;
            }
            b = typeof b == "function" ? b.toString() : b;
            let V = {}, c = v(T) || {};
            T && typeof T.argumentTypes == "object" && (c.argumentTypes = Object.keys(T.argumentTypes).map((L) => T.argumentTypes[L]));
            function a(L) {
              console.warn("Falling back to CPU");
              let K = new l(b, { argumentTypes: F.argumentTypes, constantTypes: F.constantTypes, graphical: F.graphical, loopMaxIterations: F.loopMaxIterations, constants: F.constants, dynamicOutput: F.dynamicOutput, dynamicArgument: F.dynamicArguments, output: F.output, precision: F.precision, pipeline: F.pipeline, immutable: F.immutable, optimizeFloatMemory: F.optimizeFloatMemory, fixIntegerDivisionAccuracy: F.fixIntegerDivisionAccuracy, functions: F.functions, nativeFunctions: F.nativeFunctions, injectedNative: F.injectedNative, subKernels: F.subKernels, strictIntegers: F.strictIntegers, debug: F.debug });
              K.build.apply(K, L);
              let O = K.run.apply(K, L);
              return F.replaceKernel(K), O;
            }
            function k(L, K, O) {
              O.debug && console.warn("Switching kernels");
              let X = null;
              if (O.signature && !V[O.signature] && (V[O.signature] = O), O.dynamicOutput)
                for (let j = L.length - 1; j >= 0; j--) {
                  let U = L[j];
                  U.type === "outputPrecisionMismatch" && (X = U.needed);
                }
              let B = O.constructor, P = B.getArgumentTypes(O, K), Y = B.getSignature(O, P), J = V[Y];
              if (J)
                return J.onActivate(O), J;
              let q = V[Y] = new B(b, { argumentTypes: P, constantTypes: O.constantTypes, graphical: O.graphical, loopMaxIterations: O.loopMaxIterations, constants: O.constants, dynamicOutput: O.dynamicOutput, dynamicArgument: O.dynamicArguments, context: O.context, canvas: O.canvas, output: X || O.output, precision: O.precision, pipeline: O.pipeline, immutable: O.immutable, optimizeFloatMemory: O.optimizeFloatMemory, fixIntegerDivisionAccuracy: O.fixIntegerDivisionAccuracy, functions: O.functions, nativeFunctions: O.nativeFunctions, injectedNative: O.injectedNative, subKernels: O.subKernels, strictIntegers: O.strictIntegers, debug: O.debug, gpu: O.gpu, validate: m, returnType: O.returnType, tactic: O.tactic, onRequestFallback: a, onRequestSwitchKernel: k, texture: O.texture, mappedTextures: O.mappedTextures, drawBuffersMap: O.drawBuffersMap });
              return q.build.apply(q, K), F.replaceKernel(q), C.push(q), q;
            }
            let A = Object.assign({ context: this.context, canvas: this.canvas, functions: this.functions, nativeFunctions: this.nativeFunctions, injectedNative: this.injectedNative, gpu: this, validate: m, onRequestFallback: a, onRequestSwitchKernel: k }, c), N = new this.Kernel(b, A), F = i(N);
            return this.canvas || (this.canvas = N.canvas), this.context || (this.context = N.context), C.push(N), F;
          }
          createKernelMap() {
            let b, T, C = typeof arguments[arguments.length - 2];
            if (C === "function" || C === "string" ? (b = arguments[arguments.length - 2], T = arguments[arguments.length - 1]) : b = arguments[arguments.length - 1], this.mode !== "dev" && (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) && this.mode && x2.indexOf(this.mode) < 0)
              throw new Error(\`kernelMap not supported on \${this.Kernel.name}\`);
            let V = v(T);
            if (T && typeof T.argumentTypes == "object" && (V.argumentTypes = Object.keys(T.argumentTypes).map((c) => T.argumentTypes[c])), Array.isArray(arguments[0])) {
              V.subKernels = [];
              let c = arguments[0];
              for (let a = 0; a < c.length; a++) {
                let k = c[a].toString(), A = g.getFunctionNameFromString(k);
                V.subKernels.push({ name: A, source: k, property: a });
              }
            } else {
              V.subKernels = [];
              let c = arguments[0];
              for (let a in c) {
                if (!c.hasOwnProperty(a))
                  continue;
                let k = c[a].toString(), A = g.getFunctionNameFromString(k);
                V.subKernels.push({ name: A || a, source: k, property: a });
              }
            }
            return this.createKernel(b, V);
          }
          combineKernels() {
            let b = arguments[0], T = arguments[arguments.length - 1];
            if (b.kernel.constructor.mode === "cpu")
              return T;
            let C = arguments[0].canvas, V = arguments[0].context, c = arguments.length - 1;
            for (let a = 0; a < c; a++)
              arguments[a].setCanvas(C).setContext(V).setPipeline(true);
            return function() {
              let a = T.apply(this, arguments);
              return a.toArray ? a.toArray() : a;
            };
          }
          setFunctions(b) {
            return this.functions = b, this;
          }
          setNativeFunctions(b) {
            return this.nativeFunctions = b, this;
          }
          addFunction(b, T) {
            return this.functions.push({ source: b, settings: T }), this;
          }
          addNativeFunction(b, T, C) {
            if (this.kernels.length > 0)
              throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
            return this.nativeFunctions.push(Object.assign({ name: b, source: T }, C)), this;
          }
          injectNative(b) {
            return this.injectedNative = b, this;
          }
          destroy() {
            return new Promise((b, T) => {
              this.kernels || b(), setTimeout(() => {
                try {
                  for (let V = 0; V < this.kernels.length; V++)
                    this.kernels[V].destroy(true);
                  let C = this.kernels[0];
                  C && (C.kernel && (C = C.kernel), C.constructor.destroyContext && C.constructor.destroyContext(this.context));
                } catch (C) {
                  T(C);
                }
                b();
              }, 0);
            });
          }
        }
        function v(h) {
          if (!h)
            return {};
          let b = Object.assign({}, h);
          return h.hasOwnProperty("floatOutput") && (g.warnDeprecated("setting", "floatOutput", "precision"), b.precision = h.floatOutput ? "single" : "unsigned"), h.hasOwnProperty("outputToTexture") && (g.warnDeprecated("setting", "outputToTexture", "pipeline"), b.pipeline = Boolean(h.outputToTexture)), h.hasOwnProperty("outputImmutable") && (g.warnDeprecated("setting", "outputImmutable", "immutable"), b.immutable = Boolean(h.outputImmutable)), h.hasOwnProperty("floatTextures") && (g.warnDeprecated("setting", "floatTextures", "optimizeFloatMemory"), b.optimizeFloatMemory = Boolean(h.floatTextures)), b;
        }
        y.exports = { GPU: S, kernelOrder: u, kernelTypes: x2 };
      }, { "./backend/cpu/kernel": 8, "./backend/headless-gl/kernel": 34, "./backend/kernel": 36, "./backend/web-gl/kernel": 70, "./backend/web-gl2/kernel": 105, "./kernel-run-shortcut": 111, "./utils": 114, "gpu-mock.js": 4 }], 109: [function(o, y, E) {
        let { GPU: p } = o("./gpu"), { alias: g } = o("./alias"), { utils: f } = o("./utils"), { Input: l, input: n } = o("./input"), { Texture: s } = o("./texture"), { FunctionBuilder: t } = o("./backend/function-builder"), { FunctionNode: i } = o("./backend/function-node"), { CPUFunctionNode: u } = o("./backend/cpu/function-node"), { CPUKernel: x2 } = o("./backend/cpu/kernel"), { HeadlessGLKernel: w } = o("./backend/headless-gl/kernel"), { WebGLFunctionNode: m } = o("./backend/web-gl/function-node"), { WebGLKernel: S } = o("./backend/web-gl/kernel"), { kernelValueMaps: v } = o("./backend/web-gl/kernel-value-maps"), { WebGL2FunctionNode: h } = o("./backend/web-gl2/function-node"), { WebGL2Kernel: b } = o("./backend/web-gl2/kernel"), { kernelValueMaps: T } = o("./backend/web-gl2/kernel-value-maps"), { GLKernel: C } = o("./backend/gl/kernel"), { Kernel: V } = o("./backend/kernel"), { FunctionTracer: c } = o("./backend/function-tracer"), a = o("./plugins/math-random-uniformly-distributed");
        y.exports = { alias: g, CPUFunctionNode: u, CPUKernel: x2, GPU: p, FunctionBuilder: t, FunctionNode: i, HeadlessGLKernel: w, Input: l, input: n, Texture: s, utils: f, WebGL2FunctionNode: h, WebGL2Kernel: b, webGL2KernelValueMaps: T, WebGLFunctionNode: m, WebGLKernel: S, webGLKernelValueMaps: v, GLKernel: C, Kernel: V, FunctionTracer: c, plugins: { mathRandom: a } };
      }, { "./alias": 5, "./backend/cpu/function-node": 6, "./backend/cpu/kernel": 8, "./backend/function-builder": 9, "./backend/function-node": 10, "./backend/function-tracer": 11, "./backend/gl/kernel": 13, "./backend/headless-gl/kernel": 34, "./backend/kernel": 36, "./backend/web-gl/function-node": 38, "./backend/web-gl/kernel": 70, "./backend/web-gl/kernel-value-maps": 39, "./backend/web-gl2/function-node": 73, "./backend/web-gl2/kernel": 105, "./backend/web-gl2/kernel-value-maps": 74, "./gpu": 108, "./input": 110, "./plugins/math-random-uniformly-distributed": 112, "./texture": 113, "./utils": 114 }], 110: [function(o, y, E) {
        class p {
          constructor(l, n) {
            this.value = l, Array.isArray(n) ? this.size = n : (this.size = new Int32Array(3), n.z ? this.size = new Int32Array([n.x, n.y, n.z]) : n.y ? this.size = new Int32Array([n.x, n.y]) : this.size = new Int32Array([n.x]));
            let [s, t, i] = this.size;
            if (i) {
              if (this.value.length !== s * t * i)
                throw new Error(\`Input size \${this.value.length} does not match \${s} * \${t} * \${i} = \${t * s * i}\`);
            } else if (t) {
              if (this.value.length !== s * t)
                throw new Error(\`Input size \${this.value.length} does not match \${s} * \${t} = \${t * s}\`);
            } else if (this.value.length !== s)
              throw new Error(\`Input size \${this.value.length} does not match \${s}\`);
          }
          toArray() {
            let { utils: l } = o("./utils"), [n, s, t] = this.size;
            return t ? l.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), n, s, t) : s ? l.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), n, s) : this.value;
          }
        }
        function g(f, l) {
          return new p(f, l);
        }
        y.exports = { Input: p, input: g };
      }, { "./utils": 114 }], 111: [function(o, y, E) {
        let { utils: p } = o("./utils");
        function g(l) {
          let n = function() {
            return l.build.apply(l, arguments), n = function() {
              let t = l.run.apply(l, arguments);
              if (l.switchingKernels) {
                let i = l.resetSwitchingKernels(), u = l.onRequestSwitchKernel(i, arguments, l);
                s.kernel = l = u, t = u.run.apply(u, arguments);
              }
              return l.renderKernels ? l.renderKernels() : l.renderOutput ? l.renderOutput() : t;
            }, n.apply(l, arguments);
          }, s = function() {
            return n.apply(l, arguments);
          };
          return s.exec = function() {
            return new Promise((t, i) => {
              try {
                t(n.apply(this, arguments));
              } catch (u) {
                i(u);
              }
            });
          }, s.replaceKernel = function(t) {
            l = t, f(l, s);
          }, f(l, s), s;
        }
        function f(l, n) {
          if (n.kernel) {
            n.kernel = l;
            return;
          }
          let s = p.allPropertiesOf(l);
          for (let t = 0; t < s.length; t++) {
            let i = s[t];
            i[0] === "_" && i[1] === "_" || (typeof l[i] == "function" ? i.substring(0, 3) === "add" || i.substring(0, 3) === "set" ? n[i] = function() {
              return n.kernel[i].apply(n.kernel, arguments), n;
            } : n[i] = function() {
              return n.kernel[i].apply(n.kernel, arguments);
            } : (n.__defineGetter__(i, () => n.kernel[i]), n.__defineSetter__(i, (u) => {
              n.kernel[i] = u;
            })));
          }
          n.kernel = l;
        }
        y.exports = { kernelRunShortcut: g };
      }, { "./utils": 114 }], 112: [function(o, y, E) {
        let t = { name: "math-random-uniformly-distributed", onBeforeRun: (i) => {
          i.setUniform1f("randomSeed1", Math.random()), i.setUniform1f("randomSeed2", Math.random());
        }, functionMatch: "Math.random()", functionReplace: "nrand(vTexCoord)", functionReturnType: "Number", source: \`// https://www.shadertoy.com/view/4t2SDh
      //note: uniformly distributed, normalized rand, [0,1]
      highp float randomSeedShift = 1.0;
      highp float slide = 1.0;
      uniform highp float randomSeed1;
      uniform highp float randomSeed2;
      
      highp float nrand(highp vec2 n) {
        highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
        randomSeedShift = result;
        if (randomSeedShift > 0.5) {
          slide += 0.00009; 
        } else {
          slide += 0.0009;
        }
        return result;
      }\` };
        y.exports = t;
      }, {}], 113: [function(o, y, E) {
        class p {
          constructor(f) {
            let { texture: l, size: n, dimensions: s, output: t, context: i, type: u = "NumberTexture", kernel: x2, internalFormat: w, textureFormat: m } = f;
            if (!t)
              throw new Error('settings property "output" required.');
            if (!i)
              throw new Error('settings property "context" required.');
            if (!l)
              throw new Error('settings property "texture" required.');
            if (!x2)
              throw new Error('settings property "kernel" required.');
            this.texture = l, l._refs ? l._refs++ : l._refs = 1, this.size = n, this.dimensions = s, this.output = t, this.context = i, this.kernel = x2, this.type = u, this._deleted = false, this.internalFormat = w, this.textureFormat = m;
          }
          toArray() {
            throw new Error(\`Not implemented on \${this.constructor.name}\`);
          }
          clone() {
            throw new Error(\`Not implemented on \${this.constructor.name}\`);
          }
          delete() {
            throw new Error(\`Not implemented on \${this.constructor.name}\`);
          }
          clear() {
            throw new Error(\`Not implemented on \${this.constructor.name}\`);
          }
        }
        y.exports = { Texture: p };
      }, {}], 114: [function(o, y, E) {
        let p = o("acorn"), { Input: g } = o("./input"), { Texture: f } = o("./texture"), l = /function ([^(]*)/, n = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg, s = /([^\\s,]+)/g, t = { systemEndianness() {
          return w;
        }, getSystemEndianness() {
          let m = new ArrayBuffer(4), S = new Uint32Array(m), v = new Uint8Array(m);
          if (S[0] = 3735928559, v[0] === 239)
            return "LE";
          if (v[0] === 222)
            return "BE";
          throw new Error("unknown endianness");
        }, isFunction(m) {
          return typeof m == "function";
        }, isFunctionString(m) {
          return typeof m == "string" ? m.slice(0, 8).toLowerCase() === "function" : false;
        }, getFunctionNameFromString(m) {
          let S = l.exec(m);
          return !S || S.length === 0 ? null : S[1].trim();
        }, getFunctionBodyFromString(m) {
          return m.substring(m.indexOf("{") + 1, m.lastIndexOf("}"));
        }, getArgumentNamesFromString(m) {
          let S = m.replace(n, ""), v = S.slice(S.indexOf("(") + 1, S.indexOf(")")).match(s);
          return v === null && (v = []), v;
        }, clone(m) {
          if (m === null || typeof m != "object" || m.hasOwnProperty("isActiveClone"))
            return m;
          let S = m.constructor();
          for (let v in m)
            Object.prototype.hasOwnProperty.call(m, v) && (m.isActiveClone = null, S[v] = t.clone(m[v]), delete m.isActiveClone);
          return S;
        }, isArray(m) {
          return !isNaN(m.length);
        }, getVariableType(m, S) {
          if (t.isArray(m))
            return m.length > 0 && m[0].nodeName === "IMG" ? "HTMLImageArray" : "Array";
          switch (m.constructor) {
            case Boolean:
              return "Boolean";
            case Number:
              return S && Number.isInteger(m) ? "Integer" : "Float";
            case f:
              return m.type;
            case g:
              return "Input";
          }
          switch (m.nodeName) {
            case "IMG":
              return "HTMLImage";
            case "CANVAS":
              return "HTMLImage";
            case "VIDEO":
              return "HTMLVideo";
          }
          return m.hasOwnProperty("type") ? m.type : "Unknown";
        }, getKernelTextureSize(m, S) {
          let [v, h, b] = S, T = (v || 1) * (h || 1) * (b || 1);
          return m.optimizeFloatMemory && m.precision === "single" && (v = T = Math.ceil(T / 4)), h > 1 && v * h === T ? new Int32Array([v, h]) : t.closestSquareDimensions(T);
        }, closestSquareDimensions(m) {
          let S = Math.sqrt(m), v = Math.ceil(S), h = Math.floor(S);
          for (; v * h < m; )
            v--, h = Math.ceil(m / v);
          return new Int32Array([h, Math.ceil(m / h)]);
        }, getMemoryOptimizedFloatTextureSize(m, S) {
          let h = t.roundTo((m[0] || 1) * (m[1] || 1) * (m[2] || 1) * (m[3] || 1), 4) / S;
          return t.closestSquareDimensions(h);
        }, getMemoryOptimizedPackedTextureSize(m, S) {
          let [v, h, b] = m, C = t.roundTo((v || 1) * (h || 1) * (b || 1), 4) / (4 / S);
          return t.closestSquareDimensions(C);
        }, roundTo(m, S) {
          return Math.floor((m + S - 1) / S) * S;
        }, getDimensions(m, S) {
          let v;
          if (t.isArray(m)) {
            let h = [], b = m;
            for (; t.isArray(b); )
              h.push(b.length), b = b[0];
            v = h.reverse();
          } else if (m instanceof f)
            v = m.output;
          else if (m instanceof g)
            v = m.size;
          else
            throw new Error(\`Unknown dimensions of \${m}\`);
          if (S)
            for (v = Array.from(v); v.length < 3; )
              v.push(1);
          return new Int32Array(v);
        }, flatten2dArrayTo(m, S) {
          let v = 0;
          for (let h = 0; h < m.length; h++)
            S.set(m[h], v), v += m[h].length;
        }, flatten3dArrayTo(m, S) {
          let v = 0;
          for (let h = 0; h < m.length; h++)
            for (let b = 0; b < m[h].length; b++)
              S.set(m[h][b], v), v += m[h][b].length;
        }, flatten4dArrayTo(m, S) {
          let v = 0;
          for (let h = 0; h < m.length; h++)
            for (let b = 0; b < m[h].length; b++)
              for (let T = 0; T < m[h][b].length; T++)
                S.set(m[h][b][T], v), v += m[h][b][T].length;
        }, flattenTo(m, S) {
          t.isArray(m[0]) ? t.isArray(m[0][0]) ? t.isArray(m[0][0][0]) ? t.flatten4dArrayTo(m, S) : t.flatten3dArrayTo(m, S) : t.flatten2dArrayTo(m, S) : S.set(m);
        }, splitArray(m, S) {
          let v = [];
          for (let h = 0; h < m.length; h += S)
            v.push(new m.constructor(m.buffer, h * 4 + m.byteOffset, S));
          return v;
        }, getAstString(m, S) {
          let v = Array.isArray(m) ? m : m.split(/\\r?\\n/g), h = S.loc.start, b = S.loc.end, T = [];
          if (h.line === b.line)
            T.push(v[h.line - 1].substring(h.column, b.column));
          else {
            T.push(v[h.line - 1].slice(h.column));
            for (let C = h.line; C < b.line; C++)
              T.push(v[C]);
            T.push(v[b.line - 1].slice(0, b.column));
          }
          return T.join(\`
\`);
        }, allPropertiesOf(m) {
          let S = [];
          do
            S.push.apply(S, Object.getOwnPropertyNames(m));
          while (m = Object.getPrototypeOf(m));
          return S;
        }, linesToString(m) {
          return m.length > 0 ? m.join(\`;
\`) + \`;
\` : \`
\`;
        }, warnDeprecated(m, S, v) {
          console.warn(v ? \`You are using a deprecated \${m} "\${S}". It has been replaced with "\${v}". Fixing, but please upgrade as it will soon be removed.\` : \`You are using a deprecated \${m} "\${S}". It has been removed. Fixing, but please upgrade as it will soon be removed.\`);
        }, flipPixels: (m, S, v) => {
          let h = v / 2 | 0, b = S * 4, T = new Uint8ClampedArray(S * 4), C = m.slice(0);
          for (let V = 0; V < h; ++V) {
            let c = V * b, a = (v - V - 1) * b;
            T.set(C.subarray(c, c + b)), C.copyWithin(c, a, a + b), C.set(T, a);
          }
          return C;
        }, erectPackedFloat: (m, S) => m.subarray(0, S), erect2DPackedFloat: (m, S, v) => {
          let h = new Array(v);
          for (let b = 0; b < v; b++) {
            let T = b * S, C = T + S;
            h[b] = m.subarray(T, C);
          }
          return h;
        }, erect3DPackedFloat: (m, S, v, h) => {
          let b = new Array(h);
          for (let T = 0; T < h; T++) {
            let C = new Array(v);
            for (let V = 0; V < v; V++) {
              let c = T * v * S + V * S, a = c + S;
              C[V] = m.subarray(c, a);
            }
            b[T] = C;
          }
          return b;
        }, erectMemoryOptimizedFloat: (m, S) => m.subarray(0, S), erectMemoryOptimized2DFloat: (m, S, v) => {
          let h = new Array(v);
          for (let b = 0; b < v; b++) {
            let T = b * S;
            h[b] = m.subarray(T, T + S);
          }
          return h;
        }, erectMemoryOptimized3DFloat: (m, S, v, h) => {
          let b = new Array(h);
          for (let T = 0; T < h; T++) {
            let C = new Array(v);
            for (let V = 0; V < v; V++) {
              let c = T * v * S + V * S;
              C[V] = m.subarray(c, c + S);
            }
            b[T] = C;
          }
          return b;
        }, erectFloat: (m, S) => {
          let v = new Float32Array(S), h = 0;
          for (let b = 0; b < S; b++)
            v[b] = m[h], h += 4;
          return v;
        }, erect2DFloat: (m, S, v) => {
          let h = new Array(v), b = 0;
          for (let T = 0; T < v; T++) {
            let C = new Float32Array(S);
            for (let V = 0; V < S; V++)
              C[V] = m[b], b += 4;
            h[T] = C;
          }
          return h;
        }, erect3DFloat: (m, S, v, h) => {
          let b = new Array(h), T = 0;
          for (let C = 0; C < h; C++) {
            let V = new Array(v);
            for (let c = 0; c < v; c++) {
              let a = new Float32Array(S);
              for (let k = 0; k < S; k++)
                a[k] = m[T], T += 4;
              V[c] = a;
            }
            b[C] = V;
          }
          return b;
        }, erectArray2: (m, S) => {
          let v = new Array(S), h = S * 4, b = 0;
          for (let T = 0; T < h; T += 4)
            v[b++] = m.subarray(T, T + 2);
          return v;
        }, erect2DArray2: (m, S, v) => {
          let h = new Array(v), b = S * 4;
          for (let T = 0; T < v; T++) {
            let C = new Array(S), V = T * b, c = 0;
            for (let a = 0; a < b; a += 4)
              C[c++] = m.subarray(a + V, a + V + 2);
            h[T] = C;
          }
          return h;
        }, erect3DArray2: (m, S, v, h) => {
          let b = S * 4, T = new Array(h);
          for (let C = 0; C < h; C++) {
            let V = new Array(v);
            for (let c = 0; c < v; c++) {
              let a = new Array(S), k = C * b * v + c * b, A = 0;
              for (let N = 0; N < b; N += 4)
                a[A++] = m.subarray(N + k, N + k + 2);
              V[c] = a;
            }
            T[C] = V;
          }
          return T;
        }, erectArray3: (m, S) => {
          let v = new Array(S), h = S * 4, b = 0;
          for (let T = 0; T < h; T += 4)
            v[b++] = m.subarray(T, T + 3);
          return v;
        }, erect2DArray3: (m, S, v) => {
          let h = S * 4, b = new Array(v);
          for (let T = 0; T < v; T++) {
            let C = new Array(S), V = T * h, c = 0;
            for (let a = 0; a < h; a += 4)
              C[c++] = m.subarray(a + V, a + V + 3);
            b[T] = C;
          }
          return b;
        }, erect3DArray3: (m, S, v, h) => {
          let b = S * 4, T = new Array(h);
          for (let C = 0; C < h; C++) {
            let V = new Array(v);
            for (let c = 0; c < v; c++) {
              let a = new Array(S), k = C * b * v + c * b, A = 0;
              for (let N = 0; N < b; N += 4)
                a[A++] = m.subarray(N + k, N + k + 3);
              V[c] = a;
            }
            T[C] = V;
          }
          return T;
        }, erectArray4: (m, S) => {
          let v = new Array(m), h = S * 4, b = 0;
          for (let T = 0; T < h; T += 4)
            v[b++] = m.subarray(T, T + 4);
          return v;
        }, erect2DArray4: (m, S, v) => {
          let h = S * 4, b = new Array(v);
          for (let T = 0; T < v; T++) {
            let C = new Array(S), V = T * h, c = 0;
            for (let a = 0; a < h; a += 4)
              C[c++] = m.subarray(a + V, a + V + 4);
            b[T] = C;
          }
          return b;
        }, erect3DArray4: (m, S, v, h) => {
          let b = S * 4, T = new Array(h);
          for (let C = 0; C < h; C++) {
            let V = new Array(v);
            for (let c = 0; c < v; c++) {
              let a = new Array(S), k = C * b * v + c * b, A = 0;
              for (let N = 0; N < b; N += 4)
                a[A++] = m.subarray(N + k, N + k + 4);
              V[c] = a;
            }
            T[C] = V;
          }
          return T;
        }, flattenFunctionToString: (m, S) => {
          let { findDependency: v, thisLookup: h, doNotDefine: b } = S, T = S.flattened;
          T || (T = S.flattened = {});
          let C = p.parse(m), V = [], c = 0;
          function a(A) {
            if (Array.isArray(A)) {
              let N = [];
              for (let F = 0; F < A.length; F++)
                N.push(a(A[F]));
              return N.join("");
            }
            switch (A.type) {
              case "Program":
                return a(A.body) + (A.body[0].type === "VariableDeclaration" ? ";" : "");
              case "FunctionDeclaration":
                return \`function \${A.id.name}(\${A.params.map(a).join(", ")}) \${a(A.body)}\`;
              case "BlockStatement": {
                let F = [];
                c += 2;
                for (let L = 0; L < A.body.length; L++) {
                  let K = a(A.body[L]);
                  K && F.push(" ".repeat(c) + K, \`;
\`);
                }
                return c -= 2, \`{
\${F.join("")}}\`;
              }
              case "VariableDeclaration":
                let N = t.normalizeDeclarations(A).map(a).filter((F) => F !== null);
                return N.length < 1 ? "" : \`\${A.kind} \${N.join(",")}\`;
              case "VariableDeclarator":
                return A.init.object && A.init.object.type === "ThisExpression" ? h(A.init.property.name, true) ? \`\${A.id.name} = \${a(A.init)}\` : null : \`\${A.id.name} = \${a(A.init)}\`;
              case "CallExpression": {
                if (A.callee.property.name === "subarray")
                  return \`\${a(A.callee.object)}.\${a(A.callee.property)}(\${A.arguments.map((F) => a(F)).join(", ")})\`;
                if (A.callee.object.name === "gl" || A.callee.object.name === "context")
                  return \`\${a(A.callee.object)}.\${a(A.callee.property)}(\${A.arguments.map((F) => a(F)).join(", ")})\`;
                if (A.callee.object.type === "ThisExpression")
                  return V.push(v("this", A.callee.property.name)), \`\${A.callee.property.name}(\${A.arguments.map((F) => a(F)).join(", ")})\`;
                if (A.callee.object.name) {
                  let F = v(A.callee.object.name, A.callee.property.name);
                  return F === null ? \`\${A.callee.object.name}.\${A.callee.property.name}(\${A.arguments.map((L) => a(L)).join(", ")})\` : (V.push(F), \`\${A.callee.property.name}(\${A.arguments.map((L) => a(L)).join(", ")})\`);
                } else {
                  if (A.callee.object.type === "MemberExpression")
                    return \`\${a(A.callee.object)}.\${A.callee.property.name}(\${A.arguments.map((F) => a(F)).join(", ")})\`;
                  throw new Error("unknown ast.callee");
                }
              }
              case "ReturnStatement":
                return \`return \${a(A.argument)}\`;
              case "BinaryExpression":
                return \`(\${a(A.left)}\${A.operator}\${a(A.right)})\`;
              case "UnaryExpression":
                return A.prefix ? \`\${A.operator} \${a(A.argument)}\` : \`\${a(A.argument)} \${A.operator}\`;
              case "ExpressionStatement":
                return \`\${a(A.expression)}\`;
              case "SequenceExpression":
                return \`(\${a(A.expressions)})\`;
              case "ArrowFunctionExpression":
                return \`(\${A.params.map(a).join(", ")}) => \${a(A.body)}\`;
              case "Literal":
                return A.raw;
              case "Identifier":
                return A.name;
              case "MemberExpression":
                return A.object.type === "ThisExpression" ? h(A.property.name) : A.computed ? \`\${a(A.object)}[\${a(A.property)}]\` : a(A.object) + "." + a(A.property);
              case "ThisExpression":
                return "this";
              case "NewExpression":
                return \`new \${a(A.callee)}(\${A.arguments.map((F) => a(F)).join(", ")})\`;
              case "ForStatement":
                return \`for (\${a(A.init)};\${a(A.test)};\${a(A.update)}) \${a(A.body)}\`;
              case "AssignmentExpression":
                return \`\${a(A.left)}\${A.operator}\${a(A.right)}\`;
              case "UpdateExpression":
                return \`\${a(A.argument)}\${A.operator}\`;
              case "IfStatement":
                return \`if (\${a(A.test)}) \${a(A.consequent)}\`;
              case "ThrowStatement":
                return \`throw \${a(A.argument)}\`;
              case "ObjectPattern":
                return A.properties.map(a).join(", ");
              case "ArrayPattern":
                return A.elements.map(a).join(", ");
              case "DebuggerStatement":
                return "debugger;";
              case "ConditionalExpression":
                return \`\${a(A.test)}?\${a(A.consequent)}:\${a(A.alternate)}\`;
              case "Property":
                if (A.kind === "init")
                  return a(A.key);
            }
            throw new Error(\`unhandled ast.type of \${A.type}\`);
          }
          let k = a(C);
          if (V.length > 0) {
            let A = [];
            for (let N = 0; N < V.length; N++) {
              let F = V[N];
              T[F] || (T[F] = true), F && A.push(t.flattenFunctionToString(F, S) + \`
\`);
            }
            return A.join("") + k;
          }
          return k;
        }, normalizeDeclarations: (m) => {
          if (m.type !== "VariableDeclaration")
            throw new Error('Ast is not of type "VariableDeclaration"');
          let S = [];
          for (let v = 0; v < m.declarations.length; v++) {
            let h = m.declarations[v];
            if (h.id && h.id.type === "ObjectPattern" && h.id.properties) {
              let { properties: b } = h.id;
              for (let T = 0; T < b.length; T++) {
                let C = b[T];
                if (C.value.type === "ObjectPattern" && C.value.properties)
                  for (let V = 0; V < C.value.properties.length; V++) {
                    let c = C.value.properties[V];
                    if (c.type === "Property")
                      S.push({ type: "VariableDeclarator", id: { type: "Identifier", name: c.key.name }, init: { type: "MemberExpression", object: { type: "MemberExpression", object: h.init, property: { type: "Identifier", name: C.key.name }, computed: false }, property: { type: "Identifier", name: c.key.name }, computed: false } });
                    else
                      throw new Error("unexpected state");
                  }
                else if (C.value.type === "Identifier")
                  S.push({ type: "VariableDeclarator", id: { type: "Identifier", name: C.value && C.value.name ? C.value.name : C.key.name }, init: { type: "MemberExpression", object: h.init, property: { type: "Identifier", name: C.key.name }, computed: false } });
                else
                  throw new Error("unexpected state");
              }
            } else if (h.id && h.id.type === "ArrayPattern" && h.id.elements) {
              let { elements: b } = h.id;
              for (let T = 0; T < b.length; T++) {
                let C = b[T];
                if (C.type === "Identifier")
                  S.push({ type: "VariableDeclarator", id: { type: "Identifier", name: C.name }, init: { type: "MemberExpression", object: h.init, property: { type: "Literal", value: T, raw: T.toString(), start: C.start, end: C.end }, computed: true } });
                else
                  throw new Error("unexpected state");
              }
            } else
              S.push(h);
          }
          return S;
        }, splitHTMLImageToRGB: (m, S) => {
          let v = m.createKernel(function(V) {
            return V[this.thread.y][this.thread.x].r * 255;
          }, { output: [S.width, S.height], precision: "unsigned", argumentTypes: { a: "HTMLImage" } }), h = m.createKernel(function(V) {
            return V[this.thread.y][this.thread.x].g * 255;
          }, { output: [S.width, S.height], precision: "unsigned", argumentTypes: { a: "HTMLImage" } }), b = m.createKernel(function(V) {
            return V[this.thread.y][this.thread.x].b * 255;
          }, { output: [S.width, S.height], precision: "unsigned", argumentTypes: { a: "HTMLImage" } }), T = m.createKernel(function(V) {
            return V[this.thread.y][this.thread.x].a * 255;
          }, { output: [S.width, S.height], precision: "unsigned", argumentTypes: { a: "HTMLImage" } }), C = [v(S), h(S), b(S), T(S)];
          return C.rKernel = v, C.gKernel = h, C.bKernel = b, C.aKernel = T, C.gpu = m, C;
        }, splitRGBAToCanvases: (m, S, v, h) => {
          let b = m.createKernel(function(c) {
            let a = c[this.thread.y][this.thread.x];
            this.color(a.r / 255, 0, 0, 255);
          }, { output: [v, h], graphical: true, argumentTypes: { v: "Array2D(4)" } });
          b(S);
          let T = m.createKernel(function(c) {
            let a = c[this.thread.y][this.thread.x];
            this.color(0, a.g / 255, 0, 255);
          }, { output: [v, h], graphical: true, argumentTypes: { v: "Array2D(4)" } });
          T(S);
          let C = m.createKernel(function(c) {
            let a = c[this.thread.y][this.thread.x];
            this.color(0, 0, a.b / 255, 255);
          }, { output: [v, h], graphical: true, argumentTypes: { v: "Array2D(4)" } });
          C(S);
          let V = m.createKernel(function(c) {
            let a = c[this.thread.y][this.thread.x];
            this.color(255, 255, 255, a.a / 255);
          }, { output: [v, h], graphical: true, argumentTypes: { v: "Array2D(4)" } });
          return V(S), [b.canvas, T.canvas, C.canvas, V.canvas];
        }, getMinifySafeName: (m) => {
          try {
            let S = p.parse(\`const value = \${m.toString()}\`), { init: v } = S.body[0].declarations[0];
            return v.body.name || v.body.body[0].argument.name;
          } catch {
            throw new Error("Unrecognized function type.  Please use \`() => yourFunctionVariableHere\` or function() { return yourFunctionVariableHere; }");
          }
        }, sanitizeName: function(m) {
          return i.test(m) && (m = m.replace(i, "S_S")), u.test(m) ? m = m.replace(u, "U_U") : x2.test(m) && (m = m.replace(x2, "u_u")), m;
        } }, i = /\\$/, u = /__/, x2 = /_/, w = t.getSystemEndianness();
        y.exports = { utils: t };
      }, { "./input": 110, "./texture": 113, acorn: 1 }] }, {}, [107])(107);
    });
  });
  var Ni = ti(_t());
  function ii(M, I) {
    return M + I;
  }
  function ni(M, I) {
    return M - I;
  }
  function si(M, I) {
    return M * I;
  }
  function ri(M, I) {
    return M / I;
  }
  function ai(M, I, $, o) {
    return [M + $, I + o];
  }
  function oi(M, I, $, o) {
    return [M - $, I - o];
  }
  function ui(M, I, $, o) {
    return [M * $ - I * o, M * o + I * $];
  }
  function li(M, I) {
    let $ = Math.exp(M);
    return [$ * Math.cos(I), $ * Math.sin(I)];
  }
  function xe(M, I) {
    return Math.sqrt(M * M + I * I);
  }
  function hi(M) {
    return 0 - M;
  }
  function ci(M) {
    let I = Math.sqrt(M);
    for (var $ = 3; $ <= I; ) {
      if (M % $ === 0)
        return $;
      $ += 2;
    }
  }
  function Je(M, I) {
    for (var $ = 0, o = 0; o < I; o++)
      $ += M[o];
    return $ / I;
  }
  function Qe(M, I, $) {
    for (var o = 0, y = 0; y < $; y++)
      o += (M[y] - I) * (M[y] - I);
    return Math.sqrt(o);
  }
  function pi(M, I, $) {
    for (var o = 0, y = 0, E = 0; E < $; E++)
      y = M[E] - I, o += y * y;
    return o / $;
  }
  function fi(M, I, $) {
    for (var o = 0, y = 0, E = 0; E < $; E++)
      y = M[E] - I, o += y * y;
    return Math.sqrt(o / $);
  }
  function qe(M, I, $, o, y, E, p, g) {
    for (var f = 0, l = 0; l < p; l++) {
      var n = l + g, s = 0;
      n < p && (s = o[n]), f += (M[l] - I) * (s - y);
    }
    return f / ($ * E);
  }
  function di(M, I, $) {
    for (var o = 0, y = 0; y < I; y++)
      o += Math.exp(M[y]);
    return Math.exp(M[$]) / o;
  }
  function $e(M, I, $) {
    for (var o = 0, y = 0, E = 1 / I, p = 6.28318530718 * $ * E, g = 0; g < I; g++) {
      var f = p * g;
      o = o + M[g] * Math.cos(f), y = y - M[g] * Math.sin(f);
    }
    return [o * E, y * E];
  }
  function et(M, I, $, o) {
    for (var y = 0, E = 0, p = 1 / I, g = 6.28318530718 * $ * p, f = 0; f < I; f++) {
      var l = g * f;
      y = y + M[f + (I - 1) * o] * Math.cos(l), E = E - M[f + (I - 1) * o] * Math.sin(l);
    }
    return [y * p, E * p];
  }
  function Me(M, I, $, o) {
    var y = 0, E = 0, p = 1 / I, g = 6.28318530718 * $ * p, f = 1, l = 0, n = o * 0.25;
    if ($ <= n)
      for (; $ <= n; )
        n = n * 0.5, f += 1;
    for (var s = 0; s < I; s += f) {
      var t = s;
      t > I && (t = I);
      var i = g * t;
      y = y + M[t] * Math.cos(i), E = E - M[t] * Math.sin(i), l += 1;
    }
    return [y / l, E / l];
  }
  function wt(M, I, $, o, y) {
    var E = 0, p = 0, g = 1 / I, f = 6.28318530718 * $ * g, l = 1, n = 0, s = y * 0.25;
    if ($ <= s)
      for (; $ <= s; )
        s = s * 0.5, l += 1;
    for (var t = 0; t < I; t += l) {
      var i = t;
      i > I && (i = I);
      var u = f * i;
      E = E + M[i + (I - 1) * o] * Math.cos(u), p = p - M[i + (I - 1) * o] * Math.sin(u), n += 1;
    }
    return [E / n, p / n];
  }
  function Be(M, I, $) {
    for (var o = 0, y = 0, E = 1 / I, p = 6.28318530718 * $ * E, g = 0; g < I; g++) {
      var f = p * g;
      o = o + M[g] * Math.cos(f), y = M[g] * Math.sin(f) - y;
    }
    return [o * E, y * E];
  }
  function Et(M, I, $, o) {
    for (var y = 0, E = 0, p = 1 / I, g = 6.28318530718 * $ * p, f = 0; f < I; f++) {
      var l = g * f;
      y = y + M[f + (I - 1) * o] * Math.cos(l), E = M[f + (I - 1) * o] * Math.sin(l) - E;
    }
    return [y * p, E * p];
  }
  function We(M, I, $, o) {
    var y = 0, E = 0, p = 1 / I, g = 6.28318530718 * $ * p, f = 1, l = 0, n = o * 0.25;
    if ($ <= n)
      for (; $ <= n; )
        n = n * 0.5, f += 1;
    for (var s = 0; s < I; s += f) {
      var t = s;
      t > I && (t = I);
      var i = g * t;
      y = y + M[t] * Math.cos(i), E = M[t] * Math.sin(i) - E, l += 1;
    }
    return [y / l, E / l];
  }
  function It(M, I, $, o, y) {
    var E = 0, p = 0, g = 1 / I, f = 6.28318530718 * $ * g, l = 1, n = 0, s = y * 0.25;
    if ($ <= s)
      for (; $ <= s; )
        s = s * 0.5, l += 1;
    for (var t = 0; t < I; t += l) {
      var i = t;
      i > I && (i = I);
      var u = f * i;
      E = E + M[i + (I - 1) * o] * Math.cos(u), p = M[i + (I - 1) * o] * Math.sin(u) - p, n += 1;
    }
    return [E / n, p / n];
  }
  function mi(M, I) {
    var $ = Math.floor(this.thread.x / I) * 2, o = this.thread.x - Math.floor(this.thread.x / I) * I, y = Je(M[$], I), E = Je(M[$ + 1], I), p = Qe(M[$], y, I), g = Qe(M[$ + 1], E, I), f = qe(M[$], y, p, M[$ + 1], E, g, I, o);
    return f;
  }
  function xi(M, I, $, o) {
    var y = Math.floor(this.thread.x / I) * 2, E = this.thread.x - Math.floor(this.thread.x / I) * I, p = $[y], g = $[y + 1], f = o[y], l = o[y + 1], n = qe(M[y], p, f, M[y + 1], g, l, I, E);
    return n;
  }
  function gi(M, I, $) {
    var o = $e(M, I, this.thread.x);
    return xe(o[0], o[1]) * $;
  }
  function yi(M, I, $) {
    var o = Be(M, I, this.thread.x);
    return xe(o[0], o[1]) * $;
  }
  function bi(M, I, $, o) {
    var y = Me(M, I, this.thread.x, o);
    return xe(y[0], y[1]) * $;
  }
  function Ti(M, I, $, o) {
    var y = We(M, I, this.thread.x, o);
    return xe(y[0], y[1]) * $;
  }
  function vi(M, I) {
    var $ = this.output.x, o = $e(M[this.thread.y], $, this.thread.x);
    return xe(o[0], o[1]) * I;
  }
  function Si(M, I, $) {
    var o = [0, 0];
    if (this.thread.x <= I)
      o = $e(M, I, this.thread.x);
    else {
      var y = Math.floor(this.thread.x / I);
      o = et(M, I, this.thread.x - y * I, y);
    }
    return xe(o[0], o[1]) * $;
  }
  function _i(M, I, $, o) {
    var y = [0, 0];
    if (this.thread.x <= I)
      y = Me(M, I, this.thread.x, o);
    else {
      var E = Math.floor(this.thread.x / I);
      y = wt(M, I, this.thread.x - E * I, E, o);
    }
    return xe(y[0], y[1]) * $;
  }
  function wi(M, I, $, o, y) {
    var E = [0, 0], p = this.thread.x / I * (o - $) + $;
    return E = $e(M, I, p), xe(E[0], E[1]) * y;
  }
  function Ei(M, I, $, o, y) {
    var E = [0, 0], p = this.thread.x / I * (o - $) + $;
    return E = Me(M, I, p), xe(E[0], E[1]) * y;
  }
  function Ii(M, I, $, o, y) {
    var E = [0, 0], p = this.thread.x / I * (o - $) + $;
    return E = Be(M, I, p), xe(E[0], E[1]) * y;
  }
  function ki(M, I, $, o, y) {
    var E = [0, 0], p = this.thread.x / I * (o - $) + $;
    return E = We(M, I, p), xe(E[0], E[1]) * y;
  }
  function Ai(M, I, $, o, y) {
    var E = [0, 0];
    if (this.thread.x < I) {
      var p = this.thread.x / I * (o - $) + $;
      E = $e(M, I, p);
    } else {
      var g = Math.floor(this.thread.x / I), p = (this.thread.x - g * I) / I * (o - $) + $;
      E = et(M, I, p - g * I, g);
    }
    return xe(E[0], E[1]) * y;
  }
  function Di(M, I, $, o, y) {
    var E = [0, 0];
    if (this.thread.x < I) {
      var p = this.thread.x / I * (o - $) + $;
      E = Me(M, I, p, I);
    } else {
      var g = Math.floor(this.thread.x / I), p = (this.thread.x - g * I) / I * (o - $) + $;
      E = wt(M, I, p - g * I, g, I);
    }
    return xe(E[0], E[1]) * y;
  }
  function Ci(M, I, $, o, y) {
    var E = [0, 0];
    if (this.thread.x < I) {
      var p = this.thread.x / I * (o - $) + $;
      E = Be(M, I, p);
    } else {
      var g = Math.floor(this.thread.x / I), p = (this.thread.x - g * I) / I * (o - $) + $;
      E = Et(M, I, p - g * I, g);
    }
    return xe(E[0] * 2, E[1] * 2) * y;
  }
  function Fi(M, I, $, o, y) {
    var E = [0, 0];
    if (this.thread.x < I) {
      var p = this.thread.x / I * (o - $) + $;
      E = We(M, I, p);
    } else {
      var g = Math.floor(this.thread.x / I), p = (this.thread.x - g * I) / I * (o - $) + $;
      E = It(M, I, p - g * I, g);
    }
    return xe(E[0] * 2, E[1] * 2) * y;
  }
  function $i(M, I, $, o) {
    for (var y = $ * Math.floor(this.thread.x / I), E = M[y][this.thread.x], p = 0; p < $; p++)
      E *= M[p][this.thread.x];
    return E * o;
  }
  function Li(M, I, $, o, y) {
    let E = (Math.sqrt(y) - 1) / 2, p = 2 * E + 1, g = 0, f = 0, l = 0, n = -E, s = 0;
    for (; n <= E; ) {
      if (this.thread.x + n < 0 || this.thread.x + n >= I) {
        n++;
        continue;
      }
      let t = -E;
      for (; t <= E; ) {
        if (this.thread.y + t < 0 || this.thread.y + t >= $) {
          t++;
          continue;
        }
        s = (t + E) * p + n + E;
        let i = o[s], u = M[this.thread.y + n][this.thread.x + t];
        g += u.r * i, f += u.g * i, l += u.b * i, t++;
      }
      n++;
    }
    this.color(g, f, l);
  }
  function Ri(M, I, $, o, y, E) {
    let p = 0, g = 0, f = 0;
    for (var l = 0; l < E; l++) {
      let n = y[l], s = (Math.sqrt(n) - 1) / 2, t = 2 * s + 1, i = -s, u = 0;
      for (; i <= s; ) {
        if (this.thread.x + i < 0 || this.thread.x + i >= I) {
          i++;
          continue;
        }
        let x2 = -s;
        for (; x2 <= s; ) {
          if (this.thread.y + x2 < 0 || this.thread.y + x2 >= $) {
            x2++;
            continue;
          }
          u = (x2 + s) * t + i + s;
          let w = o[l][u], m = M[this.thread.y + i][this.thread.x + x2];
          p += m.r * w, g += m.g * w, f += m.b * w, x2++;
        }
        i++;
      }
    }
    this.color(p, g, f);
  }
  function Mi(M) {
    return M[this.thread.y][this.thread.x];
  }
  var me = { correlogramsKern: mi, correlogramsPCKern: xi, dftKern: gi, idftKern: yi, fftKern: bi, ifftKern: Ti, dft_windowedKern: wi, idft_windowedKern: Ii, fft_windowedKern: Ei, ifft_windowedKern: ki, listdft2DKern: vi, listdft1DKern: Si, listfft1DKern: _i, listfft1D_windowedKern: Di, listdft1D_windowedKern: Ai, listidft1D_windowedKern: Ci, listifft1D_windowedKern: Fi, bulkArrayMulKern: $i, multiImgConv2DKern: Ri, ImgConv2DKern: Li, transpose2DKern: Mi };
  var kt = [ii, ni, si, ri, ai, oi, ui, li, xe, hi, ci, Je, Qe, pi, fi, qe, di, $e, et, Be, Et, Me, We, It];
  function fe(M, I, $ = { setDynamicOutput: true, setDynamicArguments: true, setPipeline: true, setImmutable: true, setGraphical: false }) {
    let o = M.createKernel(I);
    return $.setDynamicOutput && o.setDynamicOutput(true), $.output && o.setOutput($.output), $.setDynamicArguments && o.setDynamicArguments(true), $.setPipeline && o.setPipeline(true), $.setImmutable && o.setImmutable(true), $.setGraphical && o.setGraphical(true), o;
  }
  function Vi(M, I, $ = { output: [300, 300], setDynamicArguments: true, setDynamicOutput: true, setPipeline: false, setImmutable: true, setGraphical: true }, o) {
    let y = fe(M, I, $), E = y.canvas;
    return typeof o == "string" ? document.getElementById(toAppend).appendChild(E) : o ? toAppend.appendChild(E) : document.body.appendChild(E), y;
  }
  var At = class {
    constructor(I = new GPU()) {
      this.gpu = I, this.kernels = /* @__PURE__ */ new Map(), this.kernel, this.PI = 3.141592653589793, this.SQRT1_2 = 0.7071067811865476, this.addFunctions(), this.imgkernels = { edgeDetection: [-1, -1, -1, -1, 8, -1, -1, -1, -1], boxBlur: [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9], sobelLeft: [1, 0, -1, 2, 0, -2, 1, 0, -1], sobelRight: [-1, 0, 1, -2, 0, 2, -1, 0, 1], sobelTop: [1, 2, 1, 0, 0, 0, -1, -2, -1], sobelBottom: [-1, 2, 1, 0, 0, 0, 1, 2, 1], identity: [0, 0, 0, 0, 1, 0, 0, 0, 0], gaussian3x3: [1, 2, 1, 2, 4, 2, 1, 2, 1], guassian7x7: [0, 0, 0, 5, 0, 0, 0, 0, 5, 18, 32, 18, 5, 0, 0, 18, 64, 100, 64, 18, 0, 5, 32, 100, 100, 100, 32, 5, 0, 18, 64, 100, 64, 18, 0, 0, 5, 18, 32, 18, 5, 0, 0, 0, 0, 5, 0, 0, 0], emboss: [-2, -1, 0, -1, 1, 1, 0, 1, 2], sharpen: [0, -1, 0, -1, 5, -1, 0, -1, 0] };
    }
    addFunction(I = function() {
    }) {
      this.gpu.addFunction(I);
    }
    addKernel(I = "", $ = function() {
    }, o) {
      return this.kernels.get(I) ? (console.error("Kernel already exists"), false) : (this.kernels.set(I, fe(this.gpu, $, o)), true);
    }
    addCanvasKernel(I, $, o, y) {
      if (this.kernels.get(I))
        return console.error("Kernel already exists"), false;
      {
        let p = Vi(this.gpu, $, o, y);
        return this.kernels.set(I, p), p;
      }
    }
    combineKernels(I, $ = [], o = function() {
    }) {
      if (this.kernels.get(I))
        return console.error("Kernel already exists"), false;
      {
        $.forEach((p, g) => {
          if (typeof p == "string") {
            let f = this.kernels.get(p);
            if (f)
              $[g] = f;
            else
              return false;
          } else
            typeof p == "function" && (this.kernels.get(p.name) || this.addKernel(p.name, p));
        });
        let E = this.gpu.combineKernels(...$, o);
        return this.kernels.set(I, E), E;
      }
    }
    callKernel(I = "", $ = []) {
      let o, y = this.kernels.get(I);
      return y ? (o = y(...$), o) : (console.error("Kernel not found"), false);
    }
    callCanvasKernel(I = "", $ = [], o = []) {
      let y, E = this.kernels.get(I);
      return E ? (o.length === 2 && E.setOutput(o), y = E(...$), y) : (console.error("Kernel not found"), false);
    }
    hasKernel(I = "") {
      return !!this.kernels.get(I);
    }
    addFunctions() {
      kt.forEach((y) => this.gpu.addFunction(y)), this.correlograms = fe(this.gpu, me.correlogramsKern), this.correlogramsPC = fe(this.gpu, me.correlogramsPCKern), this.dft = fe(this.gpu, me.dftKern), this.idft = fe(this.gpu, me.idftKern), this.dft_windowed = fe(this.gpu, me.dft_windowedKern), this.idft_windowed = fe(this.gpu, me.idft_windowedKern), this.fft = fe(this.gpu, me.fftKern), this.ifft = fe(this.gpu, me.ifftKern), this.fft_windowed = fe(this.gpu, me.fft_windowedKern), this.ifft_windowed = fe(this.gpu, me.ifft_windowedKern), this.listdft2D = fe(this.gpu, me.listdft2DKern), this.listdft1D = fe(this.gpu, me.listdft1DKern), this.listdft1D_windowed = fe(this.gpu, me.listdft1D_windowedKern), this.listfft1D = fe(this.gpu, me.listfft1DKern), this.listfft1D_windowed = fe(this.gpu, me.listfft1D_windowedKern), this.listidft1D_windowed = fe(this.gpu, me.listidft1D_windowedKern), this.listifft1D_windowed = fe(this.gpu, me.listifft1D_windowedKern), this.bulkArrayMul = fe(this.gpu, me.bulkArrayMulKern), [{ name: "correlograms", krnl: this.correlograms }, { name: "correlogramsPC", krnl: this.correlogramsPC }, { name: "dft", krnl: this.dft }, { name: "idft", krnl: this.idft }, { name: "dft_windowed", krnl: this.idft_windowed }, { name: "fft", krnl: this.fft }, { name: "ifft", krnl: this.ifft }, { name: "fft_windowed", krnl: this.fft_windowed }, { name: "ifft_windowed", krnl: this.ifft_windowed }, { name: "listdft2D", krnl: this.listdft2D }, { name: "listdft1D", krnl: this.listdft1D }, { name: "listdft1D_windowed", krnl: this.listdft1D_windowed }, { name: "listfft1D", krnl: this.listfft1D }, { name: "listfft1D_windowed", krnl: this.listfft1D_windowed }, { name: "listidft1D_windowed", krnl: this.listidft1D_windowed }, { name: "listifft1D_windowed", krnl: this.listifft1D_windowed }, { name: "bulkArrayMul", krnl: this.bulkArrayMul }].forEach((y) => {
        this.kernels.set(y.name, y);
      });
      let $ = (y, E, p, g, f) => {
        var l = this.fft_windowed(y, E, p, g, f, 0), n = this.ifft_windowed(l, E, p, g, f);
        return n;
      }, o = (y, E, p, g, f) => {
        var l = this.listdft1D_windowed(y, E, p, g, f, new Array(Math.ceil(y / E)).fill(0)), n = this.listifft1D_windowed(l, E, p, g, f);
        return n;
      };
      this.gpuCoherence = (y, E, p, g, f) => {
        var l = this.correlograms(y), n = this.listfft1D_windowed(l, E, p, g, f, new Array(Math.ceil(y / E)).fill(0)), s = this.bulkArrayMul(n, E, 5, 1);
        return s;
      };
    }
    gpuXCors(I, $ = false, o = false) {
      var y;
      if ($ === true) {
        var E = [], p = [];
        I.forEach((u, x2) => {
          E.push(u.reduce((w, m) => m += w) / u.length), p.push(Math.sqrt(E[x2].reduce((w, m) => w += Math.pow(m - mean1, 2))));
        });
        for (var g = [], f = [], l = [], n = 0; n < I.length; n++)
          for (var s = n; s < I.length; s++)
            l.push(...I[n], ...I[s]), g.push(E[n], E[s]), f.push(p[n], p[s]);
        this.correlogramsPC.setOutput([l.length]), this.correlogramsPC.setLoopMaxIterations(I[0].length * 2), y = this.correlogramsPC(l, I[0].length, g, f);
      } else {
        for (var l = [], n = 0; n < I.length; n++)
          for (var s = n; s < I.length; s++)
            l.push(...I[n], ...I[s]);
        this.correlograms.setOutput([l.length]), this.correlograms.setLoopMaxIterations(I[0].length * 2), y = this.correlograms(l, I[0].length);
      }
      if (o === true)
        return y;
      var t = y.toArray();
      y.delete();
      for (var i = [], n = 0; n < I.length; n++)
        i.push(t.splice(0, I[0].length));
      return i;
    }
    gpuDFT(I, $, o = 1, y = false) {
      var E = I.length, p = E / $;
      this.dft.setOutput([I.length]), this.dft.setLoopMaxIterations(E);
      var g = this.dft(I, E, o), f = null;
      if (y === false) {
        var l = this.makeFrequencyDistribution(E, p), n = g.toArray();
        return g.delete(), [l, this.orderMagnitudes(n)];
      } else {
        var s = g;
        return g.delete(), s;
      }
    }
    MultiChannelDFT(I, $, o = 1, y = false) {
      var E = [];
      I.forEach((i) => {
        E.push(...i);
      });
      var p = I[0].length, g = p / $;
      this.listdft1D.setOutput([E.length]), this.listdft1D.setLoopMaxIterations(p);
      var f = this.listdft1D(E, p, o);
      if (y === false) {
        var l = [], n = this.makeFrequencyDistribution(p, g);
        E = f.toArray();
        for (var s = 0; s < E.length; s += p)
          l.push(this.orderMagnitudes([...E.slice(s, s + p)]));
        return f.delete(), [n, l];
      } else {
        var t = f;
        return f.delete(), t;
      }
    }
    MultiChannelDFT_Bandpass(I = [], $, o, y, E = 1, p = false) {
      var g = [];
      I.forEach((i) => {
        g.push(...i);
      });
      var f = y * 2, l = I[0].length, n = l / $;
      this.listdft1D_windowed.setOutput([g.length]), this.listdft1D_windowed.setLoopMaxIterations(l);
      var s = this.listdft1D_windowed(g, n, o, f, E);
      if (p === true)
        return s;
      g = s.toArray(), s.delete();
      var t = this.bandPassWindow(o, y, n);
      return [t, this.orderBPMagnitudes(g, $, n, l)];
    }
    gpuFFT(I, $, o = 1, g, E = false) {
      var p = I.length, g = p / $;
      this.fft.setOutput([I.length]), this.fft.setLoopMaxIterations(p);
      var f = this.fft(I, p, o, g), l = null;
      if (E === false) {
        var n = this.makeFrequencyDistribution(p, g), s = f.toArray();
        return f.delete(), [n, this.orderMagnitudes(s)];
      } else {
        var t = f;
        return f.delete(), t;
      }
    }
    MultiChannelFFT(I, $, o = 1, y = false) {
      var E = [];
      I.forEach((i) => {
        E.push(...i);
      });
      var p = I[0].length, g = p / $;
      this.listfft1D.setOutput([E.length]), this.listfft1D.setLoopMaxIterations(p);
      var f = this.listfft1D(E, p, o, g);
      if (y === false) {
        var l = [], n = this.makeFrequencyDistribution(p, g);
        E = f.toArray();
        for (var s = 0; s < E.length; s += p)
          l.push(this.orderMagnitudes([...E.slice(s, s + p)]));
        return f.delete(), [n, l];
      } else {
        var t = f;
        return f.delete(), t;
      }
    }
    MultiChannelFFT_Bandpass(I = [], $, o, y, E = 1, p = false) {
      var g = [];
      I.forEach((i) => {
        g.push(...i);
      });
      var f = y * 2, l = I[0].length, n = l / $;
      this.listfft1D_windowed.setOutput([g.length]), this.listfft1D_windowed.setLoopMaxIterations(l);
      var s = this.listfft1D_windowed(g, n, o, f, E);
      if (p === true)
        return s;
      g = s.toArray(), s.delete();
      var t = this.bandPassWindow(o, y, n);
      return [t, this.orderBPMagnitudes(g, $, n, l)];
    }
    orderMagnitudes(I) {
      return [...I.slice(Math.ceil(I.length * 0.5), I.length), ...I.slice(0, Math.ceil(I.length * 0.5))];
    }
    makeFrequencyDistribution(I, $) {
      for (var o = I, y = $ / o, E = [], p = -o / 2; p < o / 2; p++) {
        var g = p * y;
        E.push(g);
      }
      return E;
    }
    orderBPMagnitudes(I, $, o, y) {
      for (var E = [], p = 0; p < I.length; p += y)
        E.push([...I.slice(p, Math.ceil(y * 0.5 + p))]);
      var g = [], f = 1 / o;
      return $ > 1 ? (E.forEach((l, n) => {
        g.push([]);
        for (var s = 1 / Math.max(...l), t = 0; t < l.length; t++)
          if (t == 0)
            g[n] = l.slice(t, Math.floor(o)), t = Math.floor(o);
          else {
            var i = t - Math.floor(Math.floor(t * f) * o) - 1;
            g[n][i] = g[n][i] * l[t - 1] * s;
          }
        g[n] = [...g[n].slice(0, Math.ceil(g[n].length * 0.5))];
      }), g) : E;
    }
    bandPassWindow(I, $, o, y = true) {
      var E = $ * 2;
      let p = (E - I) / o;
      var g = [];
      if (y === true)
        for (var f = 0; f < Math.ceil(0.5 * o); f += p)
          g.push(I + (E - I) * f / o);
      else
        for (var f = -Math.ceil(0.5 * o); f < Math.ceil(0.5 * o); f += p)
          g.push(I + (E - I) * f / o);
      return g;
    }
  };

  // ../GraphServiceRouter/node_modules/brainsatplay-math/dist/index.esm.js
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
  var __publicField = (obj, key, value2) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
    return value2;
  };
  var _Math2 = class {
    constructor() {
    }
    static genSineWave(freq = 20, peakAmp = 1, nSec = 1, fs = 512, freq2 = 0, peakAmp2 = 1) {
      var sineWave = [];
      var t = [];
      var increment = 1 / fs;
      for (var ti2 = 0; ti2 < nSec; ti2 += increment) {
        var amplitude = Math.sin(2 * Math.PI * freq * ti2) * peakAmp;
        amplitude += Math.sin(2 * Math.PI * freq2 * ti2) * peakAmp2;
        sineWave.push(amplitude);
        t.push(ti2);
      }
      return [t, sineWave];
    }
    static getSineAmplitude(frequency = 20, peakAmplitude = 1, ti2 = 0, tOffset = 0) {
      return Math.sin(this.TWO_PI * frequency * ti2 + tOffset) * peakAmplitude;
    }
    static mean(arr) {
      var sum = arr.reduce((prev, curr) => curr += prev);
      return sum / arr.length;
    }
    static mode(arr) {
      return arr.sort((a, b) => arr.filter((v) => v === a).length - arr.filter((v) => v === b).length).pop();
    }
    static std(arr, mean = void 0) {
      let avg = mean;
      if (!mean)
        avg = this.mean(arr);
      let summed = 0;
      for (let i = 0; i < arr.length; i++) {
        let subbed = arr[i] - avg;
        summed += subbed * subbed;
      }
      return Math.sqrt(summed / arr.length);
    }
    static relError(actual = [], forecast = [], abs = true) {
      if (actual.length !== forecast.length)
        throw new Error("Input arrays of same length!");
      let i = actual.length;
      let d = new Array(actual.length);
      for (let j = 0; j < i; j++) {
        let dd = (actual[j] - forecast[j]) / actual[j];
        if (abs)
          dd = Math.abs(dd);
        d[j] = dd;
      }
      return d;
    }
    static informationEntropy(probabilities = []) {
      let len = probabilities.length;
      let entropy = new Array(len);
      for (let i = 0; i < len; i++) {
        let ent = probabilities[i] * Math.log(probabilities[i]);
        if (isNaN(ent))
          ent = 0;
        entropy[i] = ent;
      }
      return entropy;
    }
    static zscore(arr) {
      let mean = this.mean(arr);
      let std = this.std(arr, mean);
      let z = new Array().length(arr.length);
      for (let i = 0; i < arr.length; i++) {
        z[i] = (arr[i] - mean) / std;
      }
      return z;
    }
    static variance(arr) {
      var mean = this.mean(arr);
      return arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
    }
    static dot(vec1, vec2) {
      var dot = 0;
      for (var i = 0; i < vec1.length; i++) {
        dot += vec1[i] * vec2[i];
      }
      return dot;
    }
    static cross3D(vec1, vec2) {
      return [
        vec1[1] * vec2[2] - vec1[2] * vec2[1],
        vec1[2] * vec2[0] - vec1[0] * vec2[2],
        vec1[0] * vec2[1] - vec1[1] * vec2[0]
      ];
    }
    static magnitude(vec) {
      var sqrd = 0;
      vec.forEach((c) => {
        sqrd += c * c;
      });
      return Math.sqrt(sqrd);
    }
    static distance(point1, point2) {
      var dsqrd = 0;
      point1.forEach((c, i) => {
        dsqrd += (point2[i] - c) * (point2[i] - c);
      });
      return Math.sqrt(dsqrd);
    }
    static midpoint(point1 = [1, 2, 3], point2 = [3, 4, 5]) {
      return point1.map((c, i) => {
        return (c + point2[i]) * 0.5;
      });
    }
    static normalize(vec) {
      var norm = 0;
      norm = this.magnitude(vec);
      var vecn = new Array(vec.length);
      vec.forEach((c, i) => {
        vecn[i] = c * norm;
      });
      return vecn;
    }
    static normalizeSeries(arr = [], fromZero = true) {
      let max = Math.max(...arr);
      let min = Math.min(...arr);
      if (fromZero == false) {
        max = Math.max(max, Math.abs(min));
        min = 0;
      }
      if (max - min === 0) {
        min = 0;
        if (max === 0)
          max = 1e-13;
      }
      return arr.map((v) => (v - min) / (max - min));
    }
    static quadraticFormula(a, b, c) {
      let bbmac4 = Math.sqrt(b * b - 4 * a * c);
      if (!isNaN(bbmac4))
        return ["complex", "complex"];
      let _a2 = 1 / (2 * a);
      if (bbmac4 === 0)
        return [b * _a2];
      let nb = -b;
      return [(nb + bbmac4) * _a2, (nb - bbmac4) * _a2];
    }
    static newtonsMethod(foo = (x2) => {
      return Math.pow(x2, 5) + x2 * x2 - x2 - 0.2;
    }, start = 0, end = 1, precision = 0.01, attempts = 10) {
      let roots = [];
      for (let i = 0; i < attempts; i++) {
        let seedx = Math.random() * (end - start);
        let guess = foo(seedx);
        let guess2 = foo(seedx + precision);
        let slope = (guess2 - guess) / precision;
        let xn = seedx + precision;
        while (Math.abs(slope) > precision) {
          let step = -guess / slope2;
          let xn12 = xn + step;
          guess = guess2;
          guess2 = foo(xn12);
          let slope2 = (guess2 - guess) / (xn12 - xn);
        }
        let idx;
        let f = roots.find((root, i2) => {
          if (Math.abs(xn1 - root) < precision) {
            idx = i2;
            return true;
          }
        });
        if (f)
          roots[idx] = (xn1 + f) * 0.5;
        else
          roots.push(xn1);
      }
      return roots;
    }
    static makeVec(point1, point2) {
      var vec = [];
      point1.forEach((c, i) => {
        vec.push(point2[i] - c);
      });
      return vec;
    }
    static getBufferedValueByCoordinates(vb = new Array(300).fill(1), dims = [10, 10, 2], coordinate = [1, 2, 1], cardinal = void 0) {
      let getIdx = (foundIdx = 0, dimIdx = 0) => {
        if (dimIdx === dims.length)
          return foundIdx;
        if (dimIdx == 0)
          foundIdx += coordinate[dimIdx];
        else if (dims[dimIdx] == 0)
          dimsAt0++;
        else {
          let reMul = (val = coordinate[dimIdx], di2 = dimIdx - 1) => {
            val *= dims[di2];
            di2--;
            if (di2 == 0)
              return val;
            else
              return reMul(val, di2);
          };
          foundIdx += reMul(coordinate[dimIdx] + 1, dimIdx - 1);
        }
        dimIdx++;
        return getIdx(foundIdx, dimIdx);
      };
      let found = getIdx();
      if (cardinal) {
        if (coordinate[coordinate.length - 1] === 0) {
          let lastnonzero = 0;
          let idx = 0;
          while (idx !== coordinate.length - 1) {
            if (coordinate[idx] !== 0)
              lastnonzero = idx;
            idx++;
          }
          return vb[found - lastnonzero + cardinal];
        }
        return vb[found - dims.length + cardinal];
      } else {
        if (coordinate[coordinate.length - 1] === 0) {
          let lastnonzero = 0;
          let idx = 0;
          while (idx !== coordinate.length - 1) {
            if (coordinate[idx] !== 0)
              lastnonzero = idx;
            idx++;
          }
          return vb.slice(found - lastnonzero, found + 1);
        }
        return vb.slice(found - dims.length, found + 1);
      }
    }
    static forBufferedMat(vb = new Array(100).fill(1), dims = [10, 10], asIndex = (v, i, x2, y) => {
      return v + x2 + y;
    }) {
      let coordinate = [];
      let idx = 0;
      let recurseFor = (depth = 0, nextDepth = depth + 1) => {
        let result = new Array(vb.length);
        for (let di2 = 0; di2 < dims[depth]; di2++) {
          coordinate[depth] = di2;
          if (dims[nextDepth])
            recurseFor(nextDepth);
          else {
            result[idx] = asIndex(vb[idx], idx, ...coordinate);
            idx++;
          }
        }
        return result;
      };
      let recurseForArrFuncs = (depth, nextDepth = depth + 1) => {
        let result = new Array(vb.length);
        for (let di2 = 0; di2 < dims[depth]; di2++) {
          coordinate[depth] = di2;
          if (dims[nextDepth])
            recurseFor(nextDepth);
          else {
            for (let dj = 0; dj < dims.length; dj++) {
              result[idx] = asIndex[dj](vb[idx], idx, ...coordinate);
              idx++;
            }
          }
        }
        return result;
      };
      if (typeof asIndex === "function") {
        return recurseFor();
      } else if (Array.isArray(asIndex)) {
        return recurseForArrFuncs();
      }
    }
    static mapBufferedMat(buffer = new Array(100).fill(1), dimensions = [10, 10], asIndex = (v, idx, i, j) => {
      console.log(\`value:\${v}, idx:\${idx}, x:\${i},y:\${j}\`);
      return v + i + j;
    }) {
      let coordinate = new Array(dimensions.length).fill(0);
      const iterateCoordinate = (coord, idx = 0) => {
        if (coord[idx] >= dimensions[idx]) {
          coord[idx] = 0;
          idx++;
          if (idx === dimensions.length)
            return;
          iterateCoordinate(coord, idx);
        } else
          coord[idx]++;
      };
      let result = new Array(buffer.length);
      let i = 0;
      if (typeof asIndex === "function") {
        while (i < buffer.length) {
          result[i] = asIndex(buffer[i], i, ...coordinate);
          i += dimensions.length;
          iterateCoordinate(coordinate);
        }
      } else if (Array.isArray(asIndex)) {
        while (i < buffer.length) {
          asIndex.forEach((func) => {
            result[i] = func(buffer[i], i, ...coordinate);
            i++;
            iterateCoordinate(coordinate);
          });
        }
      }
      return result;
    }
    static combinations(choices = ["a", "b", "c"], vecsize = 3) {
      var result = [];
      if (vecsize <= 0) {
        result.push([]);
      } else {
        _Math2.combinations(choices, vecsize - 1).forEach(function(previousComb) {
          choices.forEach(function(element) {
            result.push([element].concat(previousComb));
          });
        });
      }
      return result;
    }
    static generateCoordinateSpace(upperBounds = [10, 10, 10], lowerBounds = [-10, -10, -10], steps = [1, 1, 1], mutater = void 0) {
      for (let i = 0; i < upperBounds.length; i++) {
        if (lowerBounds[i] > upperBounds[i]) {
          let temp = upperBounds[i];
          upperBounds[i] = lowerBounds[i];
          lowerBounds[i] = temp;
        }
      }
      let result = [];
      let copy = [...upperBounds];
      let lastindex = copy.length - 1;
      result.push([...copy]);
      while (copy[0] >= lowerBounds[0]) {
        let checkNextIndex = (decrIdx2) => {
          if (copy[decrIdx2] <= lowerBounds[decrIdx2]) {
            if (decrIdx2 === 0)
              return;
            copy[decrIdx2] = upperBounds[decrIdx2];
            decrIdx2--;
            if (decrIdx2 < 0)
              return;
            if (typeof steps[decrIdx2] == "function")
              copy[decrIdx2] -= steps[decrIdx2](copy[decrIdx2]);
            else
              copy[decrIdx2] -= steps[decrIdx2];
            checkNextIndex(decrIdx2);
          }
        };
        let decrIdx = lastindex;
        if (typeof steps[decrIdx] == "function")
          copy[decrIdx] -= steps[decrIdx](copy[decrIdx]);
        else
          copy[decrIdx] -= steps[decrIdx];
        result.push([...copy]);
        checkNextIndex(decrIdx);
        if (mutater)
          result[result.length - 1] = mutater(result[result.length - 1]);
      }
      return result;
    }
    static calcVectorField(coordinates = [[0, 0], [0, 1], [1, 0], [1, 1]], formula = (x2, y) => {
      return [x2 * 10, y * 10];
    }) {
      return coordinates.map((vec) => formula(...vec));
    }
    static transpose(mat) {
      return mat[0].map((_, colIndex) => mat.map((row) => row[colIndex]));
    }
    static matmul(a, b) {
      var aNumRows = a.length, aNumCols = a[0].length, bNumRows = b.length, bNumCols = b[0].length, m = new Array(aNumRows);
      for (var r = 0; r < aNumRows; ++r) {
        m[r] = new Array(bNumCols);
        for (var c = 0; c < bNumCols; ++c) {
          m[r][c] = 0;
          for (var i = 0; i < aNumCols; ++i) {
            m[r][c] += a[r][i] * b[i][c];
          }
        }
      }
      return m;
    }
    static matscale(mat, scalar) {
      let m = [];
      for (var i = 0; i < mat.length; i++) {
        m[i] = [];
        for (let j = 0; j < mat[0].length; j++) {
          m[i][j] = mat[i][j] * scalar;
        }
      }
      return m;
    }
    static matadd(a, b) {
      let m = [];
      for (let i = 0; i < a.length; i++) {
        m[i] = [];
        for (var j = 0; j < a[0].length; j++) {
          m[i][j] = a[i][j] + b[i][j];
        }
      }
      return m;
    }
    static matsub(a, b) {
      let m = [];
      for (let i = 0; i < a.length; i++) {
        m[i] = [];
        for (var j = 0; j < a[0].length; j++) {
          m[i][j] = a[i][j] - b[i][j];
        }
      }
      return m;
    }
    static histogram(arr = [], binSize = 1, nBins = void 0) {
      let copy = [...arr];
      copy.sort(function(a, b) {
        return a - b;
      });
      let binStart = Math.min(...copy);
      if (typeof nBins === "number") {
        let binEnd = Math.max(...copy);
        binSize = Math.abs((binEnd - binStart) / (nBins - 1));
      }
      let j = binStart;
      let binx = [];
      let biny = [];
      for (let i = 0; i < copy.length; i++) {
        let binidx = binSize * j;
        if (copy[i] > binStart + binidx) {
          j++;
          binidx += binSize;
          let binmin = binStart + binidx;
          let binmid = binmin + binidx * 0.5;
          binx.push(binmid);
          biny.push(0);
        }
        biny[biny.length - 1]++;
      }
      return [binx, biny];
    }
    static normalDistribution(samples = [], normalize = true, cutoff = 1e-4) {
      let m = this.mean(samples);
      let vari = this.variance(samples);
      let nSamples = samples.length;
      let probabilities = [];
      let denom = 1 / (this.TWO_PI * vari);
      let _variance = 1 / vari;
      let sum = 0;
      for (let i = 0; i < nSamples; i++) {
        let px = Math.exp(-0.5 * Math.pow((samples[i] - m) * _variance, 2)) * denom;
        if (px < cutoff)
          px = 0;
        probabilities.push(px);
        sum += px;
      }
      if (normalize) {
        let _sum = 1 / sum;
        probabilities = probabilities.map((x2) => x2 * _sum);
      }
      return probabilities;
    }
    static expectedValue(samples = [], probabilities = this.normalDistribution(samples)) {
      return samples.reduce((sum, item, idx) => sum + item * probabilities[idx]);
    }
    static originMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {
      return samples.reduce((sum, item, idx) => sum + Math.pow(item, order) * probabilities[idx]);
    }
    static centralMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {
      let m = this.mean(samples);
      return samples.reduce((sum, item, idx) => sum + Math.pow(item - m, order) * probabilities[idx] / samples.length);
    }
    static linearDiscriminantAnalysis(samples = [], classifier = []) {
      let mean = this.mean(samples);
      let meank = this.mean(classifier);
      let covariance = this.cov1d(samples, classifier);
      let probs = this.normalDistribution(samples);
      let dk = [];
      for (let i = 0; i < samples.length; i++) {
        dk.push(x[i] * covariance * meank - 0.5 * mean * covariance * meank + Math.log10(probs[i]));
      }
      return dk;
    }
    static conv1D(arr = [], kern = [1 / 3, 1 / 3, 1 / 3], pad = Math.floor(kern.length * 0.5)) {
      let result = [];
      let _n = 1 / kern.length;
      if (pad > 0) {
        let pads = new Array(pad).fill(0);
        arr = [...pads, ...arr, ...pads];
      }
      let start = Math.floor(kern.length * 0.5);
      let end = arr.length - kern.length + start;
      for (let i = start; i < end; i++) {
        let acc = 0;
        for (let j = 0; j < kern.length; j++) {
          acc += arr[i - start] * kern[j];
        }
        result.push(acc * _n);
      }
      return result;
    }
    static conv2D(mat = [[], [], []], kern = [[], [], []], pad = 0) {
      let result = new Array(mat.length - Math.ceil(kern.length * 0.5)).fill([]);
      let mat_t;
      let kern_t = _Math2.transpose(kern_t);
      if (pad > 0) {
        let pads = new Array(pad).fill(0);
        mat_t = _Math2.transpose(mat);
        for (let i2 = 0; i2 < mat_t.length; i2++) {
          mat_t[i2] = [...pads, ...mat_t[i2], ...pads];
        }
        mat = _Math2.transpose(mat_t);
        for (let j = 0; j < mat.length; j++) {
          mat[j] = [...pads, ...mat[j], ...pads];
        }
      }
      let startr = Math.floor(kern[0].length * 0.5);
      let startl = Math.floor(kern_t[0].length * 0.5);
      let endr = mat[0].length - kern[0].length + startr;
      let endl = mat_t[0].length - kern_t[0].length + startl;
      let _n = 1 / (kern[0].length * kern_t[0].length);
      let iters = endr * endl;
      let i = startr;
      let x2;
      let y = startl;
      while (i < iters) {
        let acc = 0;
        x2 = i % mat[0].length;
        if (x2 === 0) {
          y++;
        }
        for (let j = 0; j < kern[0].length; j++) {
          for (let k = 0; k < kern_t[0].length; j++) {
            acc += mat[y - startl + k][x2 - startr + j] * kern[k][j];
          }
          result[y].push(acc * _n);
        }
        i++;
      }
      return result;
    }
    static cov2d(mat) {
      var mattransposed = this.transpose(mat);
      var matproducts = [];
      var rowmeans = [];
      var colmeans = [];
      mat.forEach((row, idx) => {
        rowmeans.push(this.mean(row));
      });
      mattransposed.forEach((col, idx) => {
        colmeans.push(this.mean(col));
      });
      mat.forEach((row, idx) => {
        matproducts.push([]);
        for (var col = 0; col < row.length; col++) {
          matproducts[idx].push((mat[idx][col] - rowmeans[idx]) * (mat[idx][col] - colmeans[col]) / (row.length - 1));
        }
      });
      var matproductstransposed = this.transpose(matproducts);
      var aNumRows = matproducts.length, aNumCols = matproducts[0].length, bNumRows = matproductstransposed.length, bNumCols = matproductstransposed[0].length, m = new Array(aNumRows);
      for (var r = 0; r < aNumRows; ++r) {
        m[r] = new Array(bNumCols);
        for (var c = 0; c < bNumCols; ++c) {
          m[r][c] = 0;
          for (var i = 0; i < aNumCols; ++i) {
            m[r][c] += matproducts[r][i] * matproductstransposed[i][c] / (mat[0].length - 1);
          }
        }
      }
      return m;
    }
    static cov1d(arr1 = [], arr2 = []) {
      return this.cov2d([arr1, arr2]);
    }
    static cov3d(x2 = [], y = [], z = []) {
      return [
        [this.cov1d(x2, x2), this.cov1d(x2, y), this.cov1d(x2, z)],
        [this.cov1d(y, x2), this.cov1d(y, y), this.cov1d(y, z)],
        [this.cov1d(z, x2), this.cov1d(z, y), this.cov1d(z, z)]
      ];
    }
    static covNd(dimensionalData = []) {
      let covariance = [];
      dimensionalData.forEach((arr, i) => {
        covariance.push([]);
        dimensionalData.forEach((arr2, j) => {
          covariance[i].push(this.cov1d(arr, arr2));
        });
      });
    }
    static eigens2x2(mat = [[1, 2], [3, 4]]) {
      let det = mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
      let mean = (mat[0][0] + mat[1][1]) * 0.5;
      let sqrt = Math.sqrt(mean * mean - det);
      let eig1 = mean + sqrt;
      let eig2 = mean - sqrt;
      return [eig1, eig2];
    }
    static eigenvectors2x2(mat = [[1, 2], [3, 4]], eigens = [1, 2]) {
      let v1 = [-mat[0][1], mat[0][0] - eigens[0]];
      if (v1[0] === 0 && v1[1] === 0) {
        v1[0] = mat[1][1] - eigens[0];
        v1[1] = -mat[1][0];
      }
      let v2 = [-mat[0][1], mat[0][0] - eigens[1]];
      if (v2[0] === 0 && v2[1] === 0) {
        v2[0] = mat[1][1] - eigens[1];
        v2[1] = -mat[1][0];
      }
      return [v1, v2];
    }
    static fastpca2d(xarr, yarr) {
      let cov1d = this.cov1d(xarr, yarr);
      let eigs = this.eigens2x2(cov1d);
      if (eigs[1] > eigs[0])
        eigs.reverse();
      let evs = this.eigenvectors2x2(cov1d, eigs);
      console.log(eigs, evs);
      return [eigs, evs];
    }
    static crosscorrelation(arr1, arr2) {
      var arr2buf = [...arr2, ...Array(arr2.length).fill(0)];
      var mean12 = this.mean(arr1);
      var mean2 = this.mean(arr2);
      var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean12, 2));
      arr1Est = Math.sqrt(arr1Est);
      var arr2Est = arr2.reduce((sum, item) => sum += Math.pow(item - mean12, 2));
      arr2Est = Math.sqrt(arr2Est);
      var _arrEstsMul = 1 / (arr1Est * arr2Est);
      var correlations = new Array(arr1.length).fill(0);
      for (var delay = 0; delay < arr1.length; delay++) {
        var r = arr1.reduce((sum, item, i) => sum += (item - mean12) * (arr2buf[delay + i] - mean2));
        correlations[delay] = r * _arrEstsMul;
      }
      return correlations;
    }
    static autocorrelation(arr1) {
      var delaybuf = [...arr1, ...Array(arr1.length).fill(0)];
      var mean12 = this.mean(arr1);
      var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean12, 2));
      arr1Est = Math.sqrt(arr1Est);
      var _arr1estsqrd = 1 / (arr1Est * arr1Est);
      var correlations = new Array(arr1.length).fill(0);
      for (var delay = 0; delay < arr1.length; delay++) {
        var r = arr1.reduce((sum, item, i) => sum += (item - mean12) * (delaybuf[delay + i] - mean12));
        correlations[delay] = r * _arr1estsqrd;
      }
      return correlations;
    }
    static autocorrelation2dNormalized(mat2d2) {
      let result = [];
      for (let y = 0; y < mat2d2.length; y++) {
        result.push([]);
        for (let x2 = 0; x2 < mat2d2[y].length; x2++) {
          let G = 0;
          let _G = 0;
          for (let b = 0; b < mat2d2.length; b++) {
            for (let a = 0; a < mat2d2[b].length; a++) {
              G += mat2d2[y][x2] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
              _G += mat2d2[y][x2] * mat2d2[mat2d2.length - 1][mat2d2[y].length - 1];
            }
          }
          result[y][x2] = G / _G - 1;
        }
      }
      return result;
    }
    static crosscorrelation2d(mat2d1, mat2d2) {
      let result = [];
      for (let y = 0; y < mat2d1.length; y++) {
        result.push([]);
        for (let x2 = 0; x2 < mat2d1[y].length; x2++) {
          let G = 0;
          for (let b = 0; b < mat2d2.length; b++) {
            for (let a = 0; a < mat2d2[b].length; a++) {
              G += mat2d1[y][x2] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
            }
          }
          result[y][x2] = G;
        }
      }
      return result;
    }
    static crosscorrelation2dNormalized(mat2d1, mat2d2) {
      let result = [];
      for (let y = 0; y < mat2d1.length; y++) {
        result.push([]);
        for (let x2 = 0; x2 < mat2d1[y].length; x2++) {
          let G = 0;
          let _G = 0;
          for (let b = 0; b < mat2d2.length; b++) {
            for (let a = 0; a < mat2d2[b].length; a++) {
              G += mat2d1[y][x2] * mat2d2[mat2d.length - 1 - b][mat2d2[y].length - 1 - a];
              _G += mat2d1[y][x2] * mat2d2[mat2d2.length - 1][mat2d2[y].length - 1];
            }
          }
          result[y][x2] = G / _G - 1;
        }
      }
      return result;
    }
    static correlograms(dat = [[], []]) {
      var correlograms = [];
      dat.forEach((row1, i) => {
        dat.forEach((row2, j) => {
          if (j >= i) {
            correlograms.push(_Math2.crosscorrelation(row1, row2));
          }
        });
      });
      return correlograms;
    }
    static dft(sineWave = []) {
      var TWOPI = 2 * 3.141592653589793;
      var real = [];
      var imag = [];
      var mags = [];
      for (var k = 0; k < sineWave.length; k++) {
        real.push(0);
        imag.push(0);
        for (var j = 0; j < sineWave.length; j++) {
          var shared = TWOPI * k * j / sineWave.length;
          real[k] = real[k] + sineWave[j] * Math.cos(shared);
          imag[k] = imag[k] - sineWave[j] * Math.sin(shared);
        }
        mags.push(Math.sqrt(real[k] * real[k] + imag[k] * imag[k]));
      }
      function orderMagnitudes(unorderedMags) {
        return [...unorderedMags.slice(Math.ceil(unorderedMags.length * 0.5), unorderedMags.length), ...unorderedMags.slice(0, Math.ceil(unorderedMags.length * 0.5))];
      }
      mags = orderMagnitudes(mags);
      let halflen = mags.length * 0.5;
      let freqs = mags.map((m, i) => {
        return i - halflen;
      });
      return {
        real,
        imag,
        freqs,
        mags
      };
    }
    static sma(arr = [], window2) {
      var smaArr = [];
      for (var i = 0; i < arr.length; i++) {
        if (i == 0) {
          smaArr.push(arr[0]);
        } else if (i < window2) {
          var arrslice = arr.slice(0, i + 1);
          smaArr.push(arrslice.reduce((previous, current) => current += previous) / (i + 1));
        } else {
          var arrslice = arr.slice(i - window2, i);
          smaArr.push(arrslice.reduce((previous, current) => current += previous) / window2);
        }
      }
      return smaArr;
    }
    static sum(arr = []) {
      if (arr.length > 0) {
        var sum = arr.reduce((prev, curr) => curr += prev);
        return sum;
      } else {
        return 0;
      }
    }
    static reduceArrByFactor(arr, factor = 2) {
      let x2 = arr.filter((element, index) => {
        return index % factor === 0;
      });
      return x2;
    }
    static makeArr(startValue, stopValue, nSteps) {
      var arr = [];
      var step = (stopValue - startValue) / (nSteps - 1);
      for (var i = 0; i < nSteps; i++) {
        arr.push(startValue + step * i);
      }
      return arr;
    }
    static autoscale(array, stackedLines = 1, stackPosition = 0, centerZero = false) {
      if (array?.length === 0)
        return array;
      let max = Math.max(...array);
      let min = Math.min(...array);
      let _lines = 1 / stackedLines;
      let scalar;
      if (centerZero) {
        let absmax = Math.max(Math.abs(min), Math.abs(max));
        scalar = _lines / absmax;
        return array.map((y) => y * scalar + (_lines * (stackPosition + 1) * 2 - 1 - _lines));
      } else {
        scalar = _lines / (max - min);
        return array.map((y) => 2 * ((y - min) * scalar - 1 / (2 * stackedLines)) + (_lines * (stackPosition + 1) * 2 - 1 - _lines));
      }
    }
    static absmax(array) {
      return Math.max(Math.abs(Math.min(...array)), Math.max(...array));
    }
    static downsample(array, fitCount, scalar = 1) {
      if (array.length > fitCount) {
        let output = new Array(fitCount);
        let incr = array.length / fitCount;
        let lastIdx = array.length - 1;
        let last = 0;
        let counter = 0;
        for (let i = incr; i < array.length; i += incr) {
          let rounded = Math.round(i);
          if (rounded > lastIdx)
            rounded = lastIdx;
          for (let j = last; j < rounded; j++) {
            output[counter] += array[j];
          }
          output[counter] /= (rounded - last) * scalar;
          counter++;
          last = rounded;
        }
        return output;
      } else
        return array;
    }
    static interpolateArray(data, fitCount, scalar = 1) {
      var linearInterpolate = function(before2, after2, atPoint2) {
        return (before2 + (after2 - before2) * atPoint2) * scalar;
      };
      var newData = new Array();
      var springFactor = new Number((data.length - 1) / (fitCount - 1));
      newData[0] = data[0];
      for (var i = 1; i < fitCount - 1; i++) {
        var tmp = i * springFactor;
        var before = new Number(Math.floor(tmp)).toFixed();
        var after = new Number(Math.ceil(tmp)).toFixed();
        var atPoint = tmp - before;
        newData[i] = linearInterpolate(data[before], data[after], atPoint);
      }
      newData[fitCount - 1] = data[data.length - 1];
      return newData;
    }
    static isExtrema(arr, critical = "peak") {
      let ref = [...arr];
      if (ref.length % 2 === 0)
        ref.pop();
      if (arr.length > 1) {
        let pass = true;
        for (let i = 0; i < ref.length; i++) {
          let val = ref[i];
          if (critical === "peak") {
            if (i < Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            } else if (i > Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            }
          } else if (critical === "valley") {
            if (i < Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            } else if (i > Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            }
          } else {
            if (i < Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            } else if (i > Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            }
          }
        }
        if (critical !== "peak" && critical !== "valley" && pass === false) {
          pass = true;
          for (let i = 0; i < ref.length; i++) {
            let val = ref[i];
            if (i < Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            } else if (i > Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
              pass = false;
              break;
            }
          }
        }
        return pass;
      } else
        return void 0;
    }
    static isCriticalPoint(arr, critical = "peak") {
      let ref = [...arr];
      if (ref.length % 2 === 0)
        ref.pop();
      if (arr.length > 1) {
        let pass = true;
        for (let i = 0; i < ref.length; i++) {
          let val = ref[i];
          if (critical === "peak") {
            if (i < ref.length * 0.5 && val <= 0) {
              pass = false;
              break;
            } else if (i > ref.length * 0.5 && val > 0) {
              pass = false;
              break;
            }
          } else if (critical === "valley") {
            if (i < ref.length * 0.5 && val >= 0) {
              pass = false;
              break;
            } else if (i > ref.length * 0.5 && val < 0) {
              pass = false;
              break;
            }
          } else {
            if (i < ref.length * 0.5 && val >= 0) {
              pass = false;
              break;
            } else if (i > ref.length * 0.5 && val < 0) {
              pass = false;
              break;
            }
          }
        }
        if (critical !== "peak" && critical !== "valley" && pass === false) {
          pass = true;
          for (let i = 0; i < ref.length; i++) {
            let val = ref[i];
            if (i < ref.length * 0.5 && val <= 0) {
              pass = false;
              break;
            } else if (i > ref.length * 0.5 && val > 0) {
              pass = false;
              break;
            }
          }
        }
        return pass;
      } else
        return void 0;
    }
    static getPeakThreshold(arr, peakIndices, thresholdVar) {
      let threshold;
      let filtered = arr.filter((o, i) => {
        if (peakIndices.indexOf(i) > -1)
          return true;
      });
      if (thresholdVar === 0) {
        threshold = this.mean(filtered);
      } else
        threshold = (thresholdVar + this.mean(filtered)) * 0.5;
      return threshold;
    }
    static column(mat, x2) {
      let col = new Array(mat.length).fill(0).map(() => new Array(1).fill(0));
      for (let i = 0; i < mat.length; i++) {
        col[i][0] = mat[i][x2];
      }
      return col;
    }
    static flatten_vector(v) {
      let v_new = [];
      for (let i = 0; i < v.length; i++) {
        v_new[i] = v[i][0];
      }
      return v_new;
    }
    static squared_difference(v1, v2) {
      let sum = 0;
      for (let i = 0; i < v1.length; i++) {
        sum = sum + Math.pow(v1[i] - v2[i], 2);
      }
      return sum;
    }
    static shift_deflate(mat, eigenvalue, eigenvector) {
      let len = Math.sqrt(this.matmul(this.transpose(eigenvector), eigenvector));
      let U = this.matscale(eigenvector, 1 / len);
      let delta = this.matscale(this.matmul(U, this.transpose(U)), eigenvalue);
      let M_new = this.matsub(mat, delta);
      return M_new;
    }
    static eigenvalue_of_vector(mat, eigenvector) {
      ev = this.matmul(this.matmul(this.transpose(eigenvector), mat), eigenvector);
      return ev;
    }
    static power_iteration(mat, tolerance = 1e-5, max_iterations = 1e3) {
      let rank = mat.length;
      let eigenvector = new Array(rank).fill(0).map(() => new Array(1).fill(Math.sqrt(rank)));
      let eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);
      let epsilon = 1;
      let iter = 0;
      while (epsilon > tolerance && iter < max_iterations) {
        let old_eigenvalue = JSON.parse(JSON.stringify(eigenvalue));
        let Mv = this.matmul(mat, eigenvector);
        eigenvector = this.normalize(Mv);
        eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);
        epsilon = Math.abs(eigenvalue - old_eigenvalue);
        iter++;
      }
      ;
      return [eigenvalue, eigenvector];
    }
    static eigens(mat, tolerance = 1e-4, max_iterations = 1e3) {
      let eigenvalues = [];
      let eigenvectors = [];
      for (let i = 0; i < mat.length; i++) {
        let result = this.power_iteration(mat, tolerance, max_iterations);
        let eigenvalue = result[0];
        let eigenvector = result[1];
        eigenvalues[i] = eigenvalue;
        eigenvectors[i] = this.flatten_vector(eigenvector);
        mat = this.shift_deflate(mat, eigenvalue, eigenvector);
      }
      return [eigenvalues, eigenvectors];
    }
    static pca(mat, tolerance = 1e-5) {
      let dims = mat.length;
      let t = new Array(dims);
      let p = new Array(dims);
      let mat_t = this.transpose(mat);
      t[0] = this.column(mat, 0);
      let epsilon = 1;
      let iter = 0;
      while (espilon > tolerance) {
        iter++;
        p[0] = this.matmul(mat_t, t[0]);
        let tp = this.matmul(this.transpose(t[0]), t[0]);
        p[0] = this.matscale(p[0], 1 / tp);
        let p_length = Math.sqrt(this.matmul(this.transpose(p[0]), p[0]));
        p[0] = this.matscale(p[0], 1 / p_length);
        let t_new = this.matmul(mat, p[0]);
        let pp = this.matmul(this.transpose(p[0]), p[0]);
        t_new = this.matscale(t_new, 1 / pp);
        epsilon = this.squared_difference(t[0], t_new);
        t[0] = JSON.parse(JSON.stringify(t_new));
      }
      let components = this.matmul(this.transpose(t[0]), t[0]);
      return components;
    }
    static p300(event_timestamps = [], raw_signal = [], signal_timestamps = [], sps = 256) {
      let smoothingstep = Math.floor(sps / 10);
      let smoothed = this.sma(raw_signal, smoothingstep);
      let peaks = this.peakDetect(smoothed, "peak", smoothingstep);
      let mean = this.mean(smoothed);
      let std = this.std(smoothed, mean);
      let p_idx = 0;
      let candidates = [];
      if (peaks.length > 0) {
        event_timestamps.forEach((t, j) => {
          while (signal_timestamps[peaks[p_idx]] < t + 200) {
            p_idx++;
            if (!peaks[p_idx])
              break;
          }
          let tempi = 0;
          let tempcandidates = [];
          while (signal_timestamps[peaks[p_idx + tempi]] < t + 600) {
            tempcandidates.push(p_idx + tempi);
            tempi++;
            if (!peaks[p_idx + tempi])
              break;
          }
          if (tempcandidates.length > 1) {
            let peakvals = [];
            tempcandidates.forEach((tc) => {
              peakvals.push(smoothed[peaks[tc]]);
            });
            let max = Math.max(...peakvals);
            let maxi = tempcandidates[peakvals.indexOf(max)];
            candidates.push({
              event_timestamp: t,
              event_index: j,
              peak_timestamp: signal_timestamps[[peaks[maxi]]],
              signal_index: [peaks[maxi]],
              signal_amplitude: raw_signal[[peaks[maxi]]],
              zscore: (smoothed[peaks[maxi]] - mean) / std
            });
          } else if (tempcandidates.length === 1)
            candidates.push({
              event_timestamp: t,
              event_index: j,
              peak_timestamp: signal_timestamps[peaks[tempcandidates[0]]],
              signal_index: peaks[tempcandidates[0]],
              signal_amplitude: raw_signal[[peaks[tempcandidates[0]]]],
              zscore: (smoothed[peaks[tempcandidates[0]]] - mean) / std
            });
        });
      }
      return candidates;
    }
  };
  var Math2 = _Math2;
  __publicField(Math2, "TWO_PI", Math.PI * 2);
  __publicField(Math2, "C", 299792458);
  __publicField(Math2, "G", 66743e-15);
  __publicField(Math2, "h", 662607015e-42);
  __publicField(Math2, "R", 8314.32);
  __publicField(Math2, "Ra", 287);
  __publicField(Math2, "H", 69.3);
  __publicField(Math2, "kbar", 1054571817e-43);
  __publicField(Math2, "kB", 1380649e-29);
  __publicField(Math2, "ke", 89875517923e-1);
  __publicField(Math2, "me", 91093837015e-41);
  __publicField(Math2, "mp", 167262192369e-38);
  __publicField(Math2, "mn", 167492749804e-38);
  __publicField(Math2, "P0", 101325);
  __publicField(Math2, "T0", 288.15);
  __publicField(Math2, "p0", 1.225);
  __publicField(Math2, "Na", 60220978e16);
  __publicField(Math2, "y", 1.405);
  __publicField(Math2, "M0", 28.96643);
  __publicField(Math2, "g0", 9.80665);
  __publicField(Math2, "Re", 6378100);
  __publicField(Math2, "B", 1458e-9);
  __publicField(Math2, "S", 110.4);
  __publicField(Math2, "Sigma", 365e-12);
  __publicField(Math2, "imgkernels", {
    edgeDetection: [
      [-1, -1, -1],
      [-1, 8, -1],
      [-1, -1, -1]
    ],
    boxBlur: [
      [1 / 9, 1 / 9, 1 / 9],
      [1 / 9, 1 / 9, 1 / 9],
      [1 / 9, 1 / 9, 1 / 9]
    ],
    sobelLeft: [
      [1, 0, -1],
      [2, 0, -2],
      [1, 0, -1]
    ],
    sobelRight: [
      [-1, 0, 1],
      [-2, 0, 2],
      [-1, 0, 1]
    ],
    sobelTop: [
      [1, 2, 1],
      [0, 0, 0],
      [-1, -2, -1]
    ],
    sobelBottom: [
      [-1, 2, 1],
      [0, 0, 0],
      [1, 2, 1]
    ],
    identity: [
      [0, 0, 0],
      [0, 1, 0],
      [0, 0, 0]
    ],
    gaussian3x3: [
      [1, 2, 1],
      [2, 4, 2],
      [1, 2, 1]
    ],
    guassian7x7: [
      [0, 0, 0, 5, 0, 0, 0],
      [0, 5, 18, 32, 18, 5, 0],
      [0, 18, 64, 100, 64, 18, 0],
      [5, 32, 100, 100, 100, 32, 5],
      [0, 18, 64, 100, 64, 18, 0],
      [0, 5, 18, 32, 18, 5, 0],
      [0, 0, 0, 5, 0, 0, 0]
    ],
    emboss: [
      [-2, -1, 0],
      [-1, 1, 1],
      [0, 1, 2]
    ],
    sharpen: [
      [0, -1, 0],
      [-1, 5, -1],
      [0, -1, 0]
    ]
  });
  __publicField(Math2, "integral", (func = (x2) => {
    let y = x2;
    return y;
  }, range = [], stepx = 0.01) => {
    let area = 0;
    for (let i = range[0]; i < range[1]; i += stepx) {
      let y = func(i);
      area += y * stepx;
    }
    return area;
  });
  __publicField(Math2, "dintegral", (func = (x2, y) => {
    let z = x2 + y;
    return z;
  }, range = [[], []], stepx = 0.01, stepy = stepx) => {
    let volume = 0;
    for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {
      for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {
        let z = func(i, j);
        volume += z * stepx * stepy;
      }
    }
    return volume;
  });
  __publicField(Math2, "tintegral", (func = (x2, y, z) => {
    let w = x2 + y + z;
    return w;
  }, range = [[], [], []], stepx = 0.01, stepy = stepx, stepz = stepx) => {
    let volume = 0;
    for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {
      for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {
        for (let k = range[2][0] + stepz; k < range[2][1]; k += stepz) {
          let w = func(i, j, k);
          volume += w * stepx * stepy * stepz;
        }
      }
    }
    return volume;
  });
  __publicField(Math2, "pintegral", (func = (x2) => {
    let y = x2;
    return y;
  }, range = [], stepx = 0.01) => {
    let length = 0;
    let y0 = void 0;
    let yi2 = void 0;
    for (let i = range[0]; i < range[1]; i += stepx) {
      y0 = yi2;
      yi2 = func(i);
      if (y0)
        length += _Math2.distance([0, y0], [stepx, yi2]);
    }
    return length;
  });
  __publicField(Math2, "meshgrid", _Math2.generateCoordinateSpace);
  __publicField(Math2, "autocorrelation2d", (mat2d2) => {
    let result = [];
    for (let y = 0; y < mat2d2.length; y++) {
      result.push([]);
      for (let x2 = 0; x2 < mat2d2[y].length; x2++) {
        let G = 0;
        for (let b = 0; b < mat2d2.length; b++) {
          for (let a = 0; a < mat2d2[b].length; a++) {
            G += mat2d2[y][x2] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
          }
        }
        result[y][x2] = G;
      }
    }
    return result;
  });
  __publicField(Math2, "upsample", _Math2.interpolateArray);
  __publicField(Math2, "peakDetect", (smoothedArray, type = "peak", window2 = 49) => {
    let mid = Math.floor(window2 * 0.5);
    let peaks = [];
    for (let i = 0; i < smoothedArray.length - window2; i++) {
      let isPeak = _Math2.isExtrema(smoothedArray.slice(i, i + window2), type);
      if (isPeak) {
        peaks.push(i + mid - 1);
      }
    }
    return peaks;
  });
  Object.assign(Math, Math2);

  // ../GraphServiceRouter/services/gpu/GPU.service.ts
  var GPUService = class extends Service {
    constructor() {
      super(...arguments);
      this.gpu = new At();
      this.addFunc = (fn) => {
        if (typeof fn === "string")
          fn = parseFunctionFromText(fn);
        if (typeof fn === "function")
          this.gpu.addFunction(fn);
      };
      this.addKernel = (name2, fn, options) => {
        if (typeof fn === "string")
          fn = parseFunctionFromText(fn);
        if (typeof fn === "function")
          this.gpu.addKernel(name2, fn, options);
      };
      this.callKernel = (name2, ...args) => {
        this.gpu.callKernel(name2, ...args);
      };
      this.dft = (signalBuffer, nSeconds, scalar) => {
        if (scalar == void 0)
          scalar = 1;
        return this.gpu.gpuDFT(signalBuffer, nSeconds, scalar);
      };
      this.multidft = (signalBuffer, nSeconds, scalar) => {
        if (scalar == void 0)
          scalar = 1;
        return this.gpu.MultiChannelDFT(signalBuffer, nSeconds, scalar);
      };
      this.multidftbandpass = (buffered, nSeconds, freqStart, freqEnd, scalar) => {
        if (scalar == void 0)
          scalar = 1;
        return this.gpu.MultiChannelDFT_Bandpass(buffered, nSeconds, freqStart, freqEnd, scalar);
      };
      this.coherence = (buffered, nSeconds, freqStart, freqEnd) => {
        const correlograms = Math2.correlograms(buffered);
        const buffer = [...buffered, ...correlograms];
        var dfts;
        var scalar = 1;
        dfts = this.gpu.MultiChannelDFT_Bandpass(buffer, nSeconds, freqStart, freqEnd, scalar);
        const cordfts = dfts[1].splice(buffered.length, buffer.length - buffered.length);
        const coherenceResults = [];
        const nChannels = buffered.length;
        var k = 0;
        var l = 0;
        cordfts.forEach((row, i) => {
          if (l + k === nChannels) {
            var temp = cordfts.splice(i, 1);
            k++;
            cordfts.splice(k, 0, ...temp);
            l = 0;
          }
          l++;
        });
        var autoFFTproducts = [];
        k = 0;
        l = 1;
        cordfts.forEach((dft, i) => {
          var newdft = new Array(dft.length).fill(0);
          if (i < nChannels) {
            dft.forEach((amp, j) => {
              newdft[j] = amp;
            });
            autoFFTproducts.push(newdft);
          } else {
            dft.forEach((amp, j) => {
              newdft[j] = amp * amp / (autoFFTproducts[k][j] * autoFFTproducts[k + l][j]);
              if (newdft[j] > 1) {
                newdft[j] = 1;
              }
            });
            l++;
            if (l + k === nChannels) {
              k++;
              l = 1;
            }
            coherenceResults.push(newdft);
          }
        });
        return [dfts[0], dfts[1], coherenceResults];
      };
      this.routes = {
        addFunc: this.addFunc,
        addKernel: this.addKernel,
        callKernel: this.callKernel,
        dft: this.dft,
        multidft: this.multidft,
        multidftbandpass: this.multidftbandpass,
        coherence: this.coherence
      };
    }
  };

  // ../GraphServiceRouter/services/worker/ProxyListener.ts
  var mouseEventHandler = makeSendPropertiesHandler([
    "ctrlKey",
    "metaKey",
    "shiftKey",
    "button",
    "pointerType",
    "clientX",
    "clientY",
    "pageX",
    "pageY"
  ]);
  var wheelEventHandlerImpl = makeSendPropertiesHandler([
    "deltaX",
    "deltaY"
  ]);
  var keydownEventHandler = makeSendPropertiesHandler([
    "ctrlKey",
    "metaKey",
    "shiftKey",
    "keyCode"
  ]);
  function wheelEventHandler(event, sendFn) {
    event.preventDefault();
    wheelEventHandlerImpl(event, sendFn);
  }
  function preventDefaultHandler(event) {
    event.preventDefault();
  }
  function copyProperties(src, properties, dst) {
    for (const name2 of properties) {
      dst[name2] = src[name2];
    }
  }
  function makeSendPropertiesHandler(properties) {
    return function sendProperties(event, sendFn) {
      const data = { type: event.type };
      copyProperties(event, properties, data);
      sendFn(data);
    };
  }
  function touchEventHandler(event, sendFn) {
    const touches = [];
    const data = { type: event.type, touches };
    for (let i = 0; i < event.touches.length; ++i) {
      const touch = event.touches[i];
      touches.push({
        pageX: touch.pageX,
        pageY: touch.pageY
      });
    }
    sendFn(data);
  }
  var orbitKeys = {
    "37": true,
    "38": true,
    "39": true,
    "40": true
  };
  function filteredKeydownEventHandler(event, sendFn) {
    const { keyCode } = event;
    if (orbitKeys[keyCode]) {
      event.preventDefault();
      keydownEventHandler(event, sendFn);
    }
  }
  function initProxyElement(element, worker) {
    const eventHandlers = {
      contextmenu: preventDefaultHandler,
      mousedown: mouseEventHandler,
      mousemove: mouseEventHandler,
      mouseup: mouseEventHandler,
      pointerdown: mouseEventHandler,
      pointermove: mouseEventHandler,
      pointerup: mouseEventHandler,
      touchstart: touchEventHandler,
      touchmove: touchEventHandler,
      touchend: touchEventHandler,
      wheel: wheelEventHandler,
      keydown: filteredKeydownEventHandler
    };
    const id = "proxy" + Math.floor(Math.random() * 1e4);
    const sendEvent = (data) => {
      worker.postMessage({ route: "proxyHandler", args: [data, id] });
    };
    worker.postMessage({ route: "makeProxy", args: id });
    let entries = Object.entries(eventHandlers);
    for (const [eventName, handler] of entries) {
      element.addEventListener(eventName, function(event) {
        handler(event, sendEvent);
      });
    }
    const sendSize = () => {
      const rect = element.getBoundingClientRect();
      sendEvent({
        type: "size",
        left: rect.left,
        top: rect.top,
        width: element.clientWidth,
        height: element.clientHeight
      });
    };
    sendSize();
    globalThis.addEventListener("resize", sendSize);
    return id;
  }
  var EventDispatcher = class {
    addEventListener(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      if (this._listeners === void 0)
        return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
    dispatchEvent(event) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  };
  var ElementProxyReceiver = class extends EventDispatcher {
    constructor() {
      super();
      this.style = {};
    }
    get clientWidth() {
      return this.width;
    }
    get clientHeight() {
      return this.height;
    }
    setPointerCapture() {
    }
    releasePointerCapture() {
    }
    getBoundingClientRect() {
      return {
        left: this.left,
        top: this.top,
        width: this.width,
        height: this.height,
        right: this.left + this.width,
        bottom: this.top + this.height
      };
    }
    handleEvent(data) {
      if (data.type === "size") {
        this.left = data.left;
        this.top = data.top;
        this.width = data.width;
        this.height = data.height;
        return;
      }
      data.preventDefault = function noop() {
      };
      data.stopPropagation = function noop() {
      };
      this.dispatchEvent(data);
    }
    focus() {
    }
  };
  var ProxyManager = class {
    constructor() {
      this.id = "proxy" + Math.floor(Math.random() * 1e4);
      this.targets = {};
      this.handleEvent = this.handleEvent.bind(this);
    }
    makeProxy(id) {
      if (!id)
        id = \`proxyReceiver\${Math.floor(Math.random() * 1e12)}\`;
      const proxy = new ElementProxyReceiver();
      this.targets[id] = proxy;
    }
    getProxy(id) {
      return this.targets[id];
    }
    handleEvent(data, id) {
      this.targets[id].handleEvent(data);
    }
  };
  var proxyWorkerRoutes = {
    initProxyElement,
    makeProxy: (self2, origin, id) => {
      if (!self2.graph.PROXYELEMENTS)
        self2.graph.PROXYELEMENTS = new ProxyManager();
      self2.graph.PROXYELEMENTS.makeProxy(id);
      return id;
    },
    handleProxyEvent: (self2, origin, data, id) => {
      self2.graph.PROXYELEMENTS.handleEvent(data, id);
      return id;
    }
  };

  // ../GraphServiceRouter/services/worker/WorkerCanvas.ts
  var workerCanvasRoutes = {
    transferCanvas: (canvas, worker, context, drawfn) => {
      let _id = \`canvas\${Math.floor(Math.random() * 1e15)}\`;
      let offscreen = canvas.transferControlToOffscreen();
      let message = { route: "receiveCanvas", args: { offscreen, _id, context } };
      if (drawfn) {
        if (typeof drawfn === "function")
          drawfn = drawfn.toString();
        message.animation = drawfn;
      }
      worker.postMessage(message, [offscreen]);
      return _id;
    },
    receiveCanvas: (self2, origin, options) => {
      if (!self2.graph.CANVASES)
        self2.graph.CANVASES = {};
      self2.graph.CANVASES[options._id] = {
        _id: options._id,
        canvas: options.offscreen,
        context: options.offscreen.getContext(options.context),
        animation: options.animation,
        animating: false
      };
      if (typeof self2.graph.CANVASES[options._id].animation === "string") {
        self2.graph.CANVASES[options._id].animation = parseFunctionFromText(self2.graph.CANVASES[options._id].animation);
      }
      if (typeof self2.graph.CANVASES[options._id].animation === "function") {
        let draw = (canvas, context) => {
          if (self2.graph.CANVASES[options._id].animating)
            requestAnimationFrame(() => {
              self2.graph.CANVASES[options._id].animation(canvas, context);
            });
        };
        draw(self2.graph.CANVASES[options._id].canvas, self2.graph.CANVASES[options._id].context);
      }
      return self2.graph.CANVASES[options._id];
    },
    setDraw: (self2, origin, _id, drawfn) => {
      let canvasopts = self2.graph.CANVASES[_id];
      if (canvasopts) {
        if (typeof drawfn === "string")
          drawfn = parseFunctionFromText(drawfn);
        if (typeof drawfn === "function") {
          canvasopts.animation = drawfn;
        }
        return true;
      }
      return false;
    },
    animate: (self2, origin, _id, drawfn) => {
      let canvasopts = self2.graph.CANVASES[_id];
      if (canvasopts && drawfn) {
        if (typeof drawfn === "string")
          drawfn = parseFunctionFromText(drawfn);
        if (typeof drawfn === "function") {
          canvasopts.animation = drawfn;
        }
      }
      if (typeof canvasopts?.animation === "function" && !canvasopts?.animating) {
        let draw = (canvas, context) => {
          if (canvasopts.animating)
            requestAnimationFrame(() => {
              canvasopts.animation(canvas, context);
            });
        };
        draw(canvasopts.canvas, self2.graph.CANVASES[canvasopts._id].context);
        return true;
      }
      return false;
    },
    stopAnim: (self2, origin, _id) => {
      let canvasopts = self2.graph.CANVASES[_id];
      if (canvasopts)
        canvasopts.animating = false;
      return true;
    }
  };

  // ../GraphServiceRouter/services/unsafe/Unsafe.service.ts
  var unsafeRoutes = {
    setRoute: (self2, origin, fn, fnName) => {
      if (typeof fn === "string")
        fn = parseFunctionFromText(fn);
      if (typeof fn === "function") {
        if (!fnName)
          fnName = fn.name;
        if (self2.graph.get(fnName)) {
          self2.graph.get(fnName).setOperator(fn);
        } else
          self2.graph.add({ tag: fnName, operator: fn });
        return true;
      }
      return false;
    },
    transferClass: (classObj) => {
      if (typeof classObj === "object") {
        let str = classObj.toString();
        let message = { route: "receiveClass", args: str };
        return message;
      }
      return false;
    },
    receiveClass: (self2, origin, stringified) => {
      if (typeof stringified === "string") {
        if (stringified.indexOf("class") === 0) {
          let cls = (0, eval)("(" + stringified + ")");
          let name2 = cls.name;
          self2.graph[name2] = cls;
          return true;
        }
      }
      return false;
    }
  };

  // ../GraphServiceRouter/services/worker/Worker.ts
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    self.SERVICE = new WorkerService();
    self.ROUTER = new Router([
      self.SERVICE,
      GPUService,
      proxyWorkerRoutes,
      workerCanvasRoutes,
      unsafeRoutes
    ], {
      includeClassName: false
    });
    self.onmessage = (ev2) => {
      let result = self.SERVICE.receive(ev2.data);
    };
  }
  var Worker_default = self;
})();
/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.11.0
 * @date Tue Jan 05 2021 15:55:59 GMT-0500 (Eastern Standard Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2021 gpu.js Team
 */
`)],{type:"text/javascript"})),Nt=Jr;var ot=class{constructor(t,e){this.id=`router${Math.floor(Math.random()*1e15)}`;this.service=new we;this.nodes=this.service.nodes;this.run=this.service.run;this._run=this.service._run;this.add=this.service.add;this.remove=this.service.remove;this.stopNode=this.service.stopNode;this.subscribe=this.service.subscribe;this.unsubscribe=this.service.unsubscribe;this.get=this.service.get;this.reconstruct=this.service.reconstruct;this.setState=this.service.setState;this.recursivelyAssign=this.service.recursivelyAssign;this.state=this.service.state;this.routes=this.service.routes;this.services={};this.loadDefaultRoutes=!1;this.load=(t,e=!0,n=!0)=>{if(!(t instanceof Ae)&&typeof t=="function")t=new t({loadDefaultRoutes:this.loadDefaultRoutes},t.name),t.load();else if(!t)return;if(t instanceof Ae&&t.name)this.services[t.name]=t;else if(t.constructor.name==="Object"){let s=Object.prototype.toString.call(t);s&&(s=s.split(" ")[1]),s&&(s=s.split("]")[0]),s&&s!=="Object"&&s!=="Function"&&(this.services[s]=t)}else this.services[t.constructor.name]=t;if(this.service.load(t,n),e)for(let s in this.services)this.service.nodes.forEach(i=>{this.services[s]?.nodes&&(this.services[s].nodes.get(i.tag)||this.services[s].nodes.set(i.tag,i))});return this.services[t.name]};this.pipe=(t,e,n,s,i,c)=>{if(!n&&t&&e)return c?this.subscribe(t,d=>{let p=c(d);p&&(d=p),this.run(e,d)}):this.subscribe(t,d=>{this.run(e,d)});if(n){n==="sockets"&&(n="wss");let d=this.services[n];if(d)return c?this.subscribe(t,p=>{let y=c(p);y&&(p=y),d.transmit({route:e,args:p,origin:s,method:i})}):this.subscribe(t,p=>{d.transmit({route:e,args:p,origin:s,method:i})});{let p=this.getEndpointInfo(n);if(p)return this.services[p.service].pipe(t,e,n,s,i,c)}}return!1};this.pipeOnce=(t,e,n,s,i,c)=>{if(t instanceof Q&&(t=t.tag),!n&&typeof t=="string"&&e)return c?this.state.subscribeTriggerOnce(t,d=>{let p=c(d);p&&(d=p),this.run(e,d)}):this.state.subscribeTriggerOnce(t,d=>{this.run(e,d)});if(n){n==="sockets"&&(n="wss");let d=this.services[n];if(d)return c?this.state.subscribeTriggerOnce(t,p=>{let y=c(p);y&&(p=y),d.transmit({route:e,args:p,origin:s,method:i})}):this.state.subscribeTriggerOnce(t,p=>{d.transmit({route:e,args:p,origin:s,method:i})});{let p=this.getEndpointInfo(n);if(p)return this.services[p.service].pipeOnce(t,e,n,s,i,c)}}return!1};this.sendAll=(t,e,n)=>{let s=!1;if(typeof e=="object")for(let i in e)for(let c in e[i]){let d=e[i][c];if(d.socket)d.socket.readyState===1?(d.socket.send(t),s=!0):delete e[i][c];else if(d.wss)d.wss.clients.forEach(p=>{p.send(t)}),s=!0;else if(d.sessions)if(n)d.channel.broadcast(t,n),s=!0;else for(let p in d.sessions)d.sessions[p].isConnected&&(d.sessions[p].push(t),s=!0);else if(d.session)n?(d.served.channel.broadcast(t,n),s=!0):d.session.isConnected?(d.session.push(t),s=!0):delete e[i][c];else if(d.rtc)if(n&&d.channels[n])d.channels[n].send(t),s=!0;else if(d.channels.data)d.channels.data.send(t),s=!0;else{let p=Object.keys(d.channels)[0];d.channels[p].send(t),s=!0}else d.server&&this.services.http&&(this.services.http.transmit(t,n),s=!0)}return s};this.getEndpointInfo=(t,e)=>{if(!t)return;let n=(s,i)=>{if(this.services[i]){if(this.services[i].rtc?.[s])return this.services[i].rtc[s];if(this.services[i].servers?.[s])return this.services[i].servers[s];if(this.services[i].sockets?.[s])return this.services[i].sockets[s];if(this.services[i].eventsources?.[s])return this.services[i].eventsources[s];if(this.services[i].workers?.[s])return this.services[i].workers[s]}};if(e){let s=n(t,e);if(s)return{endpoint:s,service:e}}for(let s in this.services){let i=n(t,s);if(i)return{endpoint:i,service:s}}};this.pipeFastest=(t,e,n,s,i,c=this.services)=>{for(let d in c){if(c[d].rtc)return this.pipe(t,e,"webrtc",n,s,i);if(c[d].eventsources){let p=Object.keys(c[d].eventsources);if(p[0]&&this.services[d].eventsources[p[0]].sessions)return this.pipe(t,e,"sse",n,s,i)}if(c[d].sockets)return this.pipe(t,e,"wss",n,s,i);if(c[d].servers)return this.pipe(t,e,"http",n,s,i);if(c[d].workers)return this.pipe(t,e,"worker",n,s,i)}return!1};this.getFirstRemoteEndpoint=(t=this.services)=>{let e;for(let s in t){if(t[s].rtc&&(e=t[s].rtc),t[s].eventsources&&!e){let i=Object.keys(t[s].eventsources);i[0]&&this.services[s].eventsources[i[0]]?.sessions&&(e=t[s].eventsources)}t[s].sockets&&!e&&(e=t[s].sockets),t[s].servers&&!e&&(e=t[s].servers),t[s].workers&&!e&&(e=t[s].workers)}let n=Object.keys(e);return n[0]?e[n[0]]:!1};this.STREAMLATEST=0;this.STREAMALLLATEST=1;this.streamSettings={};this.streamFunctions={allLatestValues:(t,e)=>{let n;if(Array.isArray(t))t.length!==e.lastRead&&(n=t.slice(e.lastRead),e.lastRead=t.length);else if(typeof t=="object"){n={};for(let s in t)Array.isArray(t[s])?(typeof e=="number"?e={[s]:{lastRead:void 0}}:e[s]||(e[s]={lastRead:void 0}),t[s].length!==e[s].lastRead&&(n[s]=t[s].slice(e[s].lastRead),e[s].lastRead=t[s].length)):(typeof e=="number"?e={[s]:{lastRead:void 0}}:e[s]||(e[s]={lastRead:void 0}),e[s].lastRead!==t[s]&&(n[s]=t[s],e[s].lastRead=t[s]));Object.keys(n).length===0&&(n=void 0)}else e.lastRead!==t&&(n=t,e.lastRead=t);return n},latestValue:(t,e)=>{let n;if(Array.isArray(t))t.length!==e.lastRead&&(n=t[t.length-1],e.lastRead=t.length);else if(typeof t=="object"){n={};for(let s in t)Array.isArray(t[s])?(typeof e=="number"?e={[s]:{lastRead:void 0}}:e[s]||(e[s]={lastRead:void 0}),t[s].length!==e[s].lastRead&&(n[s]=t[s][t[s].length-1],e[s].lastRead=t[s].length)):(typeof e=="number"?e={[s]:{lastRead:void 0}}:e[s]||(e[s]={lastRead:void 0}),e[s].lastRead!==t[s]&&(n[s]=t[s],e[s].lastRead=t[s]))}else e.lastRead!==t&&(n=t,e.lastRead=t);return n}};this.setStreamFunc=(t,e,n=this.streamFunctions.allLatestValues)=>(this.streamSettings[t].settings[e]||(this.streamSettings[t].settings[e]={lastRead:0}),n===this.STREAMLATEST?this.streamSettings[t].settings[e].callback=this.streamFunctions.latestValue:n===this.STREAMALLLATEST?this.streamSettings[t].settings[e].callback=this.streamFunctions.allLatestValues:typeof n=="string"?this.streamSettings[t].settings[e].callback=this.streamFunctions[n]:typeof n=="function"&&(this.streamSettings[t].settings[e].callback=n),this.streamSettings[t].settings[e].callback||(this.streamSettings[t].settings[e].callback=this.streamFunctions.allLatestValues),!0);this.addStreamFunc=(t,e=n=>{})=>{this.streamFunctions[t]=e};this.setStream=(t={},e={},n=`stream${Math.floor(Math.random()*1e10)}`)=>{if(e.keys){if(e.keys.length===0){let s=Object.keys(t);s.length>0&&(e.keys=Array.from(s))}}else e.keys=Array.from(Object.keys(t));return this.streamSettings[n]={object:t,settings:e},e.keys.forEach(s=>{e[s]?.callback?this.setStreamFunc(n,s,e[s].callback):this.setStreamFunc(n,s,e.callback)}),this.streamSettings[n]};this.removeStream=(t,e)=>{if(t&&!e)delete this.streamSettings[t];else if(e&&this.streamSettings[t]?.settings?.keys){let n=this.streamSettings[t].settings.keys.indexOf(e);return n>-1&&this.streamSettings[t].settings.keys.splice(n,1),this.streamSettings[t].settings[e]&&delete this.streamSettings[t].settings[e],!0}return!1};this.updateStreamData=(t,e={})=>this.streamSettings[t]?(Object.assign(this.streamSettings[t].object,e),this.streamSettings[t].object):!1;this.streamLoop=(t,e)=>{let n={};for(let s in this.streamSettings)this.streamSettings[s].settings.keys.forEach(i=>{if(this.streamSettings[s].settings[i]){let c=this.streamSettings[s].settings[i].callback(this.streamSettings[s].object[i],this.streamSettings[s].settings[i]);c!==void 0&&(n[i]=c)}});return t&&this.sendAll(n,t,e),n};this.receive=(t,e,...n)=>{if(e){for(let s in this.services)if(s===e||this.services[s].name===e)return this.services[s].receive(t,...n)}return this.service.receive(t,...n)};this.transmit=(t,e,...n)=>{if(e){for(let s in this.services)if(s===e||this.services[s].name===e)return this.services[s].transmit(t,...n)}return this.service.transmit(t,...n)};this.defaultRoutes={getEndpointInfo:this.getEndpointInfo,pipeOnce:this.pipeOnce,pipeFastest:this.pipeFastest,setStream:this.setStream,removeStream:this.removeStream,updateStreamData:this.updateStreamData,addStreamFunc:this.addStreamFunc,setStreamFunc:this.setStreamFunc,sendAll:this.sendAll,streamLoop:{operator:this.streamLoop,loop:10}};e&&"loadDefaultRoutes"in e&&(this.loadDefaultRoutes=e.loadDefaultRoutes),this.loadDefaultRoutes&&this.load(this.defaultRoutes,e?.linkServices,e?.includeClassName),Array.isArray(t)?t.forEach(n=>this.load(n,e?.linkServices,e?.includeClassName)):typeof t=="object"&&Object.keys(t).forEach(n=>this.load(t[n],e?.linkServices,e?.includeClassName))}};var Lt=new Re,Zr=new Ne,Qt=new Rt,Mt=Qt.addWorker({url:Nt}),_a=Qt.addWorker({url:Nt});Mt.request({route:"setRoute",args:[function(t){return t}.toString()]}).then(console.log);Mt.request({route:"receiveClass",args:Re.toString()}).then(console.log);Mt.request({route:"setRoute",args:[function(t){return t.graph.Serial=new t.graph.WebSerial,!0}.toString()]}).then(console.log);Mt.request({route:"setupSerial"}).then(console.log);var Qr={debugger:{tagName:"div",children:{header:{tagName:"div",children:{bleconnect:{tagName:"button",innerText:"BLE Device",oncreate:(u,t)=>{u.onclick=()=>{Zr.setup({}).then(e=>{})}}},bleconfig:{tagName:"div",children:{namePrefixLabel:{tagName:"label",innerText:"BLE Device Name",children:{namePrefix:{tagName:"input",attributes:{type:"text",placeholder:"e.g. ESP32"}}}},deviceIdLabel:{tagName:"label",innerText:"BLE Device ID (direct connect)",children:{deviceId:{tagName:"input",attributes:{type:"text",placeholder:"e.g. ESP32"}}}},servicesLabel:{tagName:"label",innerText:"Service Config",children:{services:{tagName:"div",children:{}}}}}},serialconnect:{tagName:"button",innerText:"USB Device",oncreate:(u,t)=>{u.onclick=()=>{Lt.requestPort(document.getElementById("usbVendorId").value?parseInt(document.getElementById("usbVendorId").value):void 0,document.getElementById("usbProductId").value?parseInt(document.getElementById("usbProductId").value):void 0).then(e=>{Lt.openPort(e,{baudRate:document.getElementById("baudRate").value?parseInt(document.getElementById("baudRate").value):115200,bufferSize:document.getElementById("bufferSize").value?parseInt(document.getElementById("bufferSize").value):255,parity:document.getElementById("parity").value?document.getElementById("parity").value:"none",dataBits:document.getElementById("dataBits").value?parseInt(document.getElementById("dataBits").value):8,stopBits:document.getElementById("stopBits").value?parseInt(document.getElementById("stopBits").value):1,flowControl:document.getElementById("flowControl").value?document.getElementById("flowControl").value:"none",onconnect:n=>{let s=e.getInfo();console.log("connected port:",s)},ondisconnect:n=>{let s=e.getInfo();console.log("disconnected port:",s)}}).then(()=>{document.getElementById("console").innerText=JSON.stringify(e.getInfo());let n=new TextDecoder,s,i=()=>{document.getElementById("console").innerText=`Raw: ${s}\r UTF-8: ${n.decode(s)}`},c=Lt.createStream({port:e,frequency:1,ondata:d=>{s=d,requestAnimationFrame(i)}});Lt.readStream(c)})})}}},serialconfig:{tagName:"div",children:{baudRateLabel:{tagName:"label",innerText:"Baud Rate (bps)",children:{baudRate:{tagName:"input",attributes:{type:"number",placeholder:115200,value:115200,min:1,max:1e7}}}},bufferSizeLabel:{tagName:"label",innerText:"Read/Write buffer size (bytes)",children:{bufferSize:{tagName:"input",attributes:{type:"number",placeholder:255,value:255,min:1,max:1e7}}}},parityLabel:{tagName:"label",innerText:"Parity",children:{parity:{tagName:"select",children:{none:{tagName:"option",attributes:{value:"none",selected:!0,innerText:"none"}},even:{tagName:"option",attributes:{value:"even",innerText:"even"}},odd:{tagName:"option",attributes:{value:"odd",innerText:"odd"}}}}}},dataBitsLabel:{tagName:"label",innerText:"Data bits (7 or 8)",children:{dataBits:{tagName:"input",attributes:{type:"number",placeholder:8,value:8,min:7,max:8}}}},stopBitsLabel:{tagName:"label",innerText:"Stop bits (1 or 2)",children:{stopBits:{tagName:"input",attributes:{type:"number",placeholder:1,value:1,min:1,max:2}}}},flowControlLabel:{tagName:"label",innerText:"Flow control (hardware?)",children:{flowControl:{tagName:"select",children:{none:{tagName:"option",attributes:{value:"none",selected:!0,innerText:"none"}},hardware:{tagName:"option",attributes:{value:"hardware",innerText:"hardware"}}}}}},usbVendorIdLabel:{tagName:"label",innerText:"Vendor ID Filter? (hexadecimal)",children:{usbVendorId:{tagName:"input",attributes:{type:"text",placeholder:"0xabcd"}}}},usbProductIdLabel:{tagName:"label",innerText:"Product ID Filter? (hexadecimal)",children:{usbProductId:{tagName:"input",attributes:{type:"text",placeholder:"0xefgh"}}}},frequencyLabel:{tagName:"label",innerText:"Read frequency? (ms)",children:{frequency:{tagName:"input",attributes:{type:"number",placeholder:10,value:10,min:.001,max:1e7,step:.001}}}}}}}},console:{tagName:"div",style:{width:"100%",height:"300px",color:"white",backgroundColor:"black",fontSize:"10px",fontFamily:"Consolas, monaco, monospace"}},footer:{tagName:"div",children:{decoder:{tagName:"div"},linebreak:{tagName:"div",children:{}}}}}}},ei=new ot([Qt,zn,Gn,new kt({routes:Qr})]);console.log(ei);})();
/*! Capacitor: https://capacitorjs.com/ - MIT License */
/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.11.0
 * @date Tue Jan 05 2021 15:55:59 GMT-0500 (Eastern Standard Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2021 gpu.js Team
 */
