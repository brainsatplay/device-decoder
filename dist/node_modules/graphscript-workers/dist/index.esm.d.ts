declare var b2: {
    new (): {
        __listeners: {};
        proxied: any;
        style: {};
        width: any;
        left: any;
        right: any;
        top: any;
        height: any;
        readonly clientWidth: any;
        readonly clientHeight: any;
        setPointerCapture: () => void;
        releasePointerCapture: () => void;
        getBoundingClientRect: () => {
            left: any;
            top: any;
            width: any;
            height: any;
            right: any;
            bottom: any;
        };
        handleEvent: (e: any) => void;
        focus(): void;
        blur(): void;
        addEventListener(e: any, n: any): void;
        hasEventListener(e: any, n: any): boolean;
        removeEventListener(e: any, n: any): void;
        dispatchEvent(e: any, n: any): void;
    };
};
declare var w2: {
    new (): {
        __listeners: any;
        addEventListener(e: any, n: any): void;
        hasEventListener(e: any, n: any): boolean;
        removeEventListener(e: any, n: any): void;
        dispatchEvent(e: any, n: any): void;
    };
};
declare var g: {
    new (): {
        targets: {};
        makeProxy: (e: any, n: any) => void;
        getProxy: (e: any) => any;
        handleEvent: (e: any, n: any) => boolean;
    };
};
declare function I2(t: any): any;
export var WorkerService: {
    new (options: any): {
        name: string;
        workers: {};
        threadRot: number;
        connections: {
            workers: {};
        };
        loadWorkerRoute: (node: any, routeKey: any) => any;
        workerloader: {
            workers: (node: any, parent: any, graph: any, roots: any) => any;
        };
        addDefaultMessageListener: () => void;
        postMessage: (message: any, target: any, transfer: any) => void;
        addWorker: (options: any) => any;
        open: (options: any) => any;
        close: () => void;
        getTransferable(message: any): any[];
        transmit: (message: any, worker: any, transfer: any) => any;
        terminate: (worker: any) => boolean;
        establishMessageChannel: (worker: any, worker2: any) => string | false;
        request: (message: any, workerId: any, transfer: any, method: any) => Promise<any>;
        runRequest: (message: any, worker: any, callbackId: any, getTransferable?: boolean) => any;
        subscribeWorker: (route: any, worker: any, args: any, key: any, subInput: any, blocking: any, getTransferable?: boolean) => number;
        subscribeToWorker: (route: any, workerId: any, callback: any, args: any, key: any, subInput: any, blocking: any, getTransferable?: boolean) => any;
        triggerSubscription: (route: any, workerId: any, result: any) => Promise<boolean>;
        pipeWorkers: (sourceWorker: any, listenerWorker: any, sourceRoute: any, listenerRoute: any, portId: any, args: any, key: any, subInput: any, blocking: any, getTransferable: any) => any;
        unpipeWorkers: (sourceRoute: any, sourceWorker: any, sub: any) => any;
        restrict: any;
        addServices: (e: any) => void;
        set: (e: any, t: any) => Map<any, any>;
        delete: (e: any) => boolean;
        handleMethod: (e: any, t: any, n: any) => any;
        handleServiceMessage(e: any): any;
        handleGraphNodeCall(e: any, t: any): any;
        receive: (...e: any[]) => any;
        pipe: (e: any, t: any, n: any, s: any, r: any) => number;
        pipeOnce: (e: any, t: any, n: any, s: any, r: any) => number;
        isTypedArray: typeof X;
        recursivelyAssign: (i3: any, e: any) => any;
        spliceTypedArray: typeof Y;
        ping: () => string;
        echo: (...e: any[]) => any[];
        log: (...e: any[]) => boolean;
        error: (...e: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (e: any) => {};
                setValue: (e: any, t: any) => void;
                triggerEvent: (e: any, t: any) => void;
                subscribeState: (e: any) => number;
                unsubscribeState: (e: any) => boolean;
                subscribeEvent: (e: any, t: any, n: any, s: any) => number;
                unsubscribeEvent: (e: any, t: any) => boolean;
                subscribeEventOnce: (e: any, t: any) => number;
                getEvent: (e: any, t: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (e: any) => void;
        load: (e: any, t?: boolean) => any;
        setLoaders: (e: any, t: any) => any;
        runLoaders: (e: any, t: any, n: any, s: any) => void;
        add: (e: any, t: any, n?: boolean) => any;
        recursiveSet: (e: any, t: any, n: {}, s: any, r?: boolean) => {};
        remove: (e: any, t?: boolean) => any;
        run: (e: any, ...t: any[]) => any;
        setListeners: (e: any) => void;
        clearListeners: (e: any, t: any) => void;
        get: (e: any) => any;
        getByUnique: (e: any) => any;
        list: () => any[];
        getListener: (e: any, t: any, n: any) => any;
        getProps: (e: any, t: any) => void;
        subscribe: (e: any, t: any, n: any, s: any, r: any, _2: any, o: any) => number;
        unsubscribe: (e: any, t: any, n: any, s: any) => any;
        setState: (e: any) => void;
    };
};
declare function D2(t: any): any;
declare function L2(t: any, e: any): any;
declare namespace c {
    export { Y2 as contextmenu };
    export { d as mousedown };
    export { d as mousemove };
    export { d as mouseup };
    export { d as pointerdown };
    export { d as pointermove };
    export { d as pointerup };
    export { d as pointerlockchange };
    export { d as webkitpointerlockchange };
    export { P2 as focus };
    export { P2 as blur };
    export { d as pointerout };
    export { m as touchstart };
    export { m as touchmove };
    export { m as touchend };
    export { $2 as wheel };
    export { A2 as keydown };
    export { A2 as keyup };
    export { B2 as deviceorientation };
    export { K as devicemotion };
    export { z2 as orientation };
}
declare function h(t: any): any;
declare function H2(t: any): any;
declare function p(t: any, e: any, n: any, a: any): {
    functions: {
        keydown(o: any): void;
        keyup(o: any): void;
        devicemotion(o: any): void;
        deviceorientation(o: any): void;
        orientation(o: any): void;
    };
    terminate: () => void;
    id: any;
};
export var nodeTemplates: {};
declare namespace v {
    export { p as initProxyElement };
    export { q2 as makeProxy };
    export { M2 as handleProxyEvent };
}
export namespace remoteGraphRoutes {
    function transferNode(properties: any, connection: any, name2: any): any;
    function setNode(properties: any, name2: any): any;
    function makeNodeTransferrable(properties: any, name2: any): {};
    function getListenerJSON(): {};
    function makeRootTransferrable(): {};
    function setTemplate(properties: any, name2: any): any;
    function loadFromTemplate(templateName: any, name2: any, properties: any): any;
    function setMethod(nodeTag: any, fn: any, methodKey: any): boolean;
    function assignNode(nodeTag: any, source: any): void;
    function getNodeProperties(nodeTag: any): {};
    function proxyRemoteNode(name2: any, connection: any): Promise<any>;
    function transferClass(classObj: any, connection: any, className: any): any;
    function receiveClass(stringified: any, className: any): boolean;
    function transferFunction(fn: any, connection: any, fnName: any): any;
    function setGlobal(key: any, value: any): boolean;
    function assignGlobalObject(target: any, source: any): boolean;
    function setValue(key: any, value: any): boolean;
    function assignObject(target: any, source: any): boolean;
    function setGlobalFunction(fn: any, fnName: any): boolean;
    function setGraphFunction(fn: any, fnName: any): boolean;
}
declare function _(t: any, e: any): any;
declare function U2(t: any, e: any): any;
declare function V2(t: any): any;
declare function E(t: any, e: any): any;
declare function x2(t: any): any;
declare function N2(t: any, e: any, n: any): {
    _id: any;
    width: any;
    height: any;
    worker: any;
    draw: (o: any, u: any) => void;
    update: (o: any, u: any) => void;
    clear: () => void;
    init: () => void;
    stop: () => void;
    start: () => void;
    set: (o: any, u: any) => void;
    terminate: () => void;
};
declare function R2(t: any, e: any): any;
declare namespace ne {
    export { I2 as Renderer };
    export { N2 as transferCanvas };
    export { V2 as setupCanvas };
    export { _ as setDraw };
    export { L2 as drawFrame };
    export { D2 as clearCanvas };
    export { H2 as initCanvas };
    export { R2 as updateCanvas };
    export { U2 as setProps };
    export { E as startAnim };
    export { x2 as stopAnim };
    export { h as getCanvas };
}
declare function X(i3: any): boolean;
declare function Y(i3: any, e: any, t: any): any;
declare function Y2(t: any, e: any, n: any): void;
declare function d(n: any, a: any, r: any): void;
declare function P2(t: any, e: any): void;
declare function m(t: any, e: any, n: any): void;
declare function $2(t: any, e: any, n: any): void;
declare function A2(t: any, e: any, n: any): void;
declare function B2(n: any, a: any, r: any): void;
declare function K(t: any, e: any, n: any): void;
declare function z2(t: any, e: any, n: any): void;
declare function q2(t: any, e: any): any;
declare function M2(t: any, e: any): any;
export { b2 as ElementProxyReceiver, w2 as EventDispatcher, g as ProxyManager, I2 as Renderer, D2 as clearCanvas, L2 as drawFrame, c as eventHandlers, h as getCanvas, H2 as initCanvas, p as initProxyElement, v as proxyElementWorkerRoutes, _ as setDraw, U2 as setProps, V2 as setupCanvas, E as startAnim, x2 as stopAnim, N2 as transferCanvas, R2 as updateCanvas, ne as workerCanvasRoutes };
