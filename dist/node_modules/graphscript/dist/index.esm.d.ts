export var DOMElement: {
    new (): {
        template: (self2: any, props: any) => string;
        props: {};
        useShadow: boolean;
        styles: any;
        oncreate: any;
        onresize: any;
        ondelete: any;
        onchanged: any;
        renderonchanged: boolean;
        FRAGMENT: any;
        STYLE: any;
        attachedShadow: boolean;
        obsAttributes: string[];
        readonly observedAttributes: string[];
        attributeChangedCallback: (name2: any, old: any, val: any) => void;
        ONRESIZE: ((ev: any) => void) | ((ev: any) => void);
        connectedCallback(): void;
        delete: () => void;
        render: (props?: {}) => void;
        templateResult: any;
        state: {
            pushToState: {};
            data: {};
            triggers: {};
            setState(updateObj: any): {};
            subscribeTrigger(key: any, onchanged?: (res: any) => void): number;
            unsubscribeTrigger(key: any, sub: any): boolean;
            subscribeTriggerOnce(key?: any, onchanged?: (value: any) => void): void;
        };
        accessKey: string;
        readonly accessKeyLabel: string;
        autocapitalize: string;
        dir: string;
        draggable: boolean;
        hidden: boolean;
        inert: boolean;
        innerText: string;
        lang: string;
        readonly offsetHeight: number;
        readonly offsetLeft: number;
        readonly offsetParent: Element;
        readonly offsetTop: number;
        readonly offsetWidth: number;
        outerText: string;
        spellcheck: boolean;
        title: string;
        translate: boolean;
        attachInternals(): ElementInternals;
        click(): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        readonly attributes: NamedNodeMap;
        readonly classList: DOMTokenList;
        className: string;
        readonly clientHeight: number;
        readonly clientLeft: number;
        readonly clientTop: number;
        readonly clientWidth: number;
        id: string;
        readonly localName: string;
        readonly namespaceURI: string;
        onfullscreenchange: (this: Element, ev: Event) => any;
        onfullscreenerror: (this: Element, ev: Event) => any;
        outerHTML: string;
        readonly ownerDocument: Document;
        readonly part: DOMTokenList;
        readonly prefix: string;
        readonly scrollHeight: number;
        scrollLeft: number;
        scrollTop: number;
        readonly scrollWidth: number;
        readonly shadowRoot: ShadowRoot;
        slot: string;
        readonly tagName: string;
        attachShadow(init: ShadowRootInit): ShadowRoot;
        checkVisibility(options?: CheckVisibilityOptions): boolean;
        closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
        closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
        closest<K_4 extends keyof MathMLElementTagNameMap>(selector: K_4): MathMLElementTagNameMap[K_4];
        closest<E extends Element = Element>(selectors: string): E;
        computedStyleMap(): StylePropertyMapReadOnly;
        getAttribute(qualifiedName: string): string;
        getAttributeNS(namespace: string, localName: string): string;
        getAttributeNames(): string[];
        getAttributeNode(qualifiedName: string): Attr;
        getAttributeNodeNS(namespace: string, localName: string): Attr;
        getBoundingClientRect(): DOMRect;
        getClientRects(): DOMRectList;
        getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
        getElementsByTagName<K_5 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<HTMLElementTagNameMap[K_5]>;
        getElementsByTagName<K_6 extends keyof SVGElementTagNameMap>(qualifiedName: K_6): HTMLCollectionOf<SVGElementTagNameMap[K_6]>;
        getElementsByTagName<K_7 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7): HTMLCollectionOf<MathMLElementTagNameMap[K_7]>;
        getElementsByTagName<K_8 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8]>;
        getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
        getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
        getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
        getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
        getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
        hasAttribute(qualifiedName: string): boolean;
        hasAttributeNS(namespace: string, localName: string): boolean;
        hasAttributes(): boolean;
        hasPointerCapture(pointerId: number): boolean;
        insertAdjacentElement(where: InsertPosition, element: Element): Element;
        insertAdjacentHTML(position: InsertPosition, text: string): void;
        insertAdjacentText(where: InsertPosition, data: string): void;
        matches(selectors: string): boolean;
        releasePointerCapture(pointerId: number): void;
        removeAttribute(qualifiedName: string): void;
        removeAttributeNS(namespace: string, localName: string): void;
        removeAttributeNode(attr: Attr): Attr;
        requestFullscreen(options?: FullscreenOptions): Promise<void>;
        requestPointerLock(): void;
        scroll(options?: ScrollToOptions): void;
        scroll(x: number, y: number): void;
        scrollBy(options?: ScrollToOptions): void;
        scrollBy(x: number, y: number): void;
        scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
        scrollTo(options?: ScrollToOptions): void;
        scrollTo(x: number, y: number): void;
        setAttribute(qualifiedName: string, value: string): void;
        setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
        setAttributeNode(attr: Attr): Attr;
        setAttributeNodeNS(attr: Attr): Attr;
        setPointerCapture(pointerId: number): void;
        toggleAttribute(qualifiedName: string, force?: boolean): boolean;
        webkitMatchesSelector(selectors: string): boolean;
        readonly baseURI: string;
        readonly childNodes: NodeListOf<ChildNode>;
        readonly firstChild: ChildNode;
        readonly isConnected: boolean;
        readonly lastChild: ChildNode;
        readonly nextSibling: ChildNode;
        readonly nodeName: string;
        readonly nodeType: number;
        nodeValue: string;
        readonly parentElement: HTMLElement;
        readonly parentNode: ParentNode;
        readonly previousSibling: ChildNode;
        textContent: string;
        appendChild<T extends Node>(node: T): T;
        cloneNode(deep?: boolean): Node;
        compareDocumentPosition(other: Node): number;
        contains(other: Node): boolean;
        getRootNode(options?: GetRootNodeOptions): Node;
        hasChildNodes(): boolean;
        insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
        isDefaultNamespace(namespace: string): boolean;
        isEqualNode(otherNode: Node): boolean;
        isSameNode(otherNode: Node): boolean;
        lookupNamespaceURI(prefix: string): string;
        lookupPrefix(namespace: string): string;
        normalize(): void;
        removeChild<T_2 extends Node>(child: T_2): T_2;
        replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
        readonly ELEMENT_NODE: 1;
        readonly ATTRIBUTE_NODE: 2;
        readonly TEXT_NODE: 3;
        readonly CDATA_SECTION_NODE: 4;
        readonly ENTITY_REFERENCE_NODE: 5;
        readonly ENTITY_NODE: 6;
        readonly PROCESSING_INSTRUCTION_NODE: 7;
        readonly COMMENT_NODE: 8;
        readonly DOCUMENT_NODE: 9;
        readonly DOCUMENT_TYPE_NODE: 10;
        readonly DOCUMENT_FRAGMENT_NODE: 11;
        readonly NOTATION_NODE: 12;
        readonly DOCUMENT_POSITION_DISCONNECTED: 1;
        readonly DOCUMENT_POSITION_PRECEDING: 2;
        readonly DOCUMENT_POSITION_FOLLOWING: 4;
        readonly DOCUMENT_POSITION_CONTAINS: 8;
        readonly DOCUMENT_POSITION_CONTAINED_BY: 16;
        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
        dispatchEvent(event: Event): boolean;
        ariaAtomic: string;
        ariaAutoComplete: string;
        ariaBusy: string;
        ariaChecked: string;
        ariaColCount: string;
        ariaColIndex: string;
        ariaColSpan: string;
        ariaCurrent: string;
        ariaDisabled: string;
        ariaExpanded: string;
        ariaHasPopup: string;
        ariaHidden: string;
        ariaInvalid: string;
        ariaKeyShortcuts: string;
        ariaLabel: string;
        ariaLevel: string;
        ariaLive: string;
        ariaModal: string;
        ariaMultiLine: string;
        ariaMultiSelectable: string;
        ariaOrientation: string;
        ariaPlaceholder: string;
        ariaPosInSet: string;
        ariaPressed: string;
        ariaReadOnly: string;
        ariaRequired: string;
        ariaRoleDescription: string;
        ariaRowCount: string;
        ariaRowIndex: string;
        ariaRowSpan: string;
        ariaSelected: string;
        ariaSetSize: string;
        ariaSort: string;
        ariaValueMax: string;
        ariaValueMin: string;
        ariaValueNow: string;
        ariaValueText: string;
        role: string;
        animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
        getAnimations(options?: GetAnimationsOptions): Animation[];
        after(...nodes: (string | Node)[]): void;
        before(...nodes: (string | Node)[]): void;
        remove(): void;
        replaceWith(...nodes: (string | Node)[]): void;
        innerHTML: string;
        readonly nextElementSibling: Element;
        readonly previousElementSibling: Element;
        readonly childElementCount: number;
        readonly children: HTMLCollection;
        readonly firstElementChild: Element;
        readonly lastElementChild: Element;
        append(...nodes: (string | Node)[]): void;
        prepend(...nodes: (string | Node)[]): void;
        querySelector<K_9 extends keyof HTMLElementTagNameMap>(selectors: K_9): HTMLElementTagNameMap[K_9];
        querySelector<K_10 extends keyof SVGElementTagNameMap>(selectors: K_10): SVGElementTagNameMap[K_10];
        querySelector<K_11 extends keyof MathMLElementTagNameMap>(selectors: K_11): MathMLElementTagNameMap[K_11];
        querySelector<K_12 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12): HTMLElementDeprecatedTagNameMap[K_12];
        querySelector<E_1 extends Element = Element>(selectors: string): E_1;
        querySelectorAll<K_13 extends keyof HTMLElementTagNameMap>(selectors: K_13): NodeListOf<HTMLElementTagNameMap[K_13]>;
        querySelectorAll<K_14 extends keyof SVGElementTagNameMap>(selectors: K_14): NodeListOf<SVGElementTagNameMap[K_14]>;
        querySelectorAll<K_15 extends keyof MathMLElementTagNameMap>(selectors: K_15): NodeListOf<MathMLElementTagNameMap[K_15]>;
        querySelectorAll<K_16 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16]>;
        querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
        replaceChildren(...nodes: (string | Node)[]): void;
        readonly assignedSlot: HTMLSlotElement;
        readonly attributeStyleMap: StylePropertyMap;
        readonly style: CSSStyleDeclaration;
        contentEditable: string;
        enterKeyHint: string;
        inputMode: string;
        readonly isContentEditable: boolean;
        onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
        onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
        onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onbeforeinput: (this: GlobalEventHandlers, ev: InputEvent) => any;
        onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
        oncancel: (this: GlobalEventHandlers, ev: Event) => any;
        oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
        oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
        onchange: (this: GlobalEventHandlers, ev: Event) => any;
        onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onclose: (this: GlobalEventHandlers, ev: Event) => any;
        oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        oncopy: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
        oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
        oncut: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
        ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
        ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
        onemptied: (this: GlobalEventHandlers, ev: Event) => any;
        onended: (this: GlobalEventHandlers, ev: Event) => any;
        onerror: OnErrorEventHandlerNonNull;
        onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
        onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
        ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        oninput: (this: GlobalEventHandlers, ev: Event) => any;
        oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
        onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
        onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
        onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
        onload: (this: GlobalEventHandlers, ev: Event) => any;
        onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
        onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
        onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
        onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
        onpaste: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
        onpause: (this: GlobalEventHandlers, ev: Event) => any;
        onplay: (this: GlobalEventHandlers, ev: Event) => any;
        onplaying: (this: GlobalEventHandlers, ev: Event) => any;
        onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
        onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
        onratechange: (this: GlobalEventHandlers, ev: Event) => any;
        onreset: (this: GlobalEventHandlers, ev: Event) => any;
        onscroll: (this: GlobalEventHandlers, ev: Event) => any;
        onsecuritypolicyviolation: (this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any;
        onseeked: (this: GlobalEventHandlers, ev: Event) => any;
        onseeking: (this: GlobalEventHandlers, ev: Event) => any;
        onselect: (this: GlobalEventHandlers, ev: Event) => any;
        onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
        onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
        onslotchange: (this: GlobalEventHandlers, ev: Event) => any;
        onstalled: (this: GlobalEventHandlers, ev: Event) => any;
        onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
        onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
        ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
        ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
        ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
        ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
        onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
        onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
        onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
        onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
        autofocus: boolean;
        readonly dataset: DOMStringMap;
        nonce?: string;
        tabIndex: number;
        blur(): void;
        focus(options?: FocusOptions): void;
    };
    readonly tag: string;
    addElement(tag?: string, cls?: any, extend?: any): void;
};
export var E2EEService: {
    new (options: any, keys2: any, secureKeys: any, secret: any): {
        name: string;
        keys: any;
        securedKeys: boolean;
        encryptedkeys: any;
        secret: any;
        addKey: (key: any, _id: any) => any;
        encrypt(message: any, key: any): any;
        decrypt(message: any, key: any): any;
        encryptRoute: (message: any, keyId: any) => any;
        decryptRoute: (message: any, keyId: any) => any;
        transmit: (message: any, keyId: any) => any;
        receive: (message: any, keyId: any) => any;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        terminate: (...args: any[]) => void;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
    generateSecret(): any;
};
export var ECSService: {
    new (options: any): {
        entities: {};
        systems: {};
        entityMap: Map<any, any>;
        entityKeyMap: Map<any, any>;
        order: any[];
        animating: boolean;
        entityCt: number;
        systemCt: number;
        updateEntities: (order: any[], filter: any, debug?: boolean) => void;
        animateEntities: (filter: boolean, order: any) => void;
        stop: () => void;
        start: (filter: any) => void;
        addEntities: (prototype: any, components?: {}, count?: number) => string[];
        addEntity: (prototype?: {}, components?: {}) => any;
        addSystems: (systems: {}, order: any) => {};
        addSystem: (prototype: any, setupEntities: any, setupEntity: any, operator: any, remove: any, order: any) => any;
        setupEntity: (entity: any) => void;
        removeEntity: (tag: any) => any;
        removeEntities(entities: any): void;
        removeSystem: (tag: any) => any;
        filterObject(o: any, filter: any): {
            [k: string]: any;
        };
        setEntities: (entities: any, props: any) => boolean;
        setEntity: (entity: any, props: any) => any;
        bufferValues: (entities: any, property: any, keys2: any, buffer: any) => any;
        name: string;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        transmit: (...args: any[]) => any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        terminate: (...args: any[]) => void;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var ElementProxyReceiver: {
    new (): {
        __listeners: {};
        proxied: any;
        style: {};
        width: any;
        left: any;
        right: any;
        top: any;
        height: any;
        readonly clientWidth: any;
        readonly clientHeight: any;
        setPointerCapture: () => void;
        releasePointerCapture: () => void;
        getBoundingClientRect: () => {
            left: any;
            top: any;
            width: any;
            height: any;
            right: any;
            bottom: any;
        };
        handleEvent: (data: any) => void;
        focus(): void;
        blur(): void;
        addEventListener(type: any, listener: any): void;
        hasEventListener(type: any, listener: any): boolean;
        removeEventListener(type: any, listener: any): void;
        dispatchEvent(event: any, target: any): void;
    };
};
export var EventDispatcher: {
    new (): {
        __listeners: any;
        addEventListener(type: any, listener: any): void;
        hasEventListener(type: any, listener: any): boolean;
        removeEventListener(type: any, listener: any): void;
        dispatchEvent(event: any, target: any): void;
    };
};
export var EventHandler: {
    new (data: any): {
        data: {};
        triggers: {};
        ctr: number;
        setState: (updateObj: any) => {};
        setValue: (key: any, value: any) => void;
        triggerEvent: (key: any, value: any) => void;
        subscribeState: (onchange: any) => number;
        unsubscribeState: (sub: any) => boolean;
        subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
        unsubscribeEvent: (key: any, sub: any) => boolean;
        subscribeEventOnce: (key: any, onchange: any) => number;
        getEvent: (key: any, sub: any) => any;
        getSnapshot: () => void;
        onRemoved: any;
    };
};
export var Graph: {
    new (options: any): {
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var GraphNode: {
    new (properties: any, parent: any, graph: any): {
        __node: {
            tag: string;
            unique: string;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
        };
        __children: any;
        __parent: any;
        __operator: any;
        __listeners: any;
        __props: any;
        __args: any;
        __setProperties: (properties: any, parent: any, graph: any) => void;
        __onconnected: any;
        __ondisconnected: any;
        __subscribe: (callback: any, key: any, subInput: any, target: any, tkey: any, args: any) => number;
        __unsubscribe: (sub: any, key: any, unsubInput: any) => boolean;
        __setOperator: (fn: any) => any;
        __subscribedToParent: boolean;
        __addLocalState: (props: any, key: any) => void;
        __proxyObject: (obj: any) => void;
        __addOnconnected(callback: any): void;
        __addOndisconnected(callback: any): void;
        __callConnected(node?: any): void;
        __callDisconnected(node?: any): void;
    };
};
export var HTTPfrontend: {
    new (options: any, path: any, fetched: any): {
        name: string;
        fetchProxied: boolean;
        listening: {};
        GET: (url: string, type: string, mimeType: any) => Promise<any>;
        POST: (message: any, url: string, type: string, mimeType: any) => Promise<any>;
        transmit: (message: any, url: any) => Promise<any>;
        transponder: (url: any, message: any, type: string, mimeType: any) => Promise<any>;
        listen: (path?: string, fetched?: (clone: any, args: any, response: any) => Promise<void>) => string;
        stopListening: (path: any, listener: any) => void;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        terminate: (...args: any[]) => void;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var ProxyManager: {
    new (): {
        targets: {};
        makeProxy: (id: any, addTo?: any) => void;
        getProxy: (id: any) => any;
        handleEvent: (data: any, id: any) => boolean;
    };
};
export function Renderer(options: any): any;
export var Router: {
    new (options: any): {
        name: string;
        connections: {};
        sources: {};
        services: {};
        serviceConnections: {};
        users: {};
        userTimeout: number;
        order: any;
        addUser: (info: any, connections: any, config: any, receiving: any) => Promise<any>;
        removeUser(profile: any, terminate: any): boolean;
        getConnection: (sourceId: any, hasMethod: any, connectionId: any) => any;
        getConnections: (sourceId: any, hasMethod: any, props: any) => any;
        runConnection: (userId: any, method: any, args: any, connectionId: any) => Promise<any>;
        subscribeThroughConnection: (route: any, remoteRelay: any, remoteEndpoint: any, callback: any, ...args: any[]) => Promise<any>;
        addConnection: (options: any, source: any) => {
            connectionType: string;
            connectionsKey: any;
            source: any;
            connection: any;
            send(message: any): Promise<any>;
            request(message: any, method: any): Promise<any>;
            post(route: any, args: any, method: any): Promise<any>;
            run: any;
            subscribe(callback: any): Promise<any>;
            unsubscribe(sub: any): Promise<any>;
            terminate(): boolean;
            onclose: any;
            service: any;
            _id: any;
        };
        removeConnection: (connection: any, terminate?: boolean) => boolean;
        routeService: (service: any, connections: any, source: any, order: any) => void;
        addServiceConnections: (service: any, connectionsKey: any, source: any) => {};
        openConnection: (service: any, options: any, source: any, ...args: any[]) => Promise<void | {
            connectionType: string;
            connectionsKey: any;
            source: any;
            connection: any;
            send(message: any): Promise<any>;
            request(message: any, method: any): Promise<any>;
            post(route: any, args: any, method: any): Promise<any>;
            run: any;
            subscribe(callback: any): Promise<any>;
            unsubscribe(sub: any): Promise<any>;
            terminate(): boolean;
            onclose: any;
            service: any;
            _id: any;
        }>;
        terminate: (connection: any) => any;
        routeConnections: (route: any, transmitter: any, receiver: any, ...args: any[]) => Promise<any>;
        setUserData: (user: any, data: any) => boolean;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        transmit: (...args: any[]) => any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var SSEfrontend: {
    new (options: any): {
        name: string;
        eventsources: {};
        connections: {
            eventsources: {};
        };
        openSSE: (options: any) => any;
        open: (options: any) => any;
        POST: (message: any, url: string, type: string, mimeType: any) => Promise<any>;
        transmit: (message: any, url: any) => Promise<any>;
        request: (message: any, url: any, method: any, sessionId: any) => Promise<any>;
        runRequest: (message: any, url: any, callbackId: any, sessionId: any) => any;
        subscribeSSE: (route: any, url: any, args: any, key: any, subInput: any) => number;
        subscribeToSSE: (route: any, url: any, callback: any, args: any, key: any, subInput: any, sessionId: any) => any;
        terminate: (sse: any) => void;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var Service: {
    new (options: any): {
        name: string;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        transmit: (...args: any[]) => any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        terminate: (...args: any[]) => void;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var SessionsService: {
    new (options: any, users: any): {
        name: string;
        users: {};
        sessions: {
            private: {};
            shared: {};
        };
        getSessionInfo: (sessionId: any, userId: any) => {};
        openPrivateSession: (options: {}, userId: any) => any;
        openSharedSession: (options: any, userId: any) => any;
        open: (options: any, userId: any) => void;
        updateSession: (options: any, userId: any) => any;
        joinSession: (sessionId: any, userId: any, options: any) => any;
        leaveSession: (sessionId: any, userId: any, clear?: boolean) => boolean;
        getFirstMatch(obj1: any, obj2: any): string | false;
        swapHost: (session: any, newHostId: any) => boolean;
        deleteSession: (sessionId: any, userId: any) => boolean;
        subscribeToSession: (session: any, userId: any, onmessage: any, onopen: any, onclose: any) => any;
        sessionUpdateCheck: (transmit?: boolean) => {
            private: {};
            shared: {};
        };
        transmitSessionUpdates: (updates: any) => {};
        receiveSessionUpdates: (origin: any, update: any) => any;
        getUpdatedUserData: (user: any) => {};
        userUpdateCheck: (user: any) => {};
        setUserProps: (user: any, props: any) => boolean;
        STREAMLATEST: number;
        STREAMALLLATEST: number;
        streamSettings: {};
        streamFunctions: {
            allLatestValues: (prop: any, setting: any) => any;
            latestValue: (prop: any, setting: any) => any;
        };
        setStreamFunc: (name2: any, key: any, callback?: (prop: any, setting: any) => any) => boolean;
        addStreamFunc: (name2: any, callback?: (data: any) => void) => void;
        setStream: (object: {}, settings: {}, streamName: string, onupdate: any, onclose: any) => any;
        removeStream: (streamName: any, key: any) => boolean;
        updateStreamData: (streamName: any, data?: {}) => any;
        getStreamUpdate: (streamName: any) => {};
        getAllStreamUpdates: () => {};
        streamLoop: {
            __operator: () => {};
            __node: {
                loop: number;
            };
        };
        userUpdateLoop: {
            __operator: (user: any) => {};
            __node: {
                loop: number;
            };
        };
        sessionLoop: {
            __operator: (transmit?: boolean) => {
                private: {};
                shared: {};
            };
            __node: {
                loop: number;
            };
        };
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        transmit: (...args: any[]) => any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        terminate: (...args: any[]) => void;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var WSSfrontend: {
    new (options: any): {
        name: string;
        sockets: {};
        connections: {
            sockets: {};
        };
        openWS: (options?: {
            host: string;
            port: number;
            path: any;
            protocol: string;
            onclose: (ev: any, socket: any, wsinfo: any) => void;
        }) => any;
        open: (options?: {
            host: string;
            port: number;
            path: any;
            protocol: string;
            onclose: (ev: any, socket: any, wsinfo: any) => void;
        }) => any;
        transmit: (data: any, ws: any) => boolean;
        terminate: (ws: any) => boolean;
        request: (message: any, ws: any, _id: any, method: any) => Promise<any>;
        runRequest: (message: any, ws: any, callbackId: any) => any;
        subscribeSocket: (route: any, socket: any, args: any, key: any, subInput: any) => number;
        subscribeToSocket: (route: any, socketId: any, callback: any, args: any, key: any, subInput: any) => any;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var WebRTCfrontend: {
    new (options: any, iceServers: any): {
        name: string;
        rtc: {};
        unanswered: {};
        iceServers: {
            urls: string[];
        }[];
        connections: {
            rtc: {};
        };
        openRTC: (options: any) => Promise<any>;
        open: (options: any) => Promise<any>;
        addIceCandidate: (rtc: any, candidate: any) => any;
        receiveCallInformation: (options: any) => Promise<any>;
        answerCall: (options: any) => Promise<any>;
        rejectCall: (options: any) => boolean;
        negotiateCall: (rtc: any, description: any, polite: any) => Promise<string>;
        createOffer(rtc: any, options: any): Promise<any>;
        createAnswer(rtc: any, options: any): Promise<any>;
        answerPeer: (rtc: any, options: any) => Promise<any>;
        createStream: (options: any) => MediaStream;
        addUserMedia: (rtc: any, options: {
            audio: boolean;
            video: {
                optional: {
                    minWidth: number;
                }[];
            };
        }, info: any) => Promise<any>;
        addTrack: (rtc: any, track: any, stream: any) => any;
        removeTrack: (rtc: any, sender: any) => boolean;
        addDataChannel: (rtc: any, name2: any, options: any) => any;
        enableAudio: (call: any, audioOptions?: boolean) => Promise<any>;
        enableVideo: (call: any, videoOptions?: {
            optional: {
                minWidth: number;
            }[];
        }, includeAudio?: boolean) => Promise<any>;
        disableAudio(call: any): void;
        disableVideo(call: any): void;
        transmit: (data: any, id: any, channel: any) => boolean;
        terminate: (rtc: any) => boolean;
        request: (message: any, channel: any, _id: any, method: any) => Promise<any>;
        runRequest: (message: any, channelOrRtcId: any, callbackId: any) => any;
        subscribeRTC: (route: any, rtcId: any, args: any, key: any, subInput: any, channel: any) => number;
        subscribeToRTC: (route: any, rtcId: any, channelId: any, callback: any, args: any, key: any, subInput: any) => any;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export var WorkerService: {
    new (options: any): {
        name: string;
        workers: {};
        threadRot: number;
        connections: {
            workers: {};
        };
        loadWorkerRoute: (rt: any, routeKey: any) => any;
        workerloader: {
            workers: (node: any, parent: any, graph: any, roots: any) => any;
        };
        addDefaultMessageListener: () => void;
        postMessage: (message: any, target: any, transfer: any) => void;
        addWorker: (options: any) => any;
        open: (options: any) => any;
        close: () => void;
        toObjectURL: (scriptTemplate: any) => string;
        getTransferable(message: any): any[];
        transmit: (message: any, worker: any, transfer: any) => any;
        terminate: (worker: any) => boolean;
        establishMessageChannel: (worker: any, worker2: any) => string | false;
        request: (message: any, workerId: any, transfer: any, method: any) => Promise<any>;
        runRequest: (message: any, worker: any, callbackId: any) => any;
        subscribeWorker: (route: any, worker: any, args: any, key: any, subInput: any, blocking: any) => number;
        subscribeToWorker: (route: any, workerId: any, callback: any, args: any, key: any, subInput: any, blocking: any) => any;
        triggerSubscription: (route: any, workerId: any, result: any) => Promise<boolean>;
        pipeWorkers: (sourceWorker: any, listenerWorker: any, sourceRoute: any, listenerRoute: any, portId: any, args: any, key: any, subInput: any, blocking: any) => any;
        unpipeWorkers: (sourceRoute: any, sourceWorker: any, sub: any) => any;
        addServices: (services: any) => void;
        set: (tag: any, node: any) => Map<any, any>;
        delete: (tag: any) => boolean;
        handleMethod: (route: any, method: any, args: any) => any;
        handleServiceMessage(message: any): any;
        handleGraphNodeCall(route: any, args: any): any;
        receive: (...args: any[]) => any;
        pipe: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        pipeOnce: (source: any, destination: any, endpoint: any, method: any, callback: any) => number;
        isTypedArray: typeof isTypedArray;
        recursivelyAssign: (target: any, obj: any) => any;
        spliceTypedArray: typeof spliceTypedArray;
        ping: () => string;
        echo: (...args: any[]) => any[];
        log: (...args: any[]) => boolean;
        error: (...args: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (updateObj: any) => {};
                setValue: (key: any, value: any) => void;
                triggerEvent: (key: any, value: any) => void;
                subscribeState: (onchange: any) => number;
                unsubscribeState: (sub: any) => boolean;
                subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
                unsubscribeEvent: (key: any, sub: any) => boolean;
                subscribeEventOnce: (key: any, onchange: any) => number;
                getEvent: (key: any, sub: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (options: any) => void;
        load: (roots: any) => any;
        setLoaders: (loaders2: any, replace: any) => any;
        runLoaders: (node: any, parent: any, properties: any, key: any) => void;
        add: (properties: any, parent: any) => any;
        recursiveSet: (t2: any, parent: any, listeners: {}, origin: any) => {};
        remove: (node: any, clearListeners?: boolean) => any;
        run: (node: any, ...args: any[]) => any;
        setListeners: (listeners: any) => void;
        clearListeners: (node: any, listener: any) => void;
        get: (tag: any) => any;
        getProps: (node: any, getInitial: any) => void;
        subscribe: (nodeEvent: any, onEvent: any, args: any, key: any, subInput: any, target: any, bound: any, tkey: any) => number;
        unsubscribe: (node: any, sub: any, key: any, subInput: any) => any;
        setState: (update: any) => void;
    };
};
export function addCustomElement(cls: any, tag: any, extend?: any): void;
export function animate(node: any, parent: any, graph: any): void;
export function backprop(node: any, parent: any, graph: any): void;
export function bindListener(node: any, parent: any, graph: any): void;
export function branching(node: any, parent: any, graph: any): void;
export function clearCanvas(_id: any): any;
export function connectionHasId(connection: any, timeout?: number): Promise<any>;
export function drawFrame(props: any, _id: any): any;
export namespace eventHandlers {
    export { preventDefaultHandler as contextmenu };
    export { mouseEventHandler as mousedown };
    export { mouseEventHandler as mousemove };
    export { mouseEventHandler as mouseup };
    export { mouseEventHandler as pointerdown };
    export { mouseEventHandler as pointermove };
    export { mouseEventHandler as pointerup };
    export { mouseEventHandler as pointerlockchange };
    export { mouseEventHandler as webkitpointerlockchange };
    export { focusEventHandler as focus };
    export { focusEventHandler as blur };
    export { mouseEventHandler as pointerout };
    export { touchEventHandler as touchstart };
    export { touchEventHandler as touchmove };
    export { touchEventHandler as touchend };
    export { wheelEventHandler as wheel };
    export { filteredKeydownEventHandler as keydown };
    export { filteredKeydownEventHandler as keyup };
}
export function getAllProperties(obj: any): any[];
export function getCallbackFromString(a: any, graph: any): (...inp: any[]) => any;
export function getCanvas(_id: any): any;
export function htmlloader(node: any, parent: any, graph: any, roots: any, properties: any, key: any): void;
export function initCanvas(_id: any): any;
export function initProxyElement(element: any, worker: any, id: any, preventDefault: any): any;
export function instanceObject(obj: any): {};
export function isFunction(x: any): "" | "function" | "class" | "async" | "arrow";
export function isNativeClass(thing: any): boolean;
export function isTypedArray(x: any): boolean;
export namespace loaders {
    export { backprop };
    export { loop };
    export { animate };
    export { branching };
    export { triggerListenerOncreate };
    export { bindListener };
    export { transformListenerResult };
    export { substitute__operator };
}
export function loop(node: any, parent: any, graph: any): void;
export function methodstrings(node: any): void;
export var nodeTemplates: {};
export function parseFunctionFromText(method?: string): any;
export namespace proxyElementWorkerRoutes {
    export { initProxyElement };
    export { makeProxy };
    export { handleProxyEvent };
}
export function reconstructObject(json?: string): any;
declare function recursivelyAssign2(target: any, obj: any): any;
export function recursivelyStringifyFunctions(obj: any): {};
export namespace remoteGraphRoutes {
    function transferNode(properties: any, connection: any, name2: any): any;
    function setNode(properties: any, name2: any): any;
    function proxyRemoteNode(name2: any, connection: any): Promise<any>;
    function makeNodeTransferrable(properties: any, name2: any): {};
    function setTemplate(properties: any, name2: any): any;
    function loadFromTemplate(templateName: any, name2: any, properties: any): any;
    function setMethod(nodeTag: any, fn: any, methodKey: any): boolean;
    function assignNode(nodeTag: any, source: any): void;
    function getNodeProperties(nodeTag: any): {};
    function transferClass(classObj: any, connection: any, className: any): any;
    function receiveClass(stringified: any, className: any): boolean;
    function transferFunction(fn: any, connection: any, fnName: any): any;
    function setGlobal(key: any, value: any): boolean;
    function assignGlobalObject(target: any, source: any): boolean;
    function setValue(key: any, value: any): boolean;
    function assignObject(target: any, source: any): boolean;
    function setGlobalFunction(fn: any, fnName: any): boolean;
    function setGraphFunction(fn: any, fnName: any): boolean;
}
export function setDraw(settings: any, _id: any): any;
export function setProps(props: any, _id: any): any;
export function setupCanvas(options: any): any;
export function spliceTypedArray(arr: any, start: any, end: any): any;
export function startAnim(_id: any, draw: any): any;
export var state: {
    data: {};
    triggers: {};
    ctr: number;
    setState: (updateObj: any) => {};
    setValue: (key: any, value: any) => void;
    triggerEvent: (key: any, value: any) => void;
    subscribeState: (onchange: any) => number;
    unsubscribeState: (sub: any) => boolean;
    subscribeEvent: (key: any, onchange: any, refObject: any, refKey: any) => number;
    unsubscribeEvent: (key: any, sub: any) => boolean;
    subscribeEventOnce: (key: any, onchange: any) => number;
    getEvent: (key: any, sub: any) => any;
    getSnapshot: () => void;
    onRemoved: any;
};
export function stopAnim(_id: any): any;
export function stringifyFast(obj: any, space: any): string;
export function stringifyWithCircularRefs(obj: any, space: any): string;
export function substitute__operator(node: any, parent: any, graph: any): void;
export function transferCanvas(worker: any, options: any, route: any): {
    _id: any;
    width: any;
    height: any;
    worker: any;
    draw: (props: any, transfer: any) => void;
    update: (props: any, transfer: any) => void;
    clear: () => void;
    init: () => void;
    stop: () => void;
    start: () => void;
    set: (newDrawProps: any, transfer: any) => void;
    terminate: () => void;
};
export function transformListenerResult(node: any, parent: any, graph: any): void;
export function triggerListenerOncreate(node: any, parent: any, graph: any): void;
export function updateCanvas(input: any, _id: any): any;
export function wchtmlloader(node: any, parent: any, graph: any, roots: any, properties: any, key: any): void;
export namespace workerCanvasRoutes {
    export { Renderer };
    export { transferCanvas };
    export { setupCanvas };
    export { setDraw };
    export { drawFrame };
    export { clearCanvas };
    export { initCanvas };
    export { updateCanvas };
    export { setProps };
    export { startAnim };
    export { stopAnim };
    export { getCanvas };
}
export function wrapArgs(callback: any, argOrder: any, graph: any): {
    __callback: any;
    __args: any[];
};
declare function preventDefaultHandler(event: any, sendFn: any, preventDefault: any): void;
declare function mouseEventHandler(event: any, sendFn: any): void;
declare function focusEventHandler(event: any, sendFn: any): void;
declare function touchEventHandler(event: any, sendFn: any, preventDefault: any): void;
declare function wheelEventHandler(event: any, sendFn: any, preventDefault: any): void;
declare function filteredKeydownEventHandler(event: any, sendFn: any, preventDefault: any): void;
declare function makeProxy(id: any, elm: any): any;
declare function handleProxyEvent(data: any, id: any): any;
export { recursivelyAssign2 as recursivelyAssign };
